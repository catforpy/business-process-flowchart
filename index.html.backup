<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>前端App与后端交互业务流程（详细版）</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        h1, h2, h3 {
            color: #007bff;
        }
        .section {
            margin-bottom: 20px;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .step {
            cursor: pointer;
            padding: 10px;
            margin: 5px 0;
            background-color: #e9ecef;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        .step:hover {
            background-color: #d6d8db;
        }
        .details {
            display: none;
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-left: 4px solid #007bff;
        }
        .tooltip {
            position: absolute;
            background-color: #f8f9fa;
            border: 1px solid #007bff;
            border-radius: 5px;
            padding: 10px;
            max-width: 300px;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .tooltip .close-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            cursor: pointer;
            font-size: 16px;
            color: #007bff;
        }
        button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .module {
            background-color: #fff3cd;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>前端App与后端交互业务流程（详细版）</h1>
    <p>基于您的描述，重新梳理了详细业务流程，强调网关分发、数据校验、缓存策略、分库分表、冷热数据分离、备份等。整体设计高度解耦、高度内聚，模块化架构。</p>

    <div id="flowchart" class="section">
        <h2>整体架构与流程图</h2>
        <div class="mermaid">
            graph TD
                A[前端App/Web] --> B{连接类型}
                B -->|HTTP| C[Nginx网关<br/>健康检查]
                B -->|WebSocket| C
                C -->|健康主服务| D1[核心主后端服务]
                C -->|健康备用服务| D2[核心备用后端服务]
                C -->|功能拆分主| D3[拆分功能主后端服务]
                C -->|功能拆分备| D4[拆分功能备用后端服务]
                D1 --> F[用户中台模块: 认证校验]
                D2 --> F
                D3 --> F
                D4 --> F
                F --> G[业务模块: 操作处理]
                G --> DBOp{需要数据库操作}
                DBOp -->|是| H{读/写操作}
                DBOp -->|否| X[返回Nginx网关]
                X --> C
                H -->|读| I[Redis哨兵集群<br/>获取主节点地址]
                I --> J[Redis主节点查询]
                J -->|命中| K[返回数据]
                K --> G
                J -->|未命中| L[数据库查询]
                L --> M[更新Redis主节点]
                M --> K
                H -->|写| N[Redis哨兵<br/>获取主节点地址]
                N --> O[Redis主节点检查]
                O -->|有数据| P[更新Redis主节点 & 事务更新DB]
                O -->|无数据| Q[查询DB & 事务更新DB & 更新Redis主节点]
                P --> R[定时刷新Redis-DB]
                Q --> R
                R --> S[分库分表处理]
                S --> T{数据类型}
                T -->|热数据| U[独立热数据服务器]
                T -->|冷数据| V[集合冷数据服务器]
                V --> W[冷数据备份: 一个月前数据到备份DB]
                W --> Y[可查询冷DB]
                U --> Z[事务保护]
                V --> Z
                I -.监控.-> AA[Redis哨兵监控<br/>主从节点健康]
                AA -.自动故障转移.-> AB[Redis从节点提升主节点]
                AB -.通知.-> I
                N -.监控.-> AA
                C -.健康检查.-> AC[后端服务健康监控]
                AC -.主服务故障.-> AD[Nginx自动切换备用服务]
        </div>
    </div>

    <button onclick="toggleAllDetails()">展开/折叠所有详情</button>

    <div class="section">
        <h2>1. 前端发送环节</h2>
        <div class="step" onclick="toggleDetails('frontend')">点击查看详情</div>
        <div id="frontend" class="details">
            <p><strong>连接类型区分：</strong></p>
            <ul>
                <li><strong>普通网络连接（HTTP）：</strong>用于标准请求/响应，如GET/POST。</li>
                <li><strong>WebSocket连接：</strong>用于实时双向通信，如聊天、推送。</li>
            </ul>
            <p><strong>网关分发：</strong>Nginx作为网关，负责负载均衡、路由分发到后端服务。</p>
        </div>
    </div>

    <div class="section">
        <h2>2. 后端接收与校验环节</h2>
        <div class="step" onclick="toggleDetails('validation')">点击查看详情</div>
        <div id="validation" class="details">
            <p><strong>数据校验：</strong></p>
            <ul>
                <li>ID匹配：验证请求中的用户ID。</li>
                <li>Token匹配：JWT/OAuth验证用户身份。</li>
            </ul>
            <p><strong>用户确定：</strong>通过校验确定用户上下文，路由到相应业务模块。</p>
        </div>
    </div>

    <div class="section">
        <h2>3. 业务处理环节（读写操作）</h2>
        <div class="step" onclick="toggleDetails('business')">点击查看详情</div>
        <div id="business" class="details">
            <p><strong>读操作：</strong></p>
            <ol>
                <li>优先查询Redis缓存。</li>
                <li>未命中则查询数据库。</li>
                <li>查询后立即更新Redis（事务性）。</li>
            </ol>
            <p><strong>写操作：</strong></p>
            <ol>
                <li>检查Redis是否有数据。</li>
                <li>有：更新Redis和数据库（事务）。</li>
                <li>无：查询数据库，更新数据库和Redis（事务）。</li>
            </ol>
            <p><strong>Redis-DB同步：</strong>定时刷新机制，确保一致性。</p>
        </div>
    </div>

    <div class="section">
        <h2>4. 数据库架构与优化</h2>
        <div class="step" onclick="toggleDetails('database')">点击查看详情</div>
        <div id="database" class="details">
            <p><strong>分库分表：</strong>根据业务拆分数据库和表，降低单库压力。</p>
            <p><strong>热数据分离：</strong></p>
            <ul>
                <li>频繁查询热数据：抽取到独立服务器。</li>
                <li>不频繁冷数据：放到集合服务器。</li>
            </ul>
            <p><strong>事务保护：</strong>确保读写一致性，避免并发问题。</p>
            <p><strong>冷热数据备份：</strong>一个月前数据备份到冷数据库，支持查询但性能较低。</p>
        </div>
    </div>

    <div class="section">
        <h2>5. Redis哨兵机制（Redis Sentinel）</h2>
        <div class="step" onclick="toggleDetails('sentinel')">点击查看详情</div>
        <div id="sentinel" class="details">
            <p><strong>哨兵核心概念：</strong>Redis哨兵是Redis高可用性的解决方案，用于监控、通知和自动故障转移。</p>
            <p><strong>主要功能：</strong></p>
            <ul>
                <li><strong>监控（Monitoring）：</strong>持续监控Redis主节点和从节点是否正常运行。</li>
                <li><strong>通知（Notification）：</strong>当被监控的Redis服务器出现问题时，通过API通知系统管理员或其他应用。</li>
                <li><strong>自动故障转移（Automatic Failover）：</strong>主节点故障时，自动将从节点提升为新的主节点。</li>
                <li><strong>配置提供者（Configuration Provider）：</strong>客户端连接哨兵获取当前主节点的地址。</li>
            </ul>
            <p><strong>哨兵工作流程：</strong></p>
            <ol>
                <li><strong>健康检查：</strong>哨兵定期向所有Redis节点发送PING命令，检查节点状态。</li>
                <li><strong>主观下线（Subjectively Down）：</strong>单个哨兵认为主节点下线（主观判断）。</li>
                <li><strong>客观下线（Objectively Down）：</strong>多个哨兵通过协商确认主节点下线（客观判断）。</li>
                <li><strong>故障转移：</strong>哨兵集群选举领头哨兵，由领头哨兵执行故障转移：
                    <ul>
                        <li>从从节点中选择一个新的主节点（优先级、复制偏移量、运行ID）。</li>
                        <li>将其他从节点重新配置为复制新的主节点。</li>
                        <li>将旧主节点（恢复后）配置为从节点。</li>
                    </ul>
                </li>
                <li><strong>通知应用：</strong>应用通过哨兵获取新的主节点地址，自动切换连接。</li>
            </ol>
            <p><strong>哨兵架构：</strong></p>
            <ul>
                <li><strong>哨兵节点数：</strong>至少3个哨兵节点（奇数），避免脑裂。</li>
                <li><strong>部署方式：</strong>哨兵节点应该部署在不同的物理机或容器中。</li>
                <li><strong>仲裁机制：</strong>当quorum个哨兵确认主节点下线时，才触发故障转移。</li>
            </ul>
            <p><strong>应用集成：</strong></p>
            <ul>
                <li>应用不直接连接Redis主节点，而是连接哨兵集群。</li>
                <li>哨兵返回当前主节点的地址。</li>
                <li>主节点切换时，应用自动获取新主节点地址。</li>
            </ul>
            <p><strong>与数据库主备的区别：</strong></p>
            <ul>
                <li><strong>Redis哨兵：</strong>只负责Redis层面的高可用，自动切换Redis主从。</li>
                <li><strong>数据库主备：</strong>需要其他机制（如MHA、Orchestrator）实现自动切换。</li>
                <li><strong>后端服务主备：</strong>通过Nginx健康检查实现，不属于哨兵范畴。</li>
            </ul>
        </div>
    </div>

    <div class="section">
        <h2>6. 后端服务高可用架构</h2>
        <div class="step" onclick="toggleDetails('backend-ha')">点击查看详情</div>
        <div id="backend-ha" class="details">
            <p><strong>后端服务分类：</strong></p>
            <ul>
                <li><strong>核心主后端服务：</strong>处理核心业务逻辑的主服务器。</li>
                <li><strong>核心备用后端服务：</strong>核心业务的备用服务器，主服务故障时接管。</li>
                <li><strong>拆分功能主后端服务：</strong>特定功能（如AI推理、高资源占用）的主服务器。</li>
                <li><strong>拆分功能备用后端服务：</strong>特定功能的备用服务器。</li>
            </ul>
            <p><strong>Nginx健康检查机制：</strong></p>
            <ul>
                <li><strong>主动健康检查：</strong>Nginx定期向后端服务发送健康检查请求。</li>
                <li><strong>被动健康检查：</strong>根据请求响应判断服务状态（连续失败标记为不健康）。</li>
                <li><strong>自动故障转移：</strong>主服务故障时，Nginx自动将流量切换到备用服务。</li>
                <li><strong>恢复检测：</strong>故障服务恢复后，健康检查通过后重新加入负载均衡。</li>
            </ul>
            <p><strong>Nginx配置示例：</strong></p>
            <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px;">
upstream backend_core {
    server 192.168.2.10:8080 max_fails=3 fail_timeout=30s;  # 主服务
    server 192.168.2.11:8080 backup;  # 备用服务
}

upstream backend_ai {
    server 192.168.2.20:8080 max_fails=3 fail_timeout=30s;  # AI主服务
    server 192.168.2.21:8080 backup;  # AI备用服务
}

# 主动健康检查（需要nginx_plus或第三方模块）
check interval=3000 rise=2 fall=3 timeout=1000;
            </pre>
            <p><strong>与Redis哨兵的区别：</strong></p>
            <ul>
                <li><strong>Redis哨兵：</strong>专门用于Redis数据库的自动故障转移。</li>
                <li><strong>Nginx健康检查：</strong>用于应用层（后端服务）的负载均衡和故障转移。</li>
                <li><strong>配合使用：</strong>Nginx负责后端服务的高可用，哨兵负责Redis的高可用，两者独立工作。</li>
            </ul>
            <p><strong>完整的高可用流程：</strong></p>
            <ol>
                <li>用户请求 → Nginx网关</li>
                <li>Nginx通过健康检查选择健康的后端服务（主服务优先）</li>
                <li>后端服务连接Redis哨兵获取主节点地址</li>
                <li>操作Redis主节点或数据库</li>
                <li>如果主服务故障，Nginx自动切换到备用服务</li>
                <li>如果Redis主节点故障，哨兵自动提升从节点为主节点</li>
                <li>后端服务从哨兵获取新的Redis主节点地址</li>
            </ol>
        </div>
    </div>

    <div class="section">
        <h2>7. 模块化设计（高度解耦、内聚）</h2>
        <div class="step" onclick="toggleDetails('modules')">点击查看详情</div>
        <div id="modules" class="details">
            <div class="module"><strong>用户中台模块：</strong>负责认证、用户管理、权限控制。</div>
            <div class="module"><strong>缓存模块：</strong>Redis操作、定时刷新逻辑。</div>
            <div class="module"><strong>数据库模块：</strong>ORM、分库分表、事务管理。</div>
            <div class="module"><strong>业务模块：</strong>具体业务逻辑，如订单、查询等。</div>
            <div class="module"><strong>网关模块：</strong>Nginx配置、路由分发、健康检查。</div>
            <div class="module"><strong>哨兵模块：</strong>Redis哨兵集群，监控和自动故障转移。</div>
            <div class="module"><strong>备份模块：</strong>冷数据迁移、备份策略。</div>
            <p>每个模块独立部署，支持微服务架构。</p>
        </div>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: true });

        window.addEventListener('load', function() {
            console.log('Window loaded');
            // 等待Mermaid渲染完成
            setTimeout(function() {
                console.log('Timeout triggered');
                const svg = document.querySelector('.mermaid svg');
                console.log('SVG found:', svg);
                if (svg) {
                    const texts = svg.querySelectorAll('text');
                    const tspans = svg.querySelectorAll('tspan');
                    const gs = svg.querySelectorAll('g');
                    console.log('Texts found:', texts.length);
                    console.log('Tspans found:', tspans.length);
                    console.log('Gs found:', gs.length);
                    gs.forEach(g => {
                        const text = g.textContent.trim();
                        console.log('Checking node:', text);

                        // 精确匹配各个节点 - 注意判断顺序，精确匹配放在前面
                        if (text === 'HTTP' ||
                            text === 'WebSocket' ||
                            text === '前端App/Web' ||
                            text === '连接类型' ||
                            text === '核心主后端服务' ||
                            text === '核心备用后端服务' ||
                            text === '拆分功能主后端服务' ||
                            text === '拆分功能备用后端服务' ||
                            text === '用户中台模块: 认证校验' ||
                            text === '业务模块: 操作处理' ||
                            text === '需要数据库操作' ||
                            text === '读/写操作' ||
                            text === '返回Nginx网关' ||
                            text === '数据类型' ||
                            text.includes('Redis哨兵集群') ||
                            text.includes('Redis哨兵监控') ||
                            text.includes('Redis主节点查询') ||
                            text.includes('Redis主节点检查') ||
                            text.includes('Redis哨兵') ||
                            text.includes('后端服务健康监控') ||
                            text.includes('Nginx网关')) {

                            console.log('Matched node:', text);
                            g.style.cursor = 'pointer';
                            g.addEventListener('click', function() {
                                let type;

                                // 按照精确度从高到低判断
                                if (text === 'HTTP') type = 'HTTP';
                                else if (text === 'WebSocket') type = 'WebSocket';
                                else if (text === '连接类型') type = 'connection-type';
                                else if (text === '前端App/Web') type = 'frontend';
                                else if (text === '核心主后端服务' || text === '核心备用后端服务' ||
                                        text === '拆分功能主后端服务' || text === '拆分功能备用后端服务') type = 'backend';
                                else if (text === '用户中台模块: 认证校验') type = 'user-middle-tier';
                                else if (text === '业务模块: 操作处理') type = 'business-module';
                                else if (text === '需要数据库操作') type = 'need-db';
                                else if (text === '读/写操作') type = 'read-write';
                                else if (text === '返回Nginx网关') type = 'return-nginx';
                                else if (text === '数据类型') type = 'data-type';
                                else if (text.includes('Redis哨兵集群') || text.includes('Redis哨兵监控')) type = 'redis-sentinel';
                                else if (text.includes('Redis主节点查询') || text.includes('Redis主节点检查')) type = 'redis-master';
                                else if (text.includes('后端服务健康监控')) type = 'health-monitor';
                                else if (text.includes('Nginx网关')) type = 'nginx';

                                console.log('Clicked type:', type, 'for text:', text);
                                toggleTooltip(this, type);
                            });
                        }
                    });
                    [...texts, ...tspans].forEach(text => {
                        const content = text.textContent.trim();
                        console.log('Text/Tspan content:', content);
                        if (content.includes('HTTP') || content.includes('WebSocket')) {
                            console.log('Match found for:', content);
                            text.style.cursor = 'pointer';
                            text.style.fill = '#007bff'; // 蓝色表示可点击
                            text.addEventListener('click', function() {
                                const type = content.includes('HTTP') ? 'HTTP' : 'WebSocket';
                                console.log('Clicked:', type);
                                toggleTooltip(this, type);
                            });
                        }
                    });
                }
            }, 2000); // 增加延迟到2秒
        });

        let currentTooltip = null;
        let currentTarget = null;

        function toggleTooltip(target, type) {
            if (currentTooltip && currentTarget === target) {
                // 隐藏
                document.body.removeChild(currentTooltip);
                currentTooltip = null;
                currentTarget = null;
                return;
            }

            // 隐藏之前的
            if (currentTooltip) {
                document.body.removeChild(currentTooltip);
            }

            // 创建新的
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';

            let content = '';
            if (type === 'HTTP') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>HTTP连接说明</h4>
                    <p><strong>定义：</strong>超文本传输协议，用于客户端和服务器之间的请求-响应通信。</p>
                    <p><strong>特点：</strong>无状态、简单、易扩展。</p>
                    <p><strong>案例：</strong>用户登录、提交表单、API调用。</p>
                    <p><strong>优势：</strong>广泛支持，易缓存。</p>
                    <p><strong>劣势：</strong>不适合实时通信。</p>
                `;
            } else if (type === 'WebSocket') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>WebSocket连接说明</h4>
                    <p><strong>定义：</strong>全双工通信协议，允许服务器推送数据。</p>
                    <p><strong>特点：</strong>持久连接、低延迟、双向。</p>
                    <p><strong>案例：</strong>聊天、实时通知、游戏。</p>
                    <p><strong>优势：</strong>实时性强。</p>
                    <p><strong>劣势：</strong>实现复杂。</p>
                `;
            } else if (type === 'frontend') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>前端App/Web准备数据说明</h4>
                    <p><strong>基础校验数据：</strong></p>
                    <ul>
                        <li><strong>Token：</strong>根据用户ID生成，具有唯一性，用于身份验证。</li>
                        <li><strong>Token位置：</strong>通常放在HTTP请求头（Header）中，如Authorization: Bearer <token>。不建议放在请求体（Data）中，以避免暴露。</li>
                        <li><strong>其他必传数据：</strong>用户ID（用于关联）、时间戳（防止重放攻击）、请求签名（可选，用于额外安全）。</li>
                    </ul>
                    <p><strong>业务数据：</strong>根据具体操作上传，如表单数据、文件等（标识化处理）。</p>
                    <p><strong>注意：</strong>确保数据格式正确，敏感信息加密传输。</p>
                `;
            } else if (type === 'nginx') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>Nginx网关说明</h4>
                    <p><strong>作用：</strong>作为反向代理和负载均衡器，接收前端请求，分发到后端服务。</p>
                    <p><strong>主要功能：</strong></p>
                    <ul>
                        <li>负载均衡：轮询、IP哈希、最少连接等算法。</li>
                        <li>SSL/TLS终止：处理HTTPS加密。</li>
                        <li>缓存：静态资源缓存，减少后端压力。</li>
                        <li>安全：防火墙、限流、DDoS防护。</li>
                        <li>日志记录：请求日志，便于监控。</li>
                    </ul>
                    <p><strong>配置示例：</strong>upstream backend { server 127.0.0.1:8080; server 127.0.0.1:8081; } location /api { proxy_pass http://backend; }</p>
                    <p><strong>优势：</strong>高性能、轻量、易扩展。</p>
                `;
            } else if (type === 'distribution') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>分发到后端服务说明</h4>
                    <p><strong>作用：</strong>将请求分发到多个后端服务器，实现负载均衡和高可用性。</p>
                    <p><strong>主要功能：</strong></p>
                    <ul>
                        <li>负载均衡：根据算法（如轮询、权重）分配请求到不同服务器。</li>
                        <li>故障转移：检测服务器健康状态，自动切换到可用服务器。</li>
                        <li>扩展性：支持动态添加/移除服务器。</li>
                        <li>性能优化：减少单点压力，提高响应速度。</li>
                    </ul>
                    <p><strong>示例：</strong>请求被分发到后端服务1、2、3中的一个或多个。</p>
                    <p><strong>优势：</strong>提高系统可用性和性能。</p>
                `;
            } else if (type === 'backend') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>后端服务高可用架构</h4>
                    <p><strong>服务分类说明：</strong></p>
                    <ul>
                        <li><strong>核心主后端服务：</strong>处理核心业务逻辑的主服务器，正常情况下处理所有请求。</li>
                        <li><strong>核心备用后端服务：</strong>核心业务的备用服务器，主服务故障时自动接管。</li>
                        <li><strong>拆分功能主后端服务：</strong>特定功能（如AI推理、高资源占用业务）的主服务器。</li>
                        <li><strong>拆分功能备用后端服务：</strong>特定功能的备用服务器，主服务故障时自动接管。</li>
                    </ul>
                    <p><strong>Nginx健康检查机制：</strong></p>
                    <ul>
                        <li><strong>主动健康检查：</strong>Nginx定期向后端服务发送健康检查请求（如/health端点）。</li>
                        <li><strong>被动健康检查：</strong>根据请求响应判断服务状态，连续失败max_fails次标记为不健康。</li>
                        <li><strong>自动故障转移：</strong>主服务故障时，Nginx自动将流量切换到备用服务（backup服务器）。</li>
                        <li><strong>恢复检测：</strong>故障服务恢复后，健康检查通过后重新加入负载均衡池。</li>
                    </ul>
                    <p><strong>Nginx配置示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
upstream backend_core {
    server 192.168.2.10:8080 max_fails=3 fail_timeout=30s;
    server 192.168.2.11:8080 backup;
}

upstream backend_ai {
    server 192.168.2.20:8080 max_fails=3 fail_timeout=30s;
    server 192.168.2.21:8080 backup;
}
                    </pre>
                    <p><strong>与Redis哨兵的区别：</strong></p>
                    <ul>
                        <li><strong>Redis哨兵：</strong>专门用于Redis数据库的自动故障转移，监控Redis主从节点。</li>
                        <li><strong>Nginx健康检查：</strong>用于应用层（后端服务）的负载均衡和故障转移。</li>
                        <li><strong>配合使用：</strong>Nginx负责后端服务的高可用，哨兵负责Redis的高可用，两者独立工作。</li>
                    </ul>
                    <p><strong>完整的高可用流程：</strong></p>
                    <ol>
                        <li>用户请求 → Nginx网关</li>
                        <li>Nginx通过健康检查选择健康的后端服务（主服务优先）</li>
                        <li>后端服务连接Redis哨兵获取主节点地址</li>
                        <li>操作Redis主节点或数据库</li>
                        <li>如果主服务故障，Nginx自动切换到备用服务</li>
                        <li>如果Redis主节点故障，哨兵自动提升从节点为主节点</li>
                        <li>后端服务从哨兵获取新的Redis主节点地址</li>
                    </ol>
                    <p><strong>优势：</strong>提高可用性、性能和安全性，实现应用层和数据层的双重高可用。</p>
                `;
            } else if (type === 'user-middle-tier') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>用户中台模块: 认证校验与ID生成</h4>
                    <p><strong>核心功能：</strong>生成全局唯一ID，用于用户注册时的手机号、名字、密码等信息。</p>
                    <p><strong>数据库设计：</strong></p>
                    <ul>
                        <li><strong>号段概念：</strong>预分配ID号段，避免每次生成都访问数据库。</li>
                        <li><strong>步长概念：</strong>每次申请的ID数量，控制性能。</li>
                        <li><strong>表结构：</strong>t_id_generate_config，管理所有业务的ID生成配置。</li>
                    </ul>
                    <p><strong>并发控制机制：</strong></p>
                    <ul>
                        <li><strong>信号量：</strong>保证只有一个线程申请新号段，避免并发冲突。</li>
                        <li><strong>乐观锁：</strong>version字段控制并发更新，只有匹配版本的线程才能成功。</li>
                        <li><strong>异步线程池：</strong>号段刷新异步执行，不阻塞ID生成。</li>
                        <li><strong>阈值策略：</strong>号段使用率超过75%时异步申请新号段。</li>
                    </ul>
                    <p><strong>核心机制：</strong>一张表管理所有业务的ID生成，支持扩展枚举(IdTypeEnum)添加新业务类型。</p>
                    <p><strong>数据隔离方式：</strong></p>
                    <table border="1" style="border-collapse: collapse; width: 100%;">
                        <thead>
                            <tr>
                                <th>id</th>
                                <th>remark</th>
                                <th>step</th>
                                <th>current_start</th>
                                <th>next_threshold</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>1</td>
                                <td>用户ID</td>
                                <td>1000</td>
                                <td>1000</td>
                                <td>2000</td>
                            </tr>
                            <tr>
                                <td>2</td>
                                <td>订单ID</td>
                                <td>5000</td>
                                <td>10000</td>
                                <td>15000</td>
                            </tr>
                            <tr>
                                <td>3</td>
                                <td>礼物ID</td>
                                <td>10000</td>
                                <td>100000</td>
                                <td>110000</td>
                            </tr>
                            <tr>
                                <td>4</td>
                                <td>房间ID</td>
                                <td>1000</td>
                                <td>1000000</td>
                                <td>1001000</td>
                            </tr>
                        </tbody>
                    </table>
                    <p><strong>示例：</strong>用户ID从1开始，订单ID从10000开始，各有独立号段和步长配置。</p>
                `;
            } else if (type === 'business-module') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>业务模块: 操作处理</h4>
                    <p><strong>模块功能：</strong>根据用户请求进行具体业务逻辑处理，区分是否需要数据库操作。</p>
                    <p><strong>处理逻辑：</strong></p>
                    <ul>
                        <li><strong>无需数据库操作：</strong>直接返回前端，数据闭环完成。</li>
                        <li><strong>需要数据库操作：</strong>进入Redis查询流程。</li>
                    </ul>
                    <p><strong>Redis查询命中后的循环处理：</strong></p>
                    <ul>
                        <li>数据返回业务模块，由业务模块再次处理。</li>
                        <li>业务模块判断是否需要进一步查询数据库。</li>
                        <li>如果需要，继续走数据库查询逻辑。</li>
                        <li>如果不需要，直接返回前端。</li>
                    </ul>
                    <p><strong>不需要读写查询数据库的操作（直接返回）：</strong></p>
                    <ul>
                        <li><strong>纯计算操作：</strong>如数学计算、数据格式转换、加密解密等。</li>
                        <li><strong>缓存查询：</strong>从Redis等缓存中获取数据，无需访问数据库。</li>
                        <li><strong>静态数据返回：</strong>返回配置数据、常量、枚举值等。</li>
                        <li><strong>外部API调用：</strong>调用第三方服务，处理结果后返回。</li>
                        <li><strong>状态检查：</strong>检查系统状态、服务可用性等。</li>
                    </ul>
                    <p><strong>需要读写查询数据库的操作（继续流程）：</strong></p>
                    <ul>
                        <li><strong>数据查询：</strong>从数据库读取用户数据、历史记录等。</li>
                        <li><strong>数据写入：</strong>插入新记录、更新现有数据、删除操作。</li>
                        <li><strong>事务处理：</strong>涉及多表操作，需要保证数据一致性。</li>
                        <li><strong>复杂业务逻辑：</strong>需要结合数据库数据进行判断和处理。</li>
                        <li><strong>数据验证：</strong>检查数据完整性、业务规则验证。</li>
                    </ul>
                    <p><strong>处理流程：</strong>根据操作类型决定是否进入读/写数据库流程，支持循环处理以优化性能。</p>
                `;
            } else if (type === 'redis-sentinel') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>Redis哨兵（Redis Sentinel）</h4>
                    <p><strong>核心作用：</strong>Redis高可用解决方案，监控Redis主从架构，自动故障转移。</p>
                    <p><strong>主要功能：</strong></p>
                    <ul>
                        <li><strong>监控：</strong>持续监控Redis主节点和从节点的健康状态。</li>
                        <li><strong>通知：</strong>Redis节点故障时，通知系统管理员和应用程序。</li>
                        <li><strong>自动故障转移：</strong>主节点故障时，自动将从节点提升为新的主节点。</li>
                        <li><strong>配置中心：</strong>为客户端提供当前主节点的地址。</li>
                    </ul>
                    <p><strong>故障转移流程：</strong></p>
                    <ol>
                        <li>哨兵检测到主节点下线（主观下线 → 客观下线）</li>
                        <li>哨兵集群选举领头哨兵</li>
                        <li>领头哨兵选择最优从节点提升为新主节点</li>
                        <li>其他从节点重新配置复制新主节点</li>
                        <li>通知应用程序新的主节点地址</li>
                    </ol>
                    <p><strong>重要概念：</strong></p>
                    <ul>
                        <li><strong>主观下线（SDOWN）：</strong>单个哨兵认为主节点下线</li>
                        <li><strong>客观下线（ODOWN）：</strong>多个哨兵协商确认主节点下线</li>
                        <li><strong>Quorum：</strong>触发客观下线所需的哨兵数量</li>
                        <li><strong>脑裂：</strong>多个主节点同时存在的异常情况，通过奇数个哨兵避免</li>
                    </ul>
                    <p><strong>与后端服务主备的区别：</strong></p>
                    <ul>
                        <li>哨兵只负责Redis层面，不涉及应用服务器</li>
                        <li>后端服务主备通过Nginx健康检查实现</li>
                        <li>两者独立工作，共同保障系统高可用</li>
                    </ul>
                `;
            } else if (type === 'need-db') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>需要数据库操作判断</h4>
                    <p><strong>作用：</strong>判断当前业务操作是否需要访问数据库。</p>
                    <p><strong>判断依据：</strong></p>
                    <ul>
                        <li><strong>需要数据库：</strong>涉及数据查询、数据写入、事务处理等操作。</li>
                        <li><strong>不需要数据库：</strong>纯计算、缓存查询、静态数据返回、外部API调用等。</li>
                    </ul>
                    <p><strong>处理流程：</strong></p>
                    <ul>
                        <li><strong>否：</strong>直接返回结果给前端，完成请求闭环。</li>
                        <li><strong>是：</strong>进入读写操作判断，继续后续流程。</li>
                    </ul>
                    <p><strong>优化目的：</strong>避免不必要的数据库访问，提高响应速度，降低数据库压力。</p>
                `;
            } else if (type === 'read-write') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>读/写操作判断</h4>
                    <p><strong>作用：</strong>区分读操作和写操作，采用不同的处理策略。</p>
                    <p><strong>读操作流程：</strong></p>
                    <ol>
                        <li>通过Redis哨兵获取主节点地址</li>
                        <li>查询Redis主节点缓存</li>
                        <li>命中：直接返回数据</li>
                        <li>未命中：查询数据库，更新Redis缓存</li>
                    </ol>
                    <p><strong>写操作流程：</strong></p>
                    <ol>
                        <li>通过Redis哨兵获取主节点地址</li>
                        <li>检查Redis是否有相关数据</li>
                        <li>有数据：更新Redis和数据库（事务操作）</li>
                        <li>无数据：查询数据库，更新数据库和Redis（事务操作）</li>
                    </ol>
                    <p><strong>注意事项：</strong></p>
                    <ul>
                        <li>写操作必须操作主节点，确保数据一致性</li>
                        <li>读写分离时，读操作可以从节点获取数据</li>
                        <li>事务操作保证原子性，要么全部成功，要么全部失败</li>
                    </ul>
                `;
            } else if (type === 'redis-master') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>Redis主节点（Redis Master）</h4>
                    <p><strong>定义：</strong>Redis主从架构中的主节点，负责处理写操作和读操作。</p>
                    <p><strong>主要职责：</strong></p>
                    <ul>
                        <li><strong>写操作：</strong>接收所有写命令（SET、DEL、LPUSH等）。</li>
                        <li><strong>读操作：</strong>可以处理读请求，但通常通过从节点分担读压力。</li>
                        <li><strong>数据同步：</strong>将写操作同步到所有从节点。</li>
                        <li><strong>故障转移：</strong>故障时由哨兵将从节点提升为新的主节点。</li>
                    </ul>
                    <p><strong>与从节点的区别：</strong></p>
                    <ul>
                        <li><strong>主节点：</strong>可读可写，数据来源为应用写入。</li>
                        <li><strong>从节点：</strong>只读，数据来源为主节点同步。</li>
                    </ul>
                    <p><strong>高可用机制：</strong></p>
                    <ul>
                        <li>通过哨兵监控主节点健康状态</li>
                        <li>主节点故障时自动切换到从节点</li>
                        <li>应用通过哨兵获取当前主节点地址</li>
                    </ul>
                    <p><strong>配置建议：</strong></p>
                    <ul>
                        <li>主节点部署在高性能服务器上</li>
                        <li>建议配置多个从节点（至少1个）</li>
                        <li>使用持久化机制（RDB+AOF）确保数据安全</li>
                    </ul>
                `;
            } else if (type === 'return-nginx') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>返回Nginx网关</h4>
                    <p><strong>作用：</strong>业务处理完成后，将结果返回给Nginx网关，由Nginx返回给前端。</p>
                    <p><strong>返回流程：</strong></p>
                    <ol>
                        <li>业务模块处理完成，生成响应数据</li>
                        <li>后端服务将响应返回给Nginx网关</li>
                        <li>Nginx网关进行必要的处理（如添加响应头、Gzip压缩等）</li>
                        <li>Nginx将响应返回给前端App/Web</li>
                    </ol>
                    <p><strong>适用场景：</strong></p>
                    <ul>
                        <li><strong>不需要数据库操作的业务：</strong>直接返回结果。</li>
                        <li><strong>纯计算操作：</strong>计算完成后返回结果。</li>
                        <li><strong>缓存命中：</strong>从Redis获取数据后返回。</li>
                        <li><strong>静态数据：</strong>返回配置数据或常量。</li>
                    </ul>
                    <p><strong>Nginx处理能力：</strong></p>
                    <ul>
                        <li><strong>负载均衡：</strong>将请求分发到健康的后端服务。</li>
                        <li><strong>反向代理：</strong>隐藏后端服务真实地址。</li>
                        <li><strong>响应缓存：</strong>缓存静态资源，减少后端压力。</li>
                        <li><strong>SSL终止：</strong>处理HTTPS加密解密。</li>
                    </ul>
                    <p><strong>优势：</strong>简化前端对接，统一接口入口，提高系统安全性。</p>
                `;
            } else if (type === 'health-monitor') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>后端服务健康监控</h4>
                    <p><strong>作用：</strong>Nginx持续监控后端服务的健康状态，确保只将流量分发到健康的服务。</p>
                    <p><strong>监控机制：</strong></p>
                    <ul>
                        <li><strong>主动健康检查：</strong>Nginx定期向后端服务发送健康检查请求（默认/health端点）。</li>
                        <li><strong>检查频率：</strong>可配置间隔时间（如每5秒检查一次）。</li>
                        <li><strong>超时设置：</strong>请求超时时间（如3秒未响应视为失败）。</li>
                        <li><strong>失败阈值：</strong>连续失败N次标记为不健康（如max_fails=3）。</li>
                    </ul>
                    <p><strong>健康状态：</strong></p>
                    <ul>
                        <li><strong>健康（Up）：</strong>服务正常运行，可以接收请求。</li>
                        <li><strong>不健康（Down）：</strong>服务故障或超时，不再接收新请求。</li>
                        <li><strong>恢复检测：</strong>不健康的服务恢复后，需要通过健康检查才能重新上线。</li>
                    </ul>
                    <p><strong>故障转移流程：</strong></p>
                    <ol>
                        <li>主服务连续失败max_fails次</li>
                        <li>Nginx将主服务标记为不健康</li>
                        <li>自动将流量切换到备用服务</li>
                        <li>主服务恢复后，健康检查通过重新上线</li>
                    </ol>
                    <p><strong>Nginx配置示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
upstream backend {
    server 192.168.2.10:8080 max_fails=3 fail_timeout=30s;
    server 192.168.2.11:8080 backup;

    # 主动健康检查（需要nginx_plus或第三方模块）
    check interval=5000 rise=2 fall=3 timeout=3000;
}
                    </pre>
                    <p><strong>优势：</strong>提高系统可用性，实现自动故障转移，减少人工干预。</p>
                `;
            } else if (type === 'connection-type') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>连接类型判断</h4>
                    <p><strong>作用：</strong>根据业务需求选择合适的通信协议。</p>
                    <p><strong>连接类型说明：</strong></p>
                    <ul>
                        <li><strong>HTTP连接：</strong>
                            <ul>
                                <li>适用于标准的请求-响应模式</li>
                                <li>无状态协议，每次请求独立</li>
                                <li>适合数据查询、表单提交等操作</li>
                                <li>支持缓存，易于扩展</li>
                            </ul>
                        </li>
                        <li><strong>WebSocket连接：</strong>
                            <ul>
                                <li>适用于实时双向通信场景</li>
                                <li>持久连接，低延迟</li>
                                <li>适合聊天、推送、实时通知等</li>
                                <li>服务器可主动推送数据给客户端</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>选择建议：</strong></p>
                    <ul>
                        <li>需要实时性：选择WebSocket</li>
                        <li>简单请求-响应：选择HTTP</li>
                        <li>需要服务器推送：选择WebSocket</li>
                        <li>需要广泛兼容性：选择HTTP</li>
                    </ul>
                    <p><strong>优势：</strong>灵活适应不同业务场景，优化用户体验和系统性能。</p>
                `;
            } else if (type === 'data-type') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>数据类型判断（热数据/冷数据）</h4>
                    <p><strong>作用：</strong>根据数据访问频率，将数据分类存储到不同的服务器。</p>
                    <p><strong>数据类型说明：</strong></p>
                    <ul>
                        <li><strong>热数据：</strong>
                            <ul>
                                <li>频繁访问的数据</li>
                                <li>最近创建或修改的数据</li>
                                <li>用户活跃数据</li>
                                <li>存储在独立的高性能服务器上</li>
                            </ul>
                        </li>
                        <li><strong>冷数据：</strong>
                            <li>不常访问的历史数据</li>
                            <li>归档数据</li>
                            <li>超过一定时间的数据（如一个月前）</li>
                            <li>存储在集合冷数据服务器上</li>
                        </ul>
                    </ul>
                    <p><strong>处理策略：</strong></p>
                    <ul>
                        <li><strong>热数据：</strong>快速响应，优先处理，使用高性能存储</li>
                        <li><strong>冷数据：</strong>定期备份到冷数据库，支持查询但性能较低</li>
                    </ul>
                    <p><strong>数据迁移：</strong></p>
                    <ul>
                        <li>定期（如每月）将热数据迁移到冷数据库</li>
                        <li>热数据服务器保留最近一段时间的数据</li>
                        <li>冷数据可以压缩存储，降低存储成本</li>
                    </ul>
                    <p><strong>优势：</strong>优化存储资源使用，提高热数据访问速度，降低存储成本。</p>
                `;
            }
            tooltip.innerHTML = content;

            document.body.appendChild(tooltip);

            // 定位到旁边
            const rect = target.getBoundingClientRect();
            const tooltipWidth = 300;
            const tooltipHeight = 200; // 估算
            let left, top = rect.top + window.scrollY;

            if (type === 'WebSocket') {
                left = rect.left + window.scrollX - tooltipWidth - 10;
            } else { // HTTP
                left = rect.right + window.scrollX + 10;
            }

            // 确保不超出视窗
            if (left < 0) left = 10;
            if (left + tooltipWidth > window.innerWidth) left = window.innerWidth - tooltipWidth - 10;
            if (top + tooltipHeight > window.innerHeight + window.scrollY) top = rect.top + window.scrollY - tooltipHeight - 10;

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';

            currentTooltip = tooltip;
            currentTarget = target;
        }

        function closeTooltip() {
            if (currentTooltip) {
                document.body.removeChild(currentTooltip);
                currentTooltip = null;
                currentTarget = null;
            }
        }
    </script>
</body>
</html>