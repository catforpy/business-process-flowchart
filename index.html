<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>前端App与后端交互业务流程（详细版）</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        h1, h2, h3 {
            color: #007bff;
        }
        .section {
            margin-bottom: 20px;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .step {
            cursor: pointer;
            padding: 10px;
            margin: 5px 0;
            background-color: #e9ecef;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        .step:hover {
            background-color: #d6d8db;
        }
        .details {
            display: none;
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-left: 4px solid #007bff;
        }
        .tooltip {
            position: absolute;
            background-color: #f8f9fa;
            border: 1px solid #007bff;
            border-radius: 5px;
            padding: 10px;
            max-width: 300px;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .tooltip .close-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            cursor: pointer;
            font-size: 16px;
            color: #007bff;
        }
        button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .module {
            background-color: #fff3cd;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>前端App与后端交互业务流程（详细版）</h1>
    <p>基于您的描述，重新梳理了详细业务流程，强调网关分发、数据校验、缓存策略、分库分表、冷热数据分离、备份等。整体设计高度解耦、高度内聚，模块化架构。</p>

    <div id="flowchart" class="section">
        <h2>整体架构与流程图</h2>
        <div class="mermaid">
            graph TD
                A[前端App/Web] --> CDN[CDN加速<br/>静态资源]
                CDN --> C
                A --> B{连接类型}
                B -->|HTTP| C[Nginx网关<br/>健康检查]
                B -->|WebSocket| C
                C -->|限流| C1[限流控制<br/>令牌桶/漏桶]
                C1 -->|通过| C2[熔断器<br/>服务熔断]
                C2 -->|健康主服务| D1[核心主后端服务]
                C2 -->|健康备用服务| D2[核心备用后端服务]
                C2 -->|功能拆分主| D3[拆分功能主后端服务]
                C2 -->|功能拆分备| D4[拆分功能备用后端服务]
                C2 -.降级.-> CE[降级处理<br/>默认值/静态页面]
                D1 --> DA[本地缓存<br/>Guava/Caffeine]
                D2 --> DA
                D3 --> DA
                D4 --> DA
                DA --> F[用户中台模块: 认证校验]
                D1 --> F
                D2 --> F
                D3 --> F
                D4 --> F
                F --> G[业务模块: 操作处理]
                G --> GA{需要分布式锁}
                GA -->|是| GB[Redis分布式锁<br/>SETNX/Redlock]
                GA -->|否| GBB[获取锁成功]
                GB --> GBB{抢锁成功}
                GBB -->|是| GBC[执行业务逻辑]
                GBB -->|否| GBW[等待重试]
                GBW --> GB
                GBC --> DBOp{需要数据库操作}
                G --> DBOp
                DBOp -->|是| H{读/写操作}
                DBOp -->|否| X[返回Nginx网关]
                X --> C
                H -->|读| I[Redis哨兵集群<br/>获取主节点地址]
                DA -.多级缓存.-> I
                I --> J[Redis主节点查询]
                J -->|命中| K[返回数据]
                K --> G
                J -->|未命中| L[数据库查询]
                L --> M[更新Redis主节点]
                M --> K
                H -->|写| N[Redis哨兵<br/>获取主节点地址]
                N --> O[Redis主节点检查]
                O -->|有数据| P[更新Redis主节点 & 事务更新DB]
                O -->|无数据| Q[查询DB & 事务更新DB & 更新Redis主节点]
                P --> R[定时刷新Redis-DB]
                Q --> R
                R --> R2[Redis-DB定期同步<br/>数据一致性保障]
                R --> S[分库分表处理]
                R2 --> S
                S --> T{数据类型}
                T -->|热数据| U[独立热数据服务器]
                T -->|冷数据| V[集合冷数据服务器]
                V --> W[冷数据备份: 一个月前数据到备份DB]
                W --> Y[可查询冷DB]
                U --> Z[事务保护]
                V --> Z
                P --> MQ[消息队列<br/>异步解耦]
                Q --> MQ
                MQ --> MQ1[日志服务]
                MQ --> MQ2[统计服务]
                MQ --> MQ3[通知服务]
                I -.监控.-> AA[Redis哨兵监控<br/>主从节点健康]
                AA -.自动故障转移.-> AB[Redis从节点提升主节点]
                AB -.通知.-> I
                N -.监控.-> AA
                C -.健康检查.-> AC[后端服务健康监控]
                AC -.主服务故障.-> AD[Nginx自动切换备用服务]
                A -.全链路追踪.-> MON[全链路监控<br/>SkyWalking/Zipkin]
                C -.日志采集.-> MON
                DA -.缓存监控.-> MON
                I -.Redis监控.-> MON
                S -.数据库监控.-> MON
                MQ -.异步监控.-> MON
                MON -.告警通知.-> ALERT[告警中心<br/>Prometheus/Grafana]
        </div>
    </div>

    <button onclick="toggleAllDetails()">展开/折叠所有详情</button>

    <div class="section">
        <h2>1. 前端发送环节</h2>
        <div class="step" onclick="toggleDetails('frontend')">点击查看详情</div>
        <div id="frontend" class="details">
            <p><strong>连接类型区分：</strong></p>
            <ul>
                <li><strong>普通网络连接（HTTP）：</strong>用于标准请求/响应，如GET/POST。</li>
                <li><strong>WebSocket连接：</strong>用于实时双向通信，如聊天、推送。</li>
            </ul>
            <p><strong>网关分发：</strong>Nginx作为网关，负责负载均衡、路由分发到后端服务。</p>
        </div>
    </div>

    <div class="section">
        <h2>2. 后端接收与校验环节</h2>
        <div class="step" onclick="toggleDetails('validation')">点击查看详情</div>
        <div id="validation" class="details">
            <p><strong>数据校验：</strong></p>
            <ul>
                <li>ID匹配：验证请求中的用户ID。</li>
                <li>Token匹配：JWT/OAuth验证用户身份。</li>
            </ul>
            <p><strong>用户确定：</strong>通过校验确定用户上下文，路由到相应业务模块。</p>
        </div>
    </div>

    <div class="section">
        <h2>3. 业务处理环节（读写操作）</h2>
        <div class="step" onclick="toggleDetails('business')">点击查看详情</div>
        <div id="business" class="details">
            <p><strong>读操作：</strong></p>
            <ol>
                <li>优先查询Redis缓存。</li>
                <li>未命中则查询数据库。</li>
                <li>查询后立即更新Redis（事务性）。</li>
            </ol>
            <p><strong>写操作：</strong></p>
            <ol>
                <li>检查Redis是否有数据。</li>
                <li>有：更新Redis和数据库（事务）。</li>
                <li>无：查询数据库，更新数据库和Redis（事务）。</li>
            </ol>
            <p><strong>Redis-DB同步：</strong>定时刷新机制，确保一致性。</p>
        </div>
    </div>

    <div class="section">
        <h2>4. 数据库架构与优化</h2>
        <div class="step" onclick="toggleDetails('database')">点击查看详情</div>
        <div id="database" class="details">
            <p><strong>分库分表：</strong>根据业务拆分数据库和表，降低单库压力。</p>
            <p><strong>热数据分离：</strong></p>
            <ul>
                <li>频繁查询热数据：抽取到独立服务器。</li>
                <li>不频繁冷数据：放到集合服务器。</li>
            </ul>
            <p><strong>事务保护：</strong>确保读写一致性，避免并发问题。</p>
            <p><strong>冷热数据备份：</strong>一个月前数据备份到冷数据库，支持查询但性能较低。</p>
        </div>
    </div>

    <div class="section">
        <h2>5. Redis哨兵机制（Redis Sentinel）</h2>
        <div class="step" onclick="toggleDetails('sentinel')">点击查看详情</div>
        <div id="sentinel" class="details">
            <p><strong>哨兵核心概念：</strong>Redis哨兵是Redis高可用性的解决方案，用于监控、通知和自动故障转移。</p>
            <p><strong>主要功能：</strong></p>
            <ul>
                <li><strong>监控（Monitoring）：</strong>持续监控Redis主节点和从节点是否正常运行。</li>
                <li><strong>通知（Notification）：</strong>当被监控的Redis服务器出现问题时，通过API通知系统管理员或其他应用。</li>
                <li><strong>自动故障转移（Automatic Failover）：</strong>主节点故障时，自动将从节点提升为新的主节点。</li>
                <li><strong>配置提供者（Configuration Provider）：</strong>客户端连接哨兵获取当前主节点的地址。</li>
            </ul>
            <p><strong>哨兵工作流程：</strong></p>
            <ol>
                <li><strong>健康检查：</strong>哨兵定期向所有Redis节点发送PING命令，检查节点状态。</li>
                <li><strong>主观下线（Subjectively Down）：</strong>单个哨兵认为主节点下线（主观判断）。</li>
                <li><strong>客观下线（Objectively Down）：</strong>多个哨兵通过协商确认主节点下线（客观判断）。</li>
                <li><strong>故障转移：</strong>哨兵集群选举领头哨兵，由领头哨兵执行故障转移：
                    <ul>
                        <li>从从节点中选择一个新的主节点（优先级、复制偏移量、运行ID）。</li>
                        <li>将其他从节点重新配置为复制新的主节点。</li>
                        <li>将旧主节点（恢复后）配置为从节点。</li>
                    </ul>
                </li>
                <li><strong>通知应用：</strong>应用通过哨兵获取新的主节点地址，自动切换连接。</li>
            </ol>
            <p><strong>哨兵架构：</strong></p>
            <ul>
                <li><strong>哨兵节点数：</strong>至少3个哨兵节点（奇数），避免脑裂。</li>
                <li><strong>部署方式：</strong>哨兵节点应该部署在不同的物理机或容器中。</li>
                <li><strong>仲裁机制：</strong>当quorum个哨兵确认主节点下线时，才触发故障转移。</li>
            </ul>
            <p><strong>应用集成：</strong></p>
            <ul>
                <li>应用不直接连接Redis主节点，而是连接哨兵集群。</li>
                <li>哨兵返回当前主节点的地址。</li>
                <li>主节点切换时，应用自动获取新主节点地址。</li>
            </ul>
            <p><strong>与数据库主备的区别：</strong></p>
            <ul>
                <li><strong>Redis哨兵：</strong>只负责Redis层面的高可用，自动切换Redis主从。</li>
                <li><strong>数据库主备：</strong>需要其他机制（如MHA、Orchestrator）实现自动切换。</li>
                <li><strong>后端服务主备：</strong>通过Nginx健康检查实现，不属于哨兵范畴。</li>
            </ul>
        </div>
    </div>

    <div class="section">
        <h2>6. 后端服务高可用架构</h2>
        <div class="step" onclick="toggleDetails('backend-ha')">点击查看详情</div>
        <div id="backend-ha" class="details">
            <p><strong>后端服务分类：</strong></p>
            <ul>
                <li><strong>核心主后端服务：</strong>处理核心业务逻辑的主服务器。</li>
                <li><strong>核心备用后端服务：</strong>核心业务的备用服务器，主服务故障时接管。</li>
                <li><strong>拆分功能主后端服务：</strong>特定功能（如AI推理、高资源占用）的主服务器。</li>
                <li><strong>拆分功能备用后端服务：</strong>特定功能的备用服务器。</li>
            </ul>
            <p><strong>Nginx健康检查机制：</strong></p>
            <ul>
                <li><strong>主动健康检查：</strong>Nginx定期向后端服务发送健康检查请求。</li>
                <li><strong>被动健康检查：</strong>根据请求响应判断服务状态（连续失败标记为不健康）。</li>
                <li><strong>自动故障转移：</strong>主服务故障时，Nginx自动将流量切换到备用服务。</li>
                <li><strong>恢复检测：</strong>故障服务恢复后，健康检查通过后重新加入负载均衡。</li>
            </ul>
            <p><strong>Nginx配置示例：</strong></p>
            <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px;">
upstream backend_core {
    server 192.168.2.10:8080 max_fails=3 fail_timeout=30s;  # 主服务
    server 192.168.2.11:8080 backup;  # 备用服务
}

upstream backend_ai {
    server 192.168.2.20:8080 max_fails=3 fail_timeout=30s;  # AI主服务
    server 192.168.2.21:8080 backup;  # AI备用服务
}

# 主动健康检查（需要nginx_plus或第三方模块）
check interval=3000 rise=2 fall=3 timeout=1000;
            </pre>
            <p><strong>与Redis哨兵的区别：</strong></p>
            <ul>
                <li><strong>Redis哨兵：</strong>专门用于Redis数据库的自动故障转移。</li>
                <li><strong>Nginx健康检查：</strong>用于应用层（后端服务）的负载均衡和故障转移。</li>
                <li><strong>配合使用：</strong>Nginx负责后端服务的高可用，哨兵负责Redis的高可用，两者独立工作。</li>
            </ul>
            <p><strong>完整的高可用流程：</strong></p>
            <ol>
                <li>用户请求 → Nginx网关</li>
                <li>Nginx通过健康检查选择健康的后端服务（主服务优先）</li>
                <li>后端服务连接Redis哨兵获取主节点地址</li>
                <li>操作Redis主节点或数据库</li>
                <li>如果主服务故障，Nginx自动切换到备用服务</li>
                <li>如果Redis主节点故障，哨兵自动提升从节点为主节点</li>
                <li>后端服务从哨兵获取新的Redis主节点地址</li>
            </ol>
        </div>
    </div>

    <div class="section">
        <h2>7. 模块化设计（高度解耦、内聚）</h2>
        <div class="step" onclick="toggleDetails('modules')">点击查看详情</div>
        <div id="modules" class="details">
            <div class="module"><strong>用户中台模块：</strong>负责认证、用户管理、权限控制。</div>
            <div class="module"><strong>缓存模块：</strong>Redis操作、定时刷新逻辑。</div>
            <div class="module"><strong>数据库模块：</strong>ORM、分库分表、事务管理。</div>
            <div class="module"><strong>业务模块：</strong>具体业务逻辑，如订单、查询等。</div>
            <div class="module"><strong>网关模块：</strong>Nginx配置、路由分发、健康检查。</div>
            <div class="module"><strong>哨兵模块：</strong>Redis哨兵集群，监控和自动故障转移。</div>
            <div class="module"><strong>备份模块：</strong>冷数据迁移、备份策略。</div>
            <p>每个模块独立部署，支持微服务架构。</p>
        </div>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: true });

        window.addEventListener('load', function() {
            console.log('Window loaded');
            // 等待Mermaid渲染完成
            setTimeout(function() {
                console.log('Timeout triggered');
                const svg = document.querySelector('.mermaid svg');
                console.log('SVG found:', svg);
                if (svg) {
                    // 定义节点类型映射
                    const nodeTypes = [
                        { text: 'HTTP', type: 'HTTP' },
                        { text: 'WebSocket', type: 'WebSocket' },
                        { text: '前端App/Web', type: 'frontend' },
                        { text: '连接类型', type: 'connection-type' },
                        { text: '核心主后端服务', type: 'backend' },
                        { text: '核心备用后端服务', type: 'backend' },
                        { text: '拆分功能主后端服务', type: 'backend' },
                        { text: '拆分功能备用后端服务', type: 'backend' },
                        { text: '用户中台模块: 认证校验', type: 'user-middle-tier' },
                        { text: '业务模块: 操作处理', type: 'business-module' },
                        { text: '需要数据库操作', type: 'need-db' },
                        { text: '读/写操作', type: 'read-write' },
                        { text: '返回Nginx网关', type: 'return-nginx' },
                        { text: '数据类型', type: 'data-type' },
                        { text: 'Redis哨兵集群', type: 'redis-sentinel-cluster' },
                        { text: 'Redis哨兵', type: 'redis-sentinel-cluster' },
                        { text: 'Redis哨兵监控', type: 'redis-sentinel-monitor' },
                        { text: 'Redis主节点健康', type: 'redis-sentinel-monitor' },
                        { text: 'Redis主节点查询', type: 'redis-read-query' },
                        { text: 'Redis主节点检查', type: 'redis-write-check' },
                        { text: 'Redis从节点提升主节点', type: 'redis-failover' },
                        { text: '有数据', type: 'write-has-data' },
                        { text: '无数据', type: 'write-no-data' },
                        { text: '查询DB & 事务更新DB & 更新Redis主节点', type: 'write-query-db-transaction' },
                        { text: '后端服务健康监控', type: 'health-monitor' },
                        { text: 'Nginx自动切换备用服务', type: 'nginx-switch' },
                        { text: 'Nginx网关', type: 'nginx' },
                        { text: '独立热数据服务器', type: 'hot-data-server' },
                        { text: '集合冷数据服务器', type: 'cold-data-server' },
                        { text: '冷数据备份:', type: 'cold-backup' },
                        { text: '可查询冷DB', type: 'cold-db' },
                        { text: '事务保护', type: 'transaction' },
                        { text: '定时刷新Redis-DB', type: 'redis-refresh' },
                        { text: '分库分表处理', type: 'sharding' },
                        { text: '监控', type: 'sentinel-monitoring-process' },
                        { text: '自动故障转移', type: 'sentinel-failover-process' },
                        { text: '通知', type: 'sentinel-notification-process' },
                        { text: '命中', type: 'cache-hit' },
                        { text: '未命中', type: 'cache-miss' },
                        { text: '数据库查询', type: 'db-query' },
                        { text: '更新Redis主节点', type: 'update-redis-master' },
                        { text: 'CDN加速', type: 'cdn' },
                        { text: '限流控制', type: 'rate-limiter' },
                        { text: '熔断器', type: 'circuit-breaker' },
                        { text: '降级处理', type: 'degradation' },
                        { text: '本地缓存', type: 'local-cache' },
                        { text: '需要分布式锁', type: 'need-distributed-lock' },
                        { text: 'Redis分布式锁', type: 'distributed-lock' },
                        { text: '抢锁成功', type: 'lock-result' },
                        { text: '执行业务逻辑', type: 'execute-business' },
                        { text: '等待重试', type: 'lock-retry' },
                        { text: 'Redis-DB定期同步', type: 'redis-db-sync' },
                        { text: '消息队列', type: 'message-queue' },
                        { text: '日志服务', type: 'mq-log-service' },
                        { text: '统计服务', type: 'mq-stats-service' },
                        { text: '通知服务', type: 'mq-notify-service' },
                        { text: '全链路监控', type: 'full-link-monitoring' },
                        { text: '告警中心', type: 'alert-center' }
                    ];

                    // 查找所有可能包含文本的元素
                    const allElements = svg.querySelectorAll('*');
                    console.log('Total elements found:', allElements.length);

                    // 为每个节点添加点击事件
                    allElements.forEach(element => {
                        const textContent = element.textContent ? element.textContent.trim() : '';

                        // 检查是否匹配我们定义的节点
                        for (let nodeType of nodeTypes) {
                            if (textContent === nodeType.text || textContent.includes(nodeType.text)) {
                                console.log('Matched:', textContent, '->', nodeType.type);

                                // 设置鼠标样式
                                element.style.cursor = 'pointer';

                                // 添加点击事件
                                element.addEventListener('click', function(e) {
                                    e.stopPropagation();
                                    console.log('Clicked:', nodeType.type, 'for text:', textContent);
                                    toggleTooltip(element, nodeType.type);
                                });

                                // 改变颜色提示可点击
                                if (element.tagName === 'text' || element.tagName === 'tspan') {
                                    element.style.fill = '#007bff';
                                }

                                break; // 找到匹配就跳出循环
                            }
                        }
                    });

                    console.log('Tooltip setup completed');
                }
            }, 3000); // 增加延迟到3秒，确保Mermaid完全渲染
        });

        let currentTooltip = null;
        let currentTarget = null;

        function toggleTooltip(target, type) {
            if (currentTooltip && currentTarget === target) {
                // 隐藏
                document.body.removeChild(currentTooltip);
                currentTooltip = null;
                currentTarget = null;
                return;
            }

            // 隐藏之前的
            if (currentTooltip) {
                document.body.removeChild(currentTooltip);
            }

            // 创建新的
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';

            let content = '';
            if (type === 'HTTP') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>HTTP连接说明</h4>
                    <p><strong>定义：</strong>超文本传输协议（HyperText Transfer Protocol），用于客户端和服务器之间的请求-响应通信。</p>
                    <p><strong>主要功能：</strong></p>
                    <ul>
                        <li><strong>请求-响应模式：</strong>客户端发送请求，服务器返回响应</li>
                        <li><strong>无状态协议：</strong>每次请求独立，不保留上下文</li>
                        <li><strong>灵活可扩展：</strong>通过请求头传递元信息</li>
                        <li><strong>支持多种方法：</strong>GET、POST、PUT、DELETE等</li>
                    </ul>
                    <p><strong>重要概念：</strong></p>
                    <ul>
                        <li><strong>无状态：</strong>服务器不保存客户端状态，需要通过Cookie/Session维持会话</li>
                        <li><strong>连接复用：</strong>HTTP/1.1支持keep-alive，减少连接建立开销</li>
                        <li><strong>缓存机制：</strong>支持强缓存和协商缓存，提高性能</li>
                    </ul>
                    <p><strong>应用场景：</strong></p>
                    <ul>
                        <li><strong>用户登录注册：</strong>表单提交、身份验证</li>
                        <li><strong>数据查询：</strong>获取列表、详情、搜索等</li>
                        <li><strong>数据提交：</strong>创建、更新、删除资源</li>
                        <li><strong>文件上传：</strong>图片、视频、文档上传</li>
                        <li><strong>API调用：</strong>RESTful API、GraphQL等</li>
                        <li><strong>页面加载：</strong>HTML、CSS、JS等静态资源加载</li>
                    </ul>
                    <p><strong>优势：</strong>广泛支持、易缓存、简单易用、防火墙友好。</p>
                    <p><strong>劣势：</strong>服务器无法主动推送、每次请求携带头部开销、不适合实时通信。</p>
                `;
            } else if (type === 'WebSocket') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>WebSocket连接说明</h4>
                    <p><strong>定义：</strong>全双工通信协议，在单个TCP连接上提供全双工、双向通信通道，允许服务器主动推送数据给客户端。</p>
                    <p><strong>主要功能：</strong></p>
                    <ul>
                        <li><strong>持久连接：</strong>建立连接后保持打开状态，避免重复握手</li>
                        <li><strong>双向通信：</strong>客户端和服务器可以随时发送消息</li>
                        <li><strong>低延迟：</strong>连接建立后数据传输实时，无需HTTP请求头开销</li>
                        <li><strong>轻量级：</strong>数据帧格式简单，开销小</li>
                    </ul>
                    <p><strong>重要概念：</strong></p>
                    <ul>
                        <li><strong>握手阶段：</strong>使用HTTP进行初始握手，升级为WebSocket协议</li>
                        <li><strong>心跳机制：</strong>定期发送ping/pong帧保持连接活跃</li>
                        <li><strong>连接状态：</strong>CONNECTING、OPEN、CLOSING、CLOSED</li>
                        <li><strong>同源策略：</strong>WebSocket受同源策略限制，需要CORS支持跨域</li>
                    </ul>
                    <p><strong>应用场景：</strong></p>
                    <ul>
                        <li><strong>即时通讯：</strong>聊天室、私聊、群聊、消息推送</li>
                        <li><strong>实时通知：</strong>系统消息、提醒通知、公告推送</li>
                        <li><strong>在线游戏：</strong>多人对战、实时同步、位置更新</li>
                        <li><strong>实时协作：</strong>在线文档、协同编辑、白板共享</li>
                        <li><strong>数据监控：</strong>服务器监控、IoT设备状态、股票行情</li>
                        <li><strong>直播互动：</strong>弹幕、礼物、点赞实时展示</li>
                        <li><strong>位置服务：</strong>实时定位、路线导航、配送跟踪</li>
                    </ul>
                    <p><strong>优势：</strong>实时性强、服务器可主动推送、连接复用、延迟低。</p>
                    <p><strong>劣势：</strong>实现相对复杂、无状态代理服务器支持差、连接管理需要考虑重连机制。</p>
                `;
            } else if (type === 'frontend') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>前端App/Web说明</h4>
                    <p><strong>作用：</strong>用户交互界面，负责接收用户输入，展示数据，与后端服务器进行通信。</p>
                    <p><strong>主要功能：</strong></p>
                    <ul>
                        <li><strong>用户交互：</strong>接收用户操作（点击、输入、滑动等）</li>
                        <li><strong>数据展示：</strong>将后端返回的数据以可视化的方式呈现给用户</li>
                        <li><strong>数据提交：</strong>收集用户输入的数据，发送到后端服务器</li>
                        <li><strong>状态管理：</strong>管理应用状态（如登录状态、用户信息等）</li>
                        <li><strong>本地缓存：</strong>缓存部分数据，提高用户体验</li>
                    </ul>
                    <p><strong>基础校验数据准备：</strong></p>
                    <ul>
                        <li><strong>Token（令牌）：</strong>根据用户ID生成的唯一标识，用于身份验证和授权</li>
                        <li><strong>Token位置：</strong>通常放在HTTP请求头（Header）中，如Authorization: Bearer <token></li>
                        <li><strong>其他必传数据：</strong>
                            <ul>
                                <li>用户ID：用于关联和识别用户</li>
                                <li>时间戳：防止重放攻击</li>
                                <li>请求签名：可选，用于额外安全性验证</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>业务数据准备：</strong></p>
                    <ul>
                        <li>表单数据（用户注册、信息修改等）</li>
                        <li>查询参数（搜索关键词、筛选条件等）</li>
                        <li>文件数据（头像上传、文档上传等）</li>
                        <li>操作指令（点赞、关注、分享等）</li>
                    </ul>
                    <p><strong>技术栈：</strong></p>
                    <ul>
                        <li><strong>移动端：</strong>原生iOS、Android、React Native、Flutter</li>
                        <li><strong>Web端：</strong>HTML、CSS、JavaScript、React、Vue、Angular</li>
                        <li><strong>小程序：</strong>微信小程序、支付宝小程序等</li>
                    </ul>
                    <p><strong>注意事项：</strong>确保数据格式正确，敏感信息加密传输，做好错误处理和用户提示。</p>
                `;
            } else if (type === 'nginx') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>Nginx网关说明</h4>
                    <p><strong>作用：</strong>作为反向代理和负载均衡器，接收前端请求，分发到后端服务。</p>
                    <p><strong>主要功能：</strong></p>
                    <ul>
                        <li>负载均衡：轮询、IP哈希、最少连接等算法。</li>
                        <li>SSL/TLS终止：处理HTTPS加密。</li>
                        <li>缓存：静态资源缓存，减少后端压力。</li>
                        <li>安全：防火墙、限流、DDoS防护。</li>
                        <li>日志记录：请求日志，便于监控。</li>
                    </ul>
                    <p><strong>配置示例：</strong>upstream backend { server 127.0.0.1:8080; server 127.0.0.1:8081; } location /api { proxy_pass http://backend; }</p>
                    <p><strong>优势：</strong>高性能、轻量、易扩展。</p>
                `;
            } else if (type === 'distribution') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>分发到后端服务说明</h4>
                    <p><strong>作用：</strong>将请求分发到多个后端服务器，实现负载均衡和高可用性。</p>
                    <p><strong>主要功能：</strong></p>
                    <ul>
                        <li>负载均衡：根据算法（如轮询、权重）分配请求到不同服务器。</li>
                        <li>故障转移：检测服务器健康状态，自动切换到可用服务器。</li>
                        <li>扩展性：支持动态添加/移除服务器。</li>
                        <li>性能优化：减少单点压力，提高响应速度。</li>
                    </ul>
                    <p><strong>示例：</strong>请求被分发到后端服务1、2、3中的一个或多个。</p>
                    <p><strong>优势：</strong>提高系统可用性和性能。</p>
                `;
            } else if (type === 'backend') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>后端服务高可用架构</h4>
                    <p><strong>服务分类说明：</strong></p>
                    <ul>
                        <li><strong>核心主后端服务：</strong>处理核心业务逻辑的主服务器，正常情况下处理所有请求。</li>
                        <li><strong>核心备用后端服务：</strong>核心业务的备用服务器，主服务故障时自动接管。</li>
                        <li><strong>拆分功能主后端服务：</strong>特定功能（如AI推理、高资源占用业务）的主服务器。</li>
                        <li><strong>拆分功能备用后端服务：</strong>特定功能的备用服务器，主服务故障时自动接管。</li>
                    </ul>
                    <p><strong>Nginx健康检查机制：</strong></p>
                    <ul>
                        <li><strong>主动健康检查：</strong>Nginx定期向后端服务发送健康检查请求（如/health端点）。</li>
                        <li><strong>被动健康检查：</strong>根据请求响应判断服务状态，连续失败max_fails次标记为不健康。</li>
                        <li><strong>自动故障转移：</strong>主服务故障时，Nginx自动将流量切换到备用服务（backup服务器）。</li>
                        <li><strong>恢复检测：</strong>故障服务恢复后，健康检查通过后重新加入负载均衡池。</li>
                    </ul>
                    <p><strong>Nginx配置示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
upstream backend_core {
    server 192.168.2.10:8080 max_fails=3 fail_timeout=30s;
    server 192.168.2.11:8080 backup;
}

upstream backend_ai {
    server 192.168.2.20:8080 max_fails=3 fail_timeout=30s;
    server 192.168.2.21:8080 backup;
}
                    </pre>
                    <p><strong>与Redis哨兵的区别：</strong></p>
                    <ul>
                        <li><strong>Redis哨兵：</strong>专门用于Redis数据库的自动故障转移，监控Redis主从节点。</li>
                        <li><strong>Nginx健康检查：</strong>用于应用层（后端服务）的负载均衡和故障转移。</li>
                        <li><strong>配合使用：</strong>Nginx负责后端服务的高可用，哨兵负责Redis的高可用，两者独立工作。</li>
                    </ul>
                    <p><strong>完整的高可用流程：</strong></p>
                    <ol>
                        <li>用户请求 → Nginx网关</li>
                        <li>Nginx通过健康检查选择健康的后端服务（主服务优先）</li>
                        <li>后端服务连接Redis哨兵获取主节点地址</li>
                        <li>操作Redis主节点或数据库</li>
                        <li>如果主服务故障，Nginx自动切换到备用服务</li>
                        <li>如果Redis主节点故障，哨兵自动提升从节点为主节点</li>
                        <li>后端服务从哨兵获取新的Redis主节点地址</li>
                    </ol>
                    <p><strong>优势：</strong>提高可用性、性能和安全性，实现应用层和数据层的双重高可用。</p>
                `;
            } else if (type === 'user-middle-tier') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>用户中台模块: 认证校验与ID生成</h4>
                    <p><strong>核心功能：</strong>生成全局唯一ID，用于用户注册时的手机号、名字、密码等信息。</p>
                    <p><strong>数据库设计：</strong></p>
                    <ul>
                        <li><strong>号段概念：</strong>预分配ID号段，避免每次生成都访问数据库。</li>
                        <li><strong>步长概念：</strong>每次申请的ID数量，控制性能。</li>
                        <li><strong>表结构：</strong>t_id_generate_config，管理所有业务的ID生成配置。</li>
                    </ul>
                    <p><strong>并发控制机制：</strong></p>
                    <ul>
                        <li><strong>信号量：</strong>保证只有一个线程申请新号段，避免并发冲突。</li>
                        <li><strong>乐观锁：</strong>version字段控制并发更新，只有匹配版本的线程才能成功。</li>
                        <li><strong>异步线程池：</strong>号段刷新异步执行，不阻塞ID生成。</li>
                        <li><strong>阈值策略：</strong>号段使用率超过75%时异步申请新号段。</li>
                    </ul>
                    <p><strong>核心机制：</strong>一张表管理所有业务的ID生成，支持扩展枚举(IdTypeEnum)添加新业务类型。</p>
                    <p><strong>数据隔离方式：</strong></p>
                    <table border="1" style="border-collapse: collapse; width: 100%;">
                        <thead>
                            <tr>
                                <th>id</th>
                                <th>remark</th>
                                <th>step</th>
                                <th>current_start</th>
                                <th>next_threshold</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>1</td>
                                <td>用户ID</td>
                                <td>1000</td>
                                <td>1000</td>
                                <td>2000</td>
                            </tr>
                            <tr>
                                <td>2</td>
                                <td>订单ID</td>
                                <td>5000</td>
                                <td>10000</td>
                                <td>15000</td>
                            </tr>
                            <tr>
                                <td>3</td>
                                <td>礼物ID</td>
                                <td>10000</td>
                                <td>100000</td>
                                <td>110000</td>
                            </tr>
                            <tr>
                                <td>4</td>
                                <td>房间ID</td>
                                <td>1000</td>
                                <td>1000000</td>
                                <td>1001000</td>
                            </tr>
                        </tbody>
                    </table>
                    <p><strong>示例：</strong>用户ID从1开始，订单ID从10000开始，各有独立号段和步长配置。</p>
                `;
            } else if (type === 'business-module') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>业务模块: 操作处理</h4>
                    <p><strong>模块功能：</strong>根据用户请求进行具体业务逻辑处理，区分是否需要数据库操作。</p>
                    <p><strong>处理逻辑：</strong></p>
                    <ul>
                        <li><strong>无需数据库操作：</strong>直接返回前端，数据闭环完成。</li>
                        <li><strong>需要数据库操作：</strong>进入Redis查询流程。</li>
                    </ul>
                    <p><strong>Redis查询命中后的循环处理：</strong></p>
                    <ul>
                        <li>数据返回业务模块，由业务模块再次处理。</li>
                        <li>业务模块判断是否需要进一步查询数据库。</li>
                        <li>如果需要，继续走数据库查询逻辑。</li>
                        <li>如果不需要，直接返回前端。</li>
                    </ul>
                    <p><strong>不需要读写查询数据库的操作（直接返回）：</strong></p>
                    <ul>
                        <li><strong>纯计算操作：</strong>如数学计算、数据格式转换、加密解密等。</li>
                        <li><strong>缓存查询：</strong>从Redis等缓存中获取数据，无需访问数据库。</li>
                        <li><strong>静态数据返回：</strong>返回配置数据、常量、枚举值等。</li>
                        <li><strong>外部API调用：</strong>调用第三方服务，处理结果后返回。</li>
                        <li><strong>状态检查：</strong>检查系统状态、服务可用性等。</li>
                    </ul>
                    <p><strong>需要读写查询数据库的操作（继续流程）：</strong></p>
                    <ul>
                        <li><strong>数据查询：</strong>从数据库读取用户数据、历史记录等。</li>
                        <li><strong>数据写入：</strong>插入新记录、更新现有数据、删除操作。</li>
                        <li><strong>事务处理：</strong>涉及多表操作，需要保证数据一致性。</li>
                        <li><strong>复杂业务逻辑：</strong>需要结合数据库数据进行判断和处理。</li>
                        <li><strong>数据验证：</strong>检查数据完整性、业务规则验证。</li>
                    </ul>
                    <p><strong>处理流程：</strong>根据操作类型决定是否进入读/写数据库流程，支持循环处理以优化性能。</p>
                `;
            } else if (type === 'redis-sentinel-cluster') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>Redis哨兵集群：获取主节点地址</h4>
                    <p><strong>作用：</strong>后端服务连接哨兵集群，获取当前Redis主节点的IP地址和端口。</p>
                    <p><strong>为什么需要哨兵集群：</strong></p>
                    <ul>
                        <li><strong>主节点可能变化：</strong>当主节点故障时，哨兵会自动将某个从节点提升为新的主节点。</li>
                        <li><strong>避免硬编码：</strong>应用不应该硬编码主节点地址，因为主节点地址会动态变化。</li>
                        <li><strong>高可用性：</strong>哨兵集群本身也是高可用的，即使部分哨兵故障，仍能提供服务。</li>
                    </ul>
                    <p><strong>Redis主从架构说明：</strong></p>
                    <ul>
                        <li><strong>Redis主节点（Master）：</strong>负责处理所有写操作，也可以处理读操作。数据写入主节点后，会自动同步到所有从节点。</li>
                        <li><strong>Redis从节点（Slave）：</strong>只能处理读操作，数据通过复制机制从主节点同步。一个主节点可以有多个从节点。</li>
                        <li><strong>主从复制关系：</strong>
                            <ul>
                                <li>从节点连接到主节点，发送SYNC命令</li>
                                <li>主节点创建快照（RDB文件），发送给从节点</li>
                                <li>主节点持续将写命令发送给从节点</li>
                                <li>从节点执行接收到的写命令，保持数据一致</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>哨兵与主从节点的关系：</strong></p>
                    <ul>
                        <li><strong>哨兵监控：</strong>哨兵节点独立于Redis数据节点，专门用于监控Redis主从节点的健康状态。</li>
                        <li><strong>哨兵数量：</strong>通常部署3个或5个哨兵节点（奇数个），避免脑裂问题。</li>
                        <li><strong>哨兵部署：</strong>哨兵节点应该部署在不同的物理机或容器中，确保哨兵本身的高可用。</li>
                        <li><strong>服务发现：</strong>后端服务不直接连接Redis主节点，而是先连接哨兵集群，询问"当前的主节点地址是什么？"</li>
                        <li><strong>地址更新：</strong>当主节点切换时，哨兵会通知后端服务新的主节点地址，或者后端服务定期向哨兵查询最新地址。</li>
                    </ul>
                    <p><strong>获取主节点地址的流程：</strong></p>
                    <ol>
                        <li>后端服务启动时，配置哨兵集群的地址列表（如：192.168.2.100:26379, 192.168.2.101:26379, 192.168.2.102:26379）</li>
                        <li>后端服务向哨兵发送命令：SENTINEL get-master-addr-by-name <master-name></li>
                        <li>哨兵返回当前主节点的IP和端口（如：192.168.2.10:6379）</li>
                        <li>后端服务连接到主节点，进行数据操作</li>
                        <li>如果主节点故障，后端服务会重新连接哨兵，获取新的主节点地址</li>
                    </ol>
                    <p><strong>客户端（后端服务）连接示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 伪代码示例
sentinel_hosts = ["192.168.2.100:26379", "192.168.2.101:26379", "192.168.2.102:26379"]
master_name = "mymaster"

// 连接到哨兵集群
master_info = sentinel.get_master_addr_by_name(master_name)
// 返回：{ip: "192.168.2.10", port: 6379}

// 连接到主节点
redis_client.connect(master_info.ip, master_info.port)
                    </pre>
                    <p><strong>重要配置：</strong></p>
                    <ul>
                        <li><strong>master-name：</strong>Redis主节点组的名称，在哨兵配置文件中定义（如：mymaster）</li>
                        <li><strong>quorum：</strong>确认主节点下线所需的最少哨兵数量</li>
                        <li><strong>down-after-milliseconds：</strong>哨兵认为主节点下线的超时时间</li>
                        <li><strong>failover-timeout：</strong>故障转移完成的最大时间</li>
                    </ul>
                    <p><strong>优势：</strong>实现Redis高可用，主节点故障时自动切换，应用无需人工干预即可获取新的主节点地址。</p>
                `;
            } else if (type === 'redis-sentinel-monitor') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>Redis哨兵监控：主从节点健康检查</h4>
                    <p><strong>作用：</strong>哨兵持续监控Redis主节点和所有从节点的健康状态，及时发现故障。</p>
                    <p><strong>监控对象：</strong></p>
                    <ul>
                        <li><strong>Redis主节点：</strong>监控主节点是否正常响应命令。</li>
                        <li><strong>Redis从节点：</strong>监控从节点是否正常复制主节点数据。</li>
                        <li><strong>哨兵节点间互相监控：</strong>哨兵节点之间也会互相通信，监控其他哨兵节点的健康状态。</li>
                    </ul>
                    <p><strong>监控机制详解：</strong></p>
                    <ol>
                        <li><strong>PING-PONG机制：</strong>
                            <ul>
                                <li>哨兵每隔1秒（可配置）向Redis主从节点发送PING命令</li>
                                <li>如果在down-after-milliseconds时间内（默认30秒）没有收到有效回复，认为该节点下线</li>
                                <li>有效回复包括：PONG、LOADING、MASTERDOWN等</li>
                            </ul>
                        </li>
                        <li><strong>主观下线（Subjectively Down, SDOWN）：</strong>
                            <ul>
                                <li>单个哨兵认为某个Redis节点下线（超过down-after-milliseconds时间未响应）</li>
                                <li>这是哨兵自己的判断，可能因为网络问题误判</li>
                                <li>主观下线后，哨兵会询问其他哨兵对该节点的判断</li>
                            </ul>
                        </li>
                        <li><strong>客观下线（Objectively Down, ODOWN）：</strong>
                            <ul>
                                <li>当足够多数量的哨兵（quorum个）都认为主节点下线时，确认主节点客观下线</li>
                                <li>需要达到配置文件中quorum的数量（通常设置为哨兵总数的大多数，如3个哨兵设置quorum为2）</li>
                                <li>客观下线确认后，才开始触发故障转移流程</li>
                                <li>从节点下线通常不需要客观下线确认，因为从节点故障不影响主服务</li>
                            </ul>
                        </li>
                        <li><strong>INFO命令监控：</strong>
                            <ul>
                                <li>哨兵每10秒向Redis节点发送INFO命令</li>
                                <li>获取Redis的运行状态、复制信息、从节点列表等</li>
                                <li>自动发现新的从节点</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>哨兵配置示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
# sentinel.conf
port 26379
sentinel monitor mymaster 192.168.2.10 6379 2
# 2表示至少2个哨兵同意才确认主节点下线

sentinel down-after-milliseconds mymaster 30000
# 30秒未响应认为主观下线

sentinel parallel-syncs mymaster 1
# 故障转移后，同时同步的从节点数量

sentinel failover-timeout mymaster 180000
# 故障转移超时时间：180秒
                    </pre>
                    <p><strong>监控流程图：</strong></p>
                    <ol>
                        <li>哨兵启动，连接到Redis主节点和从节点</li>
                        <li>哨兵定期发送PING命令检查节点健康</li>
                        <li>如果主节点未响应 → 主观下线（SDOWN）</li>
                        <li>哨兵询问其他哨兵对主节点的判断</li>
                        <li>如果足够多哨兵确认主节点下线 → 客观下线（ODOWN）</li>
                        <li>触发自动故障转移流程</li>
                    </ol>
                    <p><strong>信息发布与订阅：</strong></p>
                    <ul>
                        <li>哨兵通过Redis的发布/订阅机制，向所有连接的客户端发布主节点切换事件</li>
                        <li>客户端订阅哨兵的频道，实时获取主节点变化通知</li>
                        <li>常用频道：+switch-master（主节点切换）、+failover-end（故障转移结束）</li>
                    </ul>
                    <p><strong>优势：</strong>实现自动监控、自动发现故障、自动通知，确保Redis集群的高可用性。</p>
                `;
            } else if (type === 'redis-failover') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>Redis从节点提升为主节点：自动故障转移</h4>
                    <p><strong>什么是自动故障转移：</strong></p>
                    <ul>
                        <li>当Redis主节点故障时，哨兵自动从从节点中选择一个，提升为新的主节点。</li>
                        <li>整个过程完全自动化，无需人工干预。</li>
                        <li>故障转移期间，Redis服务会短暂不可用（通常几秒到几十秒）。</li>
                    </ul>
                    <p><strong>故障转移的完整流程：</strong></p>
                    <ol>
                        <li><strong>发现主节点故障：</strong>
                            <ul>
                                <li>哨兵通过PING命令发现主节点未响应</li>
                                <li>达到down-after-milliseconds时间后，标记为主观下线（SDOWN）</li>
                                <li>足够多的哨兵确认后，标记为客观下线（ODOWN）</li>
                            </ul>
                        </li>
                        <li><strong>选举领头哨兵（Leader Sentinel）：</strong>
                            <ul>
                                <li>确认主节点客观下线的哨兵发起领头哨兵选举</li>
                                <li>所有在线的哨兵投票选择领头哨兵</li>
                                <li>第一个获得多数票的哨兵成为领头哨兵</li>
                                <li>领头哨兵负责执行故障转移操作</li>
                            </ul>
                        </li>
                        <li><strong>选择新的主节点：</strong>
                            <ul>
                                <li>领头哨兵从所有健康的从节点中选择最优的从节点</li>
                                <li><strong>选择优先级：</strong>
                                    <ol>
                                        <li><strong>优先级（slave-priority）：</strong>配置文件中设置的优先级，值越高越优先（默认100）</li>
                                        <li><strong>复制偏移量（replication offset）：</strong>复制数据最完整的从节点（offset最大）优先</li>
                                        <li><strong>运行ID（run_id）：</strong>如果偏移量相同，选择run_id字典序较小的</li>
                                    </ol>
                                </li>
                                <li>排除不健康的从节点（断线时间超过down-after-milliseconds的10倍）</li>
                            </ul>
                        </li>
                        <li><strong>提升从节点为主节点：</strong>
                            <ul>
                                <li>领头哨兵向选中的从节点发送SLAVEOF NO ONE命令</li>
                                <li>该从节点停止复制，变身为新的主节点</li>
                                <li>新主节点开始接受写操作</li>
                            </ul>
                        </li>
                        <li><strong>重新配置其他从节点：</strong>
                            <ul>
                                <li>领头哨兵向其他从节点发送SLAVEOF命令</li>
                                <li>让所有从节点复制新的主节点</li>
                                <li>确保所有从节点的数据与新主节点同步</li>
                            </ul>
                        </li>
                        <li><strong>处理旧主节点：</strong>
                            <ul>
                                <li>如果旧主节点恢复上线，哨兵会将其配置为从节点</li>
                                <li>旧主节点开始复制新主节点的数据，保证数据一致性</li>
                            </ul>
                        </li>
                        <li><strong>通知应用：</strong>
                            <ul>
                                <li>哨兵通过发布/订阅机制发布主节点切换消息</li>
                                <li>应用收到通知后，更新连接配置，连接到新的主节点</li>
                                <li>应用也可以主动查询哨兵获取最新主节点地址</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>故障转移时间估算：</strong></p>
                    <ul>
                        <li>主观下线检测：30秒（down-after-milliseconds）</li>
                        <li>客观下线确认：几秒到几十秒（取决于哨兵通信）</li>
                        <li>领头哨兵选举：几秒</li>
                        <li>提升新主节点：几秒</li>
                        <li>从节点重新配置：几秒到几十秒</li>
                        <li><strong>总计：</strong>通常30-60秒完成整个故障转移</li>
                    </ul>
                    <p><strong>重要配置：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
# 从节点优先级配置（在redis.conf中）
slave-priority 100

# 优先级越高，越优先被选为新主节点
# 可以将性能好的从节点设置更高优先级
                    </pre>
                    <p><strong>故障转移期间的数据一致性：</strong></p>
                    <ul>
                        <li><strong>可能丢失数据：</strong>如果旧主节点在故障前还未将数据同步到从节点，这部分数据会丢失</li>
                        <li><strong>避免数据丢失：</strong>配置min-slaves-to-write和min-slaves-max-lag，确保至少N个从节点同步成功后才确认写操作</li>
                        <li><strong>数据恢复：</strong>旧主节点恢复后，会作为从节点同步新主节点的数据，丢弃未同步的写操作</li>
                    </ul>
                    <p><strong>优势：</strong>实现Redis主节点的自动切换，最大程度减少服务中断时间，提高系统可用性。</p>
                `;
            } else if (type === 'need-db') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>需要数据库操作判断</h4>
                    <p><strong>作用：</strong>判断当前业务操作是否需要访问数据库。</p>
                    <p><strong>判断依据：</strong></p>
                    <ul>
                        <li><strong>需要数据库：</strong>涉及数据查询、数据写入、事务处理等操作。</li>
                        <li><strong>不需要数据库：</strong>纯计算、缓存查询、静态数据返回、外部API调用等。</li>
                    </ul>
                    <p><strong>处理流程：</strong></p>
                    <ul>
                        <li><strong>否：</strong>直接返回结果给前端，完成请求闭环。</li>
                        <li><strong>是：</strong>进入读写操作判断，继续后续流程。</li>
                    </ul>
                    <p><strong>优化目的：</strong>避免不必要的数据库访问，提高响应速度，降低数据库压力。</p>
                `;
            } else if (type === 'read-write') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>读/写操作判断</h4>
                    <p><strong>作用：</strong>区分读操作和写操作，采用不同的处理策略。</p>
                    <p><strong>读操作流程：</strong></p>
                    <ol>
                        <li>通过Redis哨兵获取主节点地址</li>
                        <li>查询Redis主节点缓存</li>
                        <li>命中：直接返回数据</li>
                        <li>未命中：查询数据库，更新Redis缓存</li>
                    </ol>
                    <p><strong>写操作流程：</strong></p>
                    <ol>
                        <li>通过Redis哨兵获取主节点地址</li>
                        <li>检查Redis是否有相关数据</li>
                        <li>有数据：更新Redis和数据库（事务操作）</li>
                        <li>无数据：查询数据库，更新数据库和Redis（事务操作）</li>
                    </ol>
                    <p><strong>注意事项：</strong></p>
                    <ul>
                        <li>写操作必须操作主节点，确保数据一致性</li>
                        <li>读写分离时，读操作可以从节点获取数据</li>
                        <li>事务操作保证原子性，要么全部成功，要么全部失败</li>
                    </ul>
                `;
            } else if (type === 'redis-read-query') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>Redis主节点查询：读操作缓存查询</h4>
                    <p><strong>作用：</strong>后端服务从Redis主节点查询数据，判断缓存中是否有所需数据。</p>
                    <p><strong>查询流程：</strong></p>
                    <ol>
                        <li><strong>连接Redis主节点：</strong>
                            <ul>
                                <li>后端服务通过哨兵获取主节点地址</li>
                                <li>建立TCP连接到Redis主节点（默认端口6379）</li>
                                <li>发送AUTH命令进行身份验证（如果配置了密码）</li>
                                <li>选择数据库（SELECT命令，默认DB 0）</li>
                            </ul>
                        </li>
                        <li><strong>发送查询命令：</strong>
                            <ul>
                                <li><strong>单值查询：</strong>GET key（查询字符串）</li>
                                <li><strong>哈希查询：</strong>HGET hash key field（查询哈希字段）</li>
                                <li><strong>列表查询：</strong>LRANGE list start stop（查询列表范围）</li>
                                <li><strong>集合查询：</strong>SMEMBERS set（查询集合所有成员）</li>
                                <li><strong>有序集合：</strong>ZRANGE zset start stop（查询有序集合范围）</li>
                            </ul>
                        </li>
                        <li><strong>判断查询结果：</strong>
                            <ul>
                                <li><strong>命中（Cache Hit）：</strong>Redis返回了数据（非空、非nil）</li>
                                <li><strong>未命中（Cache Miss）：</strong>Redis返回nil或key不存在</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>什么是命中（Cache Hit）：</strong></p>
                    <ul>
                        <li><strong>定义：</strong>Redis主节点的内存中存在所查询的key，并且返回了对应的value</li>
                        <li><strong>体现：</strong>GET命令返回了具体的数据（如字符串、数字、JSON等），而不是nil</li>
                        <li><strong>返回值示例：</strong>
                            <ul>
                                <li>字符串："user:1001" → "张三"</li>
                                <li>哈希："HGET user:1001 name" → "张三"</li>
                                <li>JSON："GET order:5001" → '{"id":5001,"status":"paid"}'</li>
                            </ul>
                        </li>
                        <li><strong>性能优势：</strong>内存读取，微秒级响应（通常<1ms）</li>
                        <li><strong>业务处理：</strong>直接返回数据给业务模块，跳过数据库查询</li>
                    </ul>
                    <p><strong>什么是未命中（Cache Miss）：</strong></p>
                    <ul>
                        <li><strong>定义：</strong>Redis主节点的内存中不存在所查询的key，或者key已过期</li>
                        <li><strong>体现：</strong>GET命令返回nil（空值），表示key不存在</li>
                        <li><strong>返回值示例：</strong>
                            <ul>
                                <li>查询不存在的key："GET user:9999" → (nil)</li>
                                <li>查询已过期的key："GET session:expired" → (nil)</li>
                            </ul>
                        </li>
                        <li><strong>未命中原因：</strong>
                            <ol>
                                <li>数据从未写入Redis（首次访问）</li>
                                <li>数据已过期（TTL到期，Redis自动删除）</li>
                                <li>数据被主动删除（DEL命令或FLUSHDB）</li>
                                <li>内存不足，Redis淘汰了该key（LRU/LFU策略）</li>
                            </ol>
                        </li>
                        <li><strong>业务处理：</strong>需要进入"数据库查询"流程，从数据库加载数据</li>
                    </ul>
                    <p><strong>查询示例代码：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 伪代码：Redis查询
redis_client.connect(master_ip, master_port)
redis_client.auth(password)

// 查询用户信息
user_key = "user:" + user_id
user_data = redis_client.get(user_key)

if (user_data != null) {
    // 命中：缓存中有数据
    parse_json(user_data)
    return user_data  // 直接返回
} else {
    // 未命中：缓存中无数据
    return null  // 进入数据库查询流程
}
                    </pre>
                    <p><strong>缓存穿透保护：</strong></p>
                    <ul>
                        <li><strong>空值缓存：</strong>如果数据库中也不存在该数据，将key值设为空字符串或特殊标记，防止频繁查询数据库</li>
                        <li><strong>布隆过滤器：</strong>使用布隆过滤器快速判断key是否可能存在，避免查询不存在的key</li>
                        <li><strong>限流降级：</strong>对于高频未命中的查询，限制查询频率，避免压垮数据库</li>
                    </ul>
                    <p><strong>性能指标：</strong></p>
                    <ul>
                        <li><strong>命中率：</strong>命中的查询次数 / 总查询次数（通常要求>80%）</li>
                        <li><strong>响应时间：</strong>Redis查询通常<1ms，数据库查询通常10-100ms</li>
                        <li><strong>QPS提升：</strong>使用Redis缓存后，QPS可提升10-100倍</li>
                    </ul>
                    <p><strong>业务价值：</strong>通过缓存命中避免数据库查询，大幅提升查询性能，降低数据库压力。</p>
                `;
            } else if (type === 'redis-write-check') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>Redis主节点检查：写操作数据检查</h4>
                    <p><strong>作用：</strong>后端服务在执行写操作前，检查Redis主节点中是否已存在相关数据，决定后续处理策略。</p>
                    <p><strong>检查流程：</strong></p>
                    <ol>
                        <li><strong>连接Redis主节点：</strong>
                            <ul>
                                <li>通过哨兵获取主节点地址</li>
                                <li>建立连接并进行身份验证</li>
                                <li>选择目标数据库</li>
                            </ul>
                        </li>
                        <li><strong>执行检查命令：</strong>
                            <ul>
                                <li><strong>EXISTS key：</strong>检查key是否存在（返回1表示存在，0表示不存在）</li>
                                <li><strong>GET key：</strong>获取key的当前值（返回数据或nil）</li>
                                <li><strong>HGETALL hash：</strong>获取哈希表的所有字段和值</li>
                                <li><strong>TTL key：</strong>获取key的剩余过期时间</li>
                            </ul>
                        </li>
                        <li><strong>判断检查结果：</strong>
                            <ul>
                                <li><strong>有数据：</strong>Redis中存在该key，需要执行更新操作</li>
                                <li><strong>无数据：</strong>Redis中不存在该key，需要执行插入操作</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>有数据场景（Update）：</strong></p>
                    <ul>
                        <li><strong>定义：</strong>Redis主节点内存中已存在所查询的key，并且有对应的value</li>
                        <li><strong>体现：</strong>EXISTS命令返回1，GET命令返回了具体数据</li>
                        <li><strong>业务逻辑：</strong>
                            <ol>
                                <li>更新Redis主节点中的数据（SET/HMSET等命令）</li>
                                <li>同时更新数据库中的数据（事务操作）</li>
                                <li>确保Redis和数据库的数据一致性</li>
                            </ol>
                        </li>
                        <li><strong>示例：</strong>
                            <ul>
                                <li>用户修改信息："user:1001"已存在，更新name字段</li>
                                <li>订单状态变更："order:5001"已存在，更新status为"shipped"</li>
                                <li>库存扣减："inventory:product:100"已存在，更新count字段</li>
                            </ul>
                        </li>
                        <li><strong>操作命令：</strong>
                            <ul>
                                <li>字符串：SET key value</li>
                                <li>哈希：HMSET hash field1 value1 field2 value2</li>
                                <li>JSON：JSON.SET key $ json_value</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>无数据场景（Insert）：</strong></p>
                    <ul>
                        <li><strong>定义：</strong>Redis主节点内存中不存在所查询的key</li>
                        <li><strong>体现：</strong>EXISTS命令返回0，GET命令返回nil</li>
                        <li><strong>业务逻辑：</strong>
                            <ol>
                                <li>查询数据库，确认数据是否存在（可能数据只存在于数据库，不在Redis）</li>
                                <li>如果数据库存在：更新数据库数据，并写入Redis</li>
                                <li>如果数据库不存在：插入新数据到数据库，并写入Redis</li>
                            </ol>
                        </li>
                        <li><strong>示例：</strong>
                            <ul>
                                <li>新用户注册："user:1002"不存在，查询DB确认，然后插入DB和Redis</li>
                                <li>新订单创建："order:5002"不存在，插入DB订单表，写入Redis</li>
                                <li>缓存预热：系统启动后首次访问，数据只在DB中，需要加载到Redis</li>
                            </ul>
                        </li>
                        <li><strong>操作命令：</strong>
                            <ul>
                                <li>先查询DB：SELECT * FROM users WHERE id = 1002</li>
                                <li>再写入Redis：SET key value EX seconds（设置过期时间）</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>写操作示例代码：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 伪代码：写操作检查
redis_client.connect(master_ip, master_port)

// 检查数据是否存在
user_key = "user:" + user_id
exists = redis_client.exists(user_key)

if (exists == 1) {
    // 有数据：更新操作
    old_data = redis_client.get(user_key)
    new_data = update_user_info(old_data, params)

    // 事务操作：更新Redis和数据库
    begin_transaction()
    redis_client.set(user_key, new_data)
    db.execute("UPDATE users SET name=? WHERE id=?", new_data.name, user_id)
    commit_transaction()
} else {
    // 无数据：查询DB + 插入操作
    user = db.query("SELECT * FROM users WHERE id=?", user_id)

    if (user != null) {
        // 数据在DB中，更新DB和Redis
        begin_transaction()
        db.execute("UPDATE users SET ... WHERE id=?", user_id)
        redis_client.set(user_key, user_data)
        commit_transaction()
    } else {
        // 数据不存在，插入DB和Redis
        begin_transaction()
        db.execute("INSERT INTO users ...")
        redis_client.set(user_key, new_user_data)
        commit_transaction()
    }
}
                    </pre>
                    <p><strong>并发控制：</strong></p>
                    <ul>
                        <li><strong>乐观锁：</strong>使用WATCH命令监控key，如果在事务执行期间key被修改，事务失败</li>
                        <li><strong>分布式锁：</strong>使用SETNX命令实现分布式锁，避免并发写冲突</li>
                        <li><strong>CAS机制：</strong>Compare-And-Set，先获取版本号，更新时检查版本号是否变化</li>
                    </ul>
                    <p><strong>数据一致性保证：</strong></p>
                    <ul>
                        <li><strong>双写一致性：</strong>使用事务确保Redis和数据库同时成功或同时失败</li>
                        <li><strong>最终一致性：</strong>如果双写失败，通过定时刷新或MQ消息补偿</li>
                        <li><strong>主从同步：</strong>写操作只写入主节点，主节点自动同步到从节点</li>
                    </ul>
                    <p><strong>业务价值：</strong>通过检查Redis中是否有数据，决定执行更新还是插入操作，保证数据一致性，同时利用缓存提升性能。</p>
                `;
            } else if (type === 'cache-hit') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>命中：缓存数据存在</h4>
                    <p><strong>定义：</strong>Redis主节点内存中存在所查询的key，并且返回了有效的数据。</p>
                    <p><strong>命中体现：</strong></p>
                    <ul>
                        <li><strong>命令返回：</strong>GET key 返回了具体的数据（字符串、数字、JSON等），而不是nil</li>
                        <li><strong>返回值：</strong>
                            <ul>
                                <li>字符串：返回value内容，如"张三"、"12345"</li>
                                <li>JSON：返回JSON字符串，如'{"id":1001,"name":"张三"}'</li>
                                <li>数字：返回数字值，如100、3.14</li>
                            </ul>
                        </li>
                        <li><strong>非空判断：</strong>返回值 != null && 返回值 != "" && 返回值 != "(nil)"</li>
                    </ul>
                    <p><strong>命中原因：</strong></p>
                    <ul>
                        <li>数据之前被写入Redis，并且还未过期</li>
                        <li>数据的TTL（Time To Live）未到期，Redis未自动删除</li>
                        <li>数据没有被主动删除（DEL命令或FLUSHDB）</li>
                        <li>内存充足，Redis未因内存压力淘汰该key</li>
                    </ul>
                    <p><strong>命中后的处理流程：</strong></p>
                    <ol>
                        <li>后端服务解析Redis返回的数据</li>
                        <li>如果数据是JSON字符串，反序列化为对象</li>
                        <li>将数据返回给业务模块</li>
                        <li>业务模块进行后续业务逻辑处理</li>
                        <li>最终返回给前端，完成请求</li>
                    </ol>
                    <p><strong>性能优势：</strong></p>
                    <ul>
                        <li><strong>响应时间：</strong>Redis内存读取通常<1ms，比数据库快10-100倍</li>
                        <li><strong>吞吐量：</strong>Redis单节点QPS可达10万+，数据库通常只有几千</li>
                        <li><strong>数据库减压：</strong>命中一次就减少一次数据库查询</li>
                    </ul>
                    <p><strong>命中示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 查询用户ID=1001的信息
GET user:1001

// 命中返回：
'{"id":1001,"name":"张三","age":25,"email":"zhangsan@example.com"}'

// 后端服务解析JSON，返回给业务模块
user_info = JSON.parse(redis_return)
// user_info = {id: 1001, name: "张三", age: 25, email: "zhangsan@example.com"}

// 直接返回给前端，无需查询数据库
                    </pre>
                    <p><strong>业务价值：</strong>缓存命中直接返回数据，跳过数据库查询，大幅提升性能，降低数据库压力。</p>
                `;
            } else if (type === 'cache-miss') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>未命中：缓存数据不存在</h4>
                    <p><strong>定义：</strong>Redis主节点内存中不存在所查询的key，或者key已过期被删除。</p>
                    <p><strong>未命中体现：</strong></p>
                    <ul>
                        <li><strong>命令返回：</strong>GET key 返回nil（空值）</li>
                        <li><strong>返回值：</strong>
                            <ul>
                                <li>Redis CLI显示：(nil)</li>
                                <li>Redis客户端库返回：null、None、nil等</li>
                            </ul>
                        </li>
                        <li><strong>空值判断：</strong>返回值 == null || 返回值 == "" || 返回值 == "(nil)"</li>
                    </ul>
                    <p><strong>未命中原因：</strong></p>
                    <ol>
                        <li><strong>首次访问：</strong>
                            <ul>
                                <li>数据从未写入过Redis（第一次访问该数据）</li>
                                <li>系统刚启动，缓存为空（冷启动）</li>
                            </ul>
                        </li>
                        <li><strong>数据过期：</strong>
                            <ul>
                                <li>数据的TTL（Time To Live）已到期</li>
                                <li>Redis自动删除了过期的key</li>
                                <li>示例：验证码过期、Session过期</li>
                            </ul>
                        </li>
                        <li><strong>数据被删除：</strong>
                            <ul>
                                <li>应用程序主动删除（DEL命令）</li>
                                <li>管理员手动清空缓存（FLUSHDB）</li>
                                <li>数据更新时删除旧缓存</li>
                            </ul>
                        </li>
                        <li><strong>内存淘汰：</strong>
                            <ul>
                                <li>Redis内存不足，触发淘汰策略</li>
                                <li>LRU（Least Recently Used）淘汰最少使用的key</li>
                                <li>LFU（Least Frequently Used）淘汰访问频率最低的key</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>未命中后的处理流程（缓存回源）：</strong></p>
                    <ol>
                        <li><strong>查询数据库：</strong>
                            <ul>
                                <li>执行SQL查询，从数据库获取数据</li>
                                <li>示例：SELECT * FROM users WHERE id = 1001</li>
                            </ul>
                        </li>
                        <li><strong>判断数据库结果：</strong>
                            <ul>
                                <li><strong>数据库有数据：</strong>进入"更新Redis主节点"流程</li>
                                <li><strong>数据库无数据：</strong>返回空结果或错误</li>
                            </ul>
                        </li>
                        <li><strong>写入Redis缓存：</strong>
                            <ul>
                                <li>将数据库查询结果写入Redis主节点</li>
                                <li>设置TTL过期时间，避免数据永久占用内存</li>
                                <li>示例：SET user:1001 '{...}' EX 3600（1小时过期）</li>
                            </ul>
                        </li>
                        <li><strong>返回数据：</strong>
                            <ul>
                                <li>将数据返回给业务模块</li>
                                <li>最终返回给前端</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>未命中示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 查询用户ID=9999的信息（首次访问）
GET user:9999

// 未命中返回：
(nil)

// 后端服务处理：
if (redis_result == null) {
    // 查询数据库
    user = db.query("SELECT * FROM users WHERE id = 9999")

    if (user != null) {
        // 写入Redis缓存，设置1小时过期
        redis_client.set("user:9999", user_json, "EX", 3600)
        return user
    } else {
        // 数据库也没有，返回错误
        return "用户不存在"
    }
}
                    </pre>
                    <p><strong>缓存未命中优化策略：</strong></p>
                    <ul>
                        <li><strong>缓存预热：</strong>系统启动时，提前将热点数据加载到Redis</li>
                        <li><strong>延长TTL：</strong>合理设置过期时间，减少未命中</li>
                        <li><strong>互斥锁：</strong>高并发未命中时，只允许一个线程查询数据库，其他线程等待</li>
                        <li><strong>布隆过滤器：</strong>快速判断key是否存在，避免查询不存在的key</li>
                        <li><strong>空值缓存：</strong>数据库中不存在的数据，也缓存空值，TTL设置较短（如5分钟）</li>
                    </ul>
                    <p><strong>性能影响：</strong></p>
                    <ul>
                        <li>未命中需要查询数据库，响应时间从<1ms增加到10-100ms</li>
                        <li>如果未命中率过高，会失去缓存的意义，反而增加复杂度</li>
                        <li>建议命中率>80%，否则需要优化缓存策略</li>
                    </ul>
                    <p><strong>业务价值：</strong>未命中触发数据库查询，并更新缓存，确保数据最终一致性，同时为后续请求提供缓存数据。</p>
                `;
            } else if (type === 'db-query') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>数据库查询：从持久化存储获取数据</h4>
                    <p><strong>作用：</strong>当Redis缓存未命中时，后端服务从数据库查询数据，确保持久化数据的读取。</p>
                    <p><strong>查询流程：</strong></p>
                    <ol>
                        <li><strong>建立数据库连接：</strong>
                            <ul>
                                <li>从连接池获取一个数据库连接（避免每次创建新连接）</li>
                                <li>连接池配置：最大连接数、最小空闲连接数、连接超时时间</li>
                                <li>执行身份验证（用户名、密码）</li>
                                <li>选择目标数据库（USE database_name）</li>
                            </ul>
                        </li>
                        <li><strong>构建SQL查询：</strong>
                            <ul>
                                <li>根据业务需求构建SELECT语句</li>
                                <li>使用参数化查询（PreparedStatement），防止SQL注入</li>
                                <li>设置查询条件（WHERE子句）、排序（ORDER BY）、分页（LIMIT）</li>
                            </ul>
                        </li>
                        <li><strong>执行查询：</strong>
                            <ul>
                                <li>发送SQL语句到数据库服务器</li>
                                <li>数据库解析SQL、优化查询计划、执行查询</li>
                                <li>从磁盘或缓冲池读取数据</li>
                                <li>返回查询结果集（ResultSet）</li>
                            </ul>
                        </li>
                        <li><strong>处理结果集：</strong>
                            <ul>
                                <li>遍历结果集，提取每一行数据</li>
                                <li>将数据库字段映射到对象属性（ORM映射）</li>
                                <li>组装成业务对象（如User、Order等）</li>
                                <li>序列化为JSON或XML格式</li>
                            </ul>
                        </li>
                        <li><strong>释放连接：</strong>
                            <ul>
                                <li>将连接返回给连接池，供后续请求复用</li>
                                <li>关闭ResultSet、Statement等资源</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>查询示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 伪代码：数据库查询
connection = db_pool.get_connection()

// 参数化查询，防止SQL注入
sql = "SELECT id, name, age, email FROM users WHERE id = ?"
statement = connection.prepare(sql)
statement.set_int(1, user_id)

result_set = statement.execute()

if (result_set.next()) {
    // 提取数据
    user = {
        id: result_set.get_int("id"),
        name: result_set.get_string("name"),
        age: result_set.get_int("age"),
        email: result_set.get_string("email")
    }

    // 序列化为JSON
    user_json = JSON.stringify(user)

    // 进入"更新Redis主节点"流程
    redis_client.set("user:" + user_id, user_json, "EX", 3600)

    return user
} else {
    // 数据库中也没有该数据
    return null
}

db_pool.return_connection(connection)
                    </pre>
                    <p><strong>查询优化：</strong></p>
                    <ul>
                        <li><strong>索引优化：</strong>
                            <ul>
                                <li>为WHERE子句中的字段创建索引</li>
                                <li>示例：CREATE INDEX idx_user_id ON users(id)</li>
                                <li>避免全表扫描，使用索引快速定位数据</li>
                            </ul>
                        </li>
                        <li><strong>分页查询：</strong>
                            <ul>
                                <li>使用LIMIT offset, count分页</li>
                                <li>避免一次性加载大量数据</li>
                                <li>示例：SELECT * FROM orders WHERE user_id=? LIMIT 0, 20</li>
                            </ul>
                        </li>
                        <li><strong>字段筛选：</strong>
                            <ul>
                                <li>只查询需要的字段，避免SELECT *</li>
                                <li>减少网络传输和内存占用</li>
                            </ul>
                        </li>
                        <li><strong>查询缓存：</strong>
                            <ul>
                                <li>数据库自身的查询缓存（Query Cache）</li>
                                <li>相同SQL直接返回缓存结果</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>分库分表查询：</strong></p>
                    <ul>
                        <li><strong>分片路由：</strong>根据分片键（如user_id）确定查询哪个数据库</li>
                        <li><strong>跨库查询：</strong>如果需要查询多个分片，分别查询后合并结果</li>
                        <li><strong>示例：</strong>
                            <ul>
                                <li>user_id % 10 = 0 → 查询db0.users表</li>
                                <li>user_id % 10 = 1 → 查询db1.users表</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>事务隔离级别：</strong></p>
                    <ul>
                        <li><strong>读未提交：</strong>可能读到脏数据（不推荐）</li>
                        <li><strong>读已提交：</strong>只能读到已提交的数据（推荐）</li>
                        <li><strong>可重复读：</strong>MySQL默认级别，防止幻读</li>
                        <li><strong>串行化：</strong>最高隔离级别，性能差</li>
                    </ul>
                    <p><strong>性能指标：</strong></p>
                    <ul>
                        <li><strong>响应时间：</strong>简单查询10-50ms，复杂查询100-500ms</li>
                        <li><strong>并发连接：</strong>数据库连接池通常配置为10-100个连接</li>
                        <li><strong>QPS：</strong>单实例数据库QPS通常几千到上万</li>
                    </ul>
                    <p><strong>业务价值：</strong>从持久化存储获取完整、准确的数据，为业务逻辑提供数据基础，同时为缓存更新提供数据源。</p>
                `;
            } else if (type === 'update-redis-master') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>更新Redis主节点：回写缓存</h4>
                    <p><strong>作用：</strong>将从数据库查询到的数据写入Redis主节点，更新缓存，为后续请求提供服务。</p>
                    <p><strong>更新流程：</strong></p>
                    <ol>
                        <li><strong>序列化数据：</strong>
                            <ul>
                                <li>将数据库查询结果（对象、结构体）序列化为字符串</li>
                                <li>常用格式：JSON、MessagePack、Protobuf</li>
                                <li>示例：JSON.stringify(user_object)</li>
                            </ul>
                        </li>
                        <li><strong>构建Redis命令：</strong>
                            <ul>
                                <li><strong>简单key-value：</strong>SET key value EX seconds</li>
                                <li><strong>哈希结构：</strong>HMSET hash field1 value1 field2 value2</li>
                                <li><strong>列表结构：</strong>LPUSH list value1 value2</li>
                                <li><strong>集合结构：</strong>SADD set member1 member2</li>
                            </ul>
                        </li>
                        <li><strong>设置过期时间（TTL）：</strong>
                            <ul>
                                <li><strong>为什么需要TTL：</strong>防止数据永久占用内存，确保内存空间可回收</li>
                                <li><strong>TTL设置策略：</strong>
                                    <ul>
                                        <li>热点数据：1小时（3600秒）</li>
                                        <li>普通数据：10分钟（600秒）</li>
                                        <li>冷数据：5分钟（300秒）</li>
                                        <li>会话数据：30分钟（1800秒）</li>
                                    </ul>
                                </li>
                                <li><strong>设置方式：</strong>
                                    <ul>
                                        <li>SET key value EX seconds（设置时指定TTL）</li>
                                        <li>EXPIRE key seconds（已存在的key设置TTL）</li>
                                        <li>EXPIREAT key timestamp（设置过期时间戳）</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li><strong>执行写入命令：</strong>
                            <ul>
                                <li>发送命令到Redis主节点</li>
                                <li>Redis将数据写入内存</li>
                                <li>返回OK表示写入成功</li>
                                <li><strong>同步到从节点：</strong>主节点异步将写命令发送给所有从节点</li>
                            </ul>
                        </li>
                        <li><strong>主从同步机制：</strong>
                            <ul>
                                <li>主节点执行写命令后，将命令传播给从节点</li>
                                <li>从节点接收命令并执行，保持数据一致</li>
                                <li>异步复制：不等待从节点确认，主节点立即返回</li>
                                <li><strong>注意：</strong>这里只是更新Redis主节点，不涉及"将从节点提升为主节点"</li>
                                <li>从节点提升为主节点是哨兵的自动故障转移流程，与缓存更新是两个独立的概念</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>写入示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 伪代码：更新Redis主节点

// 序列化数据
user_json = JSON.stringify({
    id: 1001,
    name: "张三",
    age: 25,
    email: "zhangsan@example.com"
})

// 写入Redis主节点，设置1小时过期
redis_client.set("user:1001", user_json, "EX", 3600)

// 返回结果：OK
// 主节点异步将写命令同步到从节点
                    </pre>
                    <p><strong>主从同步详细说明：</strong></p>
                    <ul>
                        <li><strong>主节点角色：</strong>接收所有写操作，是唯一的写入点</li>
                        <li><strong>从节点角色：</strong>只能读，数据从主节点同步</li>
                        <li><strong>同步方向：</strong>主节点 → 从节点（单向）</li>
                        <li><strong>同步方式：</strong>主节点执行写命令后，将命令发送给所有从节点</li>
                        <li><strong>异步复制：</strong>主节点不等从节点确认，立即返回给客户端</li>
                        <li><strong>数据一致性：</strong>短暂延迟（通常毫秒级），从节点最终与主节点一致</li>
                    </ul>
                    <p><strong>重要澄清：</strong></p>
                    <ul>
                        <li><strong>本节点的作用：</strong>更新Redis主节点的内存数据（缓存回写）</li>
                        <li><strong>不是主从切换：</strong>不涉及将从节点提升为主节点的操作</li>
                        <li><strong>主从切换场景：</strong>只有当主节点故障时，哨兵才会将某个从节点提升为新的主节点</li>
                        <li><strong>两个独立概念：</strong>
                            <ul>
                                <li>缓存更新：正常业务流程，将数据写入Redis主节点</li>
                                <li>主从切换：故障恢复流程，哨兵自动将从节点提升为主节点</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>内存管理：</strong></p>
                    <ul>
                        <li><strong>淘汰策略：</strong>当内存不足时，Redis自动淘汰过期key或不常用的key</li>
                        <li><strong>最大内存：</strong>maxmemory配置，如maxmemory 2GB</li>
                        <li><strong>淘汰算法：</strong>allkeys-lru（淘汰最少使用的key）、volatile-lru（淘汰过期且最少使用的key）</li>
                    </ul>
                    <p><strong>并发控制：</strong></p>
                    <ul>
                        <li><strong>原子操作：</strong>Redis命令是原子的，不会出现并发冲突</li>
                        <li><strong>事务支持：</strong>使用MULTI/EXEC执行多个命令，保证原子性</li>
                        <li><strong>乐观锁：</strong>使用WATCH命令监控key，CAS更新</li>
                    </ul>
                    <p><strong>性能优势：</strong></p>
                    <ul>
                        <li><strong>写入速度：</strong>Redis写入操作通常<1ms</li>
                        <li><strong>内存访问：</strong>后续请求直接从内存读取，无需查询数据库</li>
                        <li><strong>QPS提升：</strong>缓存更新后，QPS可提升10-100倍</li>
                    </ul>
                    <p><strong>业务价值：</strong>通过更新Redis主节点，将数据库数据缓存到内存，为后续请求提供快速访问，大幅提升系统性能和用户体验。</p>
                `;
            } else if (type === 'write-has-data') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>有数据：Redis中已存在数据（更新场景）</h4>
                    <p><strong>定义：</strong>写操作检查时，发现Redis主节点内存中已存在所查询的key，并且有对应的value，表示这是对已有数据的更新操作。</p>
                    <p><strong>有数据的体现：</strong></p>
                    <ul>
                        <li><strong>EXISTS命令：</strong>返回1（表示key存在）</li>
                        <li><strong>GET命令：</strong>返回了具体的数据（不是nil）</li>
                        <li><strong>TYPE命令：</strong>返回key的数据类型（string、hash、list等）</li>
                        <li><strong>TTL命令：</strong>返回key的剩余生存时间（-1表示永不过期，-2表示已过期）</li>
                    </ul>
                    <p><strong>有数据示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 检查用户ID=1001的数据
EXISTS user:1001
// 返回：1

GET user:1001
// 返回：'{"id":1001,"name":"张三","age":25}'

// 判断：Redis中有数据，执行更新操作
                    </pre>
                    <p><strong>业务场景：</strong></p>
                    <ul>
                        <li><strong>用户信息修改：</strong>用户修改昵称、头像、个人简介等</li>
                        <li><strong>订单状态变更：</strong>订单从"待支付"变为"已支付"、"已发货"</li>
                        <li><strong>库存扣减：</strong>商品库存数量减少</li>
                        <li><strong>积分更新：</strong>用户积分增加或减少</li>
                        <li><strong>配置更新：</strong>系统配置参数的修改</li>
                    </ul>
                    <p><strong>有数据后的处理流程：</strong></p>
                    <ol>
                        <li><strong>获取旧数据：</strong>
                            <ul>
                                <li>从Redis主节点获取当前存储的数据</li>
                                <li>解析数据（如果是JSON，反序列化为对象）</li>
                                <li>了解当前的数据状态和结构</li>
                            </ul>
                        </li>
                        <li><strong>合并更新：</strong>
                            <ul>
                                <li>将前端提交的更新数据与旧数据合并</li>
                                <li>只更新需要修改的字段，保留其他字段不变</li>
                                <li>执行业务逻辑验证（如库存不能为负数）</li>
                            </ul>
                        </li>
                        <li><strong>更新Redis主节点：</strong>
                            <ul>
                                <li>使用SET、HMSET等命令更新Redis主节点中的数据</li>
                                <li>如果是部分更新，使用HSET、HINCRBY等命令</li>
                                <li>保持TTL不变或重置TTL</li>
                            </ul>
                        </li>
                        <li><strong>更新数据库：</strong>
                            <ul>
                                <li>同时更新数据库中的对应数据</li>
                                <li>使用UPDATE SQL语句</li>
                                <li>确保Redis和数据库的数据一致性</li>
                            </ul>
                        </li>
                        <li><strong>事务保证：</strong>
                            <ul>
                                <li>Redis和数据库的更新操作必须在同一个事务中</li>
                                <li>要么全部成功，要么全部失败</li>
                                <li>避免出现Redis已更新但数据库未更新的不一致情况</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>有数据更新示例代码：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 伪代码：有数据场景的更新操作
user_key = "user:" + user_id

// 1. 检查Redis中是否有数据
exists = redis_client.exists(user_key)

if (exists == 1) {
    // 2. 获取旧数据
    old_data_json = redis_client.get(user_key)
    old_data = JSON.parse(old_data_json)

    // 3. 合并更新（只更新提交的字段）
    new_data = old_data
    if (params.name != null) {
        new_data.name = params.name
    }
    if (params.age != null) {
        new_data.age = params.age
    }

    // 4. 序列化新数据
    new_data_json = JSON.stringify(new_data)

    // 5. 事务操作：同时更新Redis和数据库
    begin_transaction()
    try {
        // 更新Redis主节点
        redis_client.set(user_key, new_data_json, "EX", 3600)

        // 更新数据库
        db.execute(
            "UPDATE users SET name=?, age=? WHERE id=?",
            new_data.name, new_data.age, user_id
        )

        // 提交事务
        commit_transaction()

        return "更新成功"
    } catch (error) {
        // 回滚事务
        rollback_transaction()
        return "更新失败"
    }
}
                    </pre>
                    <p><strong>更新Redis的数据结构操作：</strong></p>
                    <ul>
                        <li><strong>字符串（String）：</strong>SET key value 或 SET key value EX seconds</li>
                        <li><strong>哈希（Hash）：</strong>
                            <ul>
                                <li>单个字段：HSET hash field value</li>
                                <li>多个字段：HMSET hash field1 value1 field2 value2</li>
                                <li>数值递增：HINCRBY hash field increment</li>
                            </ul>
                        </li>
                        <li><strong>列表（List）：</strong>
                            <ul>
                                <li>左推入：LPUSH list value</li>
                                <li>右推入：RPUSH list value</li>
                                <li>指定索引：LSET list index value</li>
                            </ul>
                        </li>
                        <li><strong>集合（Set）：</strong>SADD set member</li>
                        <li><strong>有序集合（ZSet）：</strong>ZADD zset score member</li>
                    </ul>
                    <p><strong>性能优势：</strong></p>
                    <ul>
                        <li>直接更新已有数据，无需插入新数据</li>
                        <li>利用Redis的原子操作，性能极高</li>
                        <li>减少数据库的写入压力（如果只更新Redis）</li>
                        <li>但为了数据一致性，通常需要同步更新数据库</li>
                    </ul>
                    <p><strong>注意事项：</strong></p>
                    <ul>
                        <li>更新操作必须考虑并发问题，避免覆盖其他线程的更新</li>
                        <li>使用乐观锁（版本号）或分布式锁（SETNX）保证并发安全</li>
                        <li>注意TTL的设置，避免更新后TTL被清除导致数据永久驻留内存</li>
                        <li>如果是部分字段更新，使用HSET而不是SET，避免覆盖整个对象</li>
                    </ul>
                    <p><strong>业务价值：</strong>通过识别Redis中已有数据，执行更新操作，同时保持Redis和数据库的数据一致性，确保数据的准确性和实时性。</p>
                `;
            } else if (type === 'write-no-data') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>无数据：Redis中不存在数据（插入场景）</h4>
                    <p><strong>定义：</strong>写操作检查时，发现Redis主节点内存中不存在所查询的key，表示这是首次写入或数据已过期，需要查询数据库确认后执行插入操作。</p>
                    <p><strong>无数据的体现：</strong></p>
                    <ul>
                        <li><strong>EXISTS命令：</strong>返回0（表示key不存在）</li>
                        <li><strong>GET命令：</strong>返回nil（空值）</li>
                        <li><strong>TYPE命令：</strong>返回none（key不存在）</li>
                        <li><strong>TTL命令：</strong>返回-2（表示key已过期或不存在）</li>
                    </ul>
                    <p><strong>无数据示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 检查用户ID=9999的数据
EXISTS user:9999
// 返回：0

GET user:9999
// 返回：(nil)

// 判断：Redis中无数据，需要查询数据库
                    </pre>
                    <p><strong>业务场景：</strong></p>
                    <ul>
                        <li><strong>新用户注册：</strong>第一次创建用户数据</li>
                        <li><strong>新订单创建：</strong>用户首次下单，创建订单记录</li>
                        <li><strong>缓存过期：</strong>之前的数据已过期（TTL到期），需要重新加载</li>
                        <li><strong>缓存被清空：</strong>系统重启或管理员清空缓存后首次访问</li>
                        <li><strong>冷启动：</strong>系统刚启动，缓存为空</li>
                    </ul>
                    <p><strong>无数据后的处理流程：</strong></p>
                    <ol>
                        <li><strong>查询数据库：</strong>
                            <ul>
                                <li>执行SELECT查询，从数据库获取数据</li>
                                <li>判断数据库中是否存在该数据</li>
                                <li>有两种可能：数据库有数据、数据库无数据</li>
                            </ul>
                        </li>
                        <li><strong>情况1：数据库有数据（缓存过期/冷启动）</strong>
                            <ul>
                                <li>数据存在于数据库，但不在Redis中</li>
                                <li>需要更新数据库数据（如果有更新）</li>
                                <li>同时将数据写入Redis缓存</li>
                            </ul>
                        </li>
                        <li><strong>情况2：数据库无数据（首次插入）</strong>
                            <ul>
                                <li>数据库和Redis中都没有该数据</li>
                                <li>需要执行INSERT操作，插入新数据到数据库</li>
                                <li>同时将新数据写入Redis缓存</li>
                            </ul>
                        </li>
                        <li><strong>事务保证：</strong>
                            <ul>
                                <li>数据库操作和Redis操作必须在同一个事务中</li>
                                <li>要么全部成功（数据库插入/更新 + Redis写入）</li>
                                <li>要么全部失败（回滚所有操作）</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>无数据更新示例代码：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 伪代码：无数据场景的处理操作
user_key = "user:" + user_id

// 1. 检查Redis中是否有数据
exists = redis_client.exists(user_key)

if (exists == 0) {
    // 2. 查询数据库
    user = db.query("SELECT * FROM users WHERE id = ?", user_id)

    if (user != null) {
        // 情况1：数据库有数据（缓存过期或冷启动）

        // 3. 更新数据（如果有更新）
        if (params.name != null) {
            user.name = params.name
        }
        if (params.age != null) {
            user.age = params.age
        }

        // 4. 序列化数据
        user_json = JSON.stringify(user)

        // 5. 事务操作：更新数据库和Redis
        begin_transaction()
        try {
            // 更新数据库
            db.execute(
                "UPDATE users SET name=?, age=? WHERE id=?",
                user.name, user.age, user_id
            )

            // 写入Redis缓存，设置1小时过期
            redis_client.set(user_key, user_json, "EX", 3600)

            commit_transaction()
            return "更新成功"
        } catch (error) {
            rollback_transaction()
            return "更新失败"
        }
    } else {
        // 情况2：数据库也无数据（首次插入）

        // 3. 准备新数据
        new_user = {
            id: user_id,
            name: params.name,
            age: params.age,
            email: params.email,
            created_at: now()
        }

        // 4. 序列化数据
        new_user_json = JSON.stringify(new_user)

        // 5. 事务操作：插入数据库和Redis
        begin_transaction()
        try {
            // 插入数据库
            db.execute(
                "INSERT INTO users (id, name, age, email, created_at) VALUES (?, ?, ?, ?, ?)",
                new_user.id, new_user.name, new_user.age, new_user.email, new_user.created_at
            )

            // 写入Redis缓存，设置1小时过期
            redis_client.set(user_key, new_user_json, "EX", 3600)

            commit_transaction()
            return "创建成功"
        } catch (error) {
            rollback_transaction()
            return "创建失败"
        }
    }
}
                    </pre>
                    <p><strong>为什么需要查询数据库：</strong></p>
                    <ul>
                        <li><strong>数据可能只在数据库中：</strong>缓存过期或被清空后，数据只存在于数据库</li>
                        <li><strong>避免重复插入：</strong>直接插入可能导致主键冲突或数据重复</li>
                        <li><strong>数据完整性：</strong>需要确认数据库的真实状态</li>
                        <li><strong>业务逻辑：</strong>某些业务需要在现有数据基础上更新</li>
                    </ul>
                    <p><strong>INSERT vs UPDATE的选择：</strong></p>
                    <ul>
                        <li><strong>数据库有数据：</strong>执行UPDATE语句，更新现有记录</li>
                        <li><strong>数据库无数据：</strong>执行INSERT语句，创建新记录</li>
                        <li><strong>合并写法：</strong>使用INSERT ... ON DUPLICATE KEY UPDATE（MySQL）或MERGE INTO（Oracle）</li>
                    </ul>
                    <p><strong>性能影响：</strong></p>
                    <ul>
                        <li>需要额外查询数据库，增加一次数据库交互</li>
                        <li>响应时间比"有数据"场景略长</li>
                        <li>但保证了数据的准确性和一致性</li>
                    </ul>
                    <p><strong>优化策略：</strong></p>
                    <ul>
                        <li><strong>缓存预热：</strong>系统启动时提前加载热点数据到Redis</li>
                        <li><strong>延长TTL：</strong>合理设置过期时间，减少"无数据"场景</li>
                        <li><strong>布隆过滤器：</strong>快速判断key是否在数据库中存在</li>
                        <li><strong>批量加载：</strong>检测到缓存miss时，批量预加载相关数据</li>
                    </ul>
                    <p><strong>业务价值：</strong>通过查询数据库确认数据状态，执行正确的插入或更新操作，确保数据完整性和一致性，避免数据冲突或重复。</p>
                `;
            } else if (type === 'write-query-db-transaction') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>查询DB & 事务更新DB & 更新Redis主节点：事务一致性保证</h4>
                    <p><strong>作用：</strong>在无数据场景下，先查询数据库确认数据状态，然后使用事务机制同时更新数据库和Redis主节点，确保两者的数据一致性。</p>
                    <p><strong>什么是事务一致性：</strong></p>
                    <ul>
                        <li><strong>定义：</strong>事务是一个或多个SQL语句组成的逻辑单元，这些语句要么全部成功执行，要么全部不执行，不会出现部分成功部分失败的情况。</li>
                        <li><strong>ACID特性：</strong>
                            <ol>
                                <li><strong>原子性（Atomicity）：</strong>事务中的操作是一个不可分割的整体，要么全部成功，要么全部失败回滚。不会出现数据库已更新但Redis未更新的不一致状态。</li>
                                <li><strong>一致性（Consistency）：</strong>事务执行前后，数据库从一个一致性状态变换到另一个一致性状态。所有业务规则和约束都得到满足。例如：库存扣减后不能为负数。</li>
                                <li><strong>隔离性（Isolation）：</strong>并发执行的事务之间相互隔离，一个事务的中间状态对其他事务不可见，避免并发冲突。例如：两个用户同时修改同一个用户信息。</li>
                                <li><strong>持久性（Durability）：</strong>事务一旦提交，对数据的修改就是永久性的，即使系统故障也不会丢失。</li>
                            </ol>
                        </li>
                    </ul>
                    <p><strong>为什么需要事务一致性：</strong></p>
                    <ul>
                        <li><strong>避免数据不一致：</strong>
                            <ul>
                                <li>如果数据库更新成功但Redis更新失败 → 数据不一致</li>
                                <li>如果Redis更新成功但数据库更新失败 → 数据不一致</li>
                                <li>示例：用户修改昵称，数据库已改为"李四"，但Redis还是"张三"，下次查询返回旧数据</li>
                            </ul>
                        </li>
                        <li><strong>保证业务正确性：</strong>
                            <ul>
                                <li>库存扣减：必须同时更新数据库库存和Redis缓存，避免超卖</li>
                                <li>余额转账：必须同时扣减一方余额和增加另一方余额</li>
                                <li>订单状态：必须同步更新数据库和Redis中的订单状态</li>
                            </ul>
                        </li>
                        <li><strong>用户体验：</strong>
                            <ul>
                                <li>确保用户看到的始终是最新的、准确的数据</li>
                                <li>避免用户看到修改后又变回旧数据的"数据回滚"现象</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>如何保证事务一致性：</strong></p>
                    <h5>方法1：数据库事务 + Redis回滚补偿（推荐）</h5>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 伪代码：数据库事务 + Redis回滚补偿
begin_transaction()  // 开始数据库事务

try {
    // 1. 更新数据库
    db.execute("UPDATE users SET name=?, age=? WHERE id=?", new_name, new_age, user_id)

    // 2. 更新Redis主节点
    success = redis_client.set(user_key, new_data_json, "EX", 3600)

    if (success) {
        // 3. Redis更新成功，提交数据库事务
        commit_transaction()
        return "更新成功"
    } else {
        // 4. Redis更新失败，回滚数据库事务
        rollback_transaction()
        return "Redis更新失败"
    }
} catch (db_error) {
    // 5. 数据库操作失败，回滚事务
    rollback_transaction()

    // 6. 尝试回滚Redis（删除已写入的数据）
    redis_client.del(user_key)

    return "数据库更新失败"
}
                    </pre>
                    <h5>方法2：两阶段提交（2PC，Two-Phase Commit）</h5>
                    <ul>
                        <li><strong>阶段1：准备阶段（Prepare Phase）</strong>
                            <ul>
                                <li>事务协调器询问所有参与者（数据库、Redis）是否准备好提交</li>
                                <li>参与者执行操作但不提交，返回"准备就绪"或"准备失败"</li>
                            </ul>
                        </li>
                        <li><strong>阶段2：提交阶段（Commit Phase）</strong>
                            <ul>
                                <li>如果所有参与者都返回"准备就绪"，协调器发送"提交"命令</li>
                                <li>如果有任何参与者返回"准备失败"，协调器发送"回滚"命令</li>
                            </ul>
                        </li>
                        <li><strong>优点：</strong>强一致性保证</li>
                        <li><strong>缺点：</strong>实现复杂，性能较差，存在阻塞</li>
                    </ul>
                    <h5>方法3：TCC模式（Try-Confirm-Cancel，尝试-确认-取消）</h5>
                    <ul>
                        <li><strong>Try阶段：</strong>尝试执行操作，预留资源
                            <ul>
                                <li>数据库：检查数据是否存在，锁定记录</li>
                                <li>Redis：检查key是否可写入</li>
                            </ul>
                        </li>
                        <li><strong>Confirm阶段：</strong>确认执行，提交所有操作
                            <ul>
                                <li>数据库：执行UPDATE或INSERT</li>
                                <li>Redis：执行SET写入</li>
                            </ul>
                        </li>
                        <li><strong>Cancel阶段：</strong>取消操作，释放资源
                            <ul>
                                <li>数据库：释放锁，回滚已执行的修改</li>
                                <li>Redis：删除已写入的数据</li>
                            </ul>
                        </li>
                        <li><strong>优点：</strong>性能较好，最终一致性</li>
                        <li><strong>缺点：</strong>需要编写Try、Confirm、Cancel三个方法，代码复杂</li>
                    </ul>
                    <h5>方法4：基于消息队列的最终一致性（异步）</h5>
                    <ul>
                        <li><strong>写流程：</strong>
                            <ol>
                                <li>先更新数据库（事务提交）</li>
                                <li>将更新操作发送到消息队列（MQ）</li>
                                <li>消息队列保证消息不丢失（持久化、确认机制）</li>
                                <li>消费者监听消息，更新Redis缓存</li>
                            </ol>
                        </li>
                        <li><strong>优点：</strong>解耦数据库和Redis，性能好</li>
                        <li><strong>缺点：</strong>最终一致性（短暂延迟），需要处理消息失败重试</li>
                        <li><strong>适用场景：</strong>高并发、对实时性要求不高的场景</li>
                    </ul>
                    <p><strong>事务隔离级别：</strong></p>
                    <ul>
                        <li><strong>读未提交（Read Uncommitted）：</strong>可能读到脏数据（不推荐）</li>
                        <li><strong>读已提交（Read Committed）：</strong>只能读到已提交的数据（推荐大多数场景）</li>
                        <li><strong>可重复读（Repeatable Read）：</strong>MySQL默认级别，防止幻读</li>
                        <li><strong>串行化（Serializable）：</strong>最高隔离级别，完全串行执行（性能差）</li>
                    </ul>
                    <p><strong>并发控制机制：</strong></p>
                    <ul>
                        <li><strong>乐观锁（Optimistic Lock）：</strong>
                            <ul>
                                <li>使用版本号（version）或时间戳（updated_at）字段</li>
                                <li>更新时检查版本号是否变化，变化则说明有其他事务已修改</li>
                                <li>示例：UPDATE users SET name=?, age=?, version=version+1 WHERE id=? AND version=?</li>
                                <li>优点：无需加锁，并发性能好</li>
                                <li>缺点：高并发时冲突率高，需要重试</li>
                            </ul>
                        </li>
                        <li><strong>悲观锁（Pessimistic Lock）：</strong>
                            <ul>
                                <li>使用SELECT ... FOR UPDATE锁定数据行</li>
                                <li>其他事务无法修改被锁定的行，直到锁释放</li>
                                <li>优点：强一致性，避免并发冲突</li>
                                <li>缺点：并发性能差，容易死锁</li>
                            </ul>
                        </li>
                        <li><strong>分布式锁：</strong>
                            <ul>
                                <li>使用Redis的SETNX命令实现分布式锁</li>
                                <li>或使用Redlock算法（多个Redis实例）</li>
                                <li>确保在分布式环境下，同一时刻只有一个线程能执行关键操作</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>完整事务流程示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 伪代码：完整的事务一致性保证流程
function update_user_with_transaction(user_id, params) {
    user_key = "user:" + user_id

    // 1. 查询数据库
    user = db.query("SELECT * FROM users WHERE id = ? FOR UPDATE", user_id)

    begin_transaction()

    try {
        if (user != null) {
            // 情况1：数据库有数据，执行UPDATE
            new_user = merge_user(user, params)
            db.execute(
                "UPDATE users SET name=?, age=?, version=version+1 WHERE id=? AND version=?",
                new_user.name, new_user.age, user_id, user.version
            )
        } else {
            // 情况2：数据库无数据，执行INSERT
            new_user = {
                id: user_id,
                name: params.name,
                age: params.age,
                version: 1
            }
            db.execute(
                "INSERT INTO users (id, name, age, version) VALUES (?, ?, ?, ?)",
                new_user.id, new_user.name, new_user.age, new_user.version
            )
        }

        // 2. 序列化数据
        new_user_json = JSON.stringify(new_user)

        // 3. 更新Redis主节点
        redis_success = redis_client.set(user_key, new_user_json, "EX", 3600)

        if (!redis_success) {
            // Redis更新失败，回滚数据库事务
            throw new Exception("Redis更新失败")
        }

        // 4. 提交数据库事务
        commit_transaction()

        return {success: true, data: new_user}

    } catch (error) {
        // 5. 发生错误，回滚数据库事务
        rollback_transaction()

        // 6. 尝试回滚Redis（如果已写入）
        redis_client.del(user_key)

        return {success: false, error: error.message}
    }
}
                    </pre>
                    <p><strong>失败重试机制：</strong></p>
                    <ul>
                        <li><strong>Redis更新失败：</strong>记录日志，告警通知，人工介入处理</li>
                        <li><strong>数据库更新失败：</strong>回滚Redis，重试整个事务</li>
                        <li><strong>网络超时：</strong>设置合理的超时时间，超时后重试或回滚</li>
                        <li><strong>死锁处理：</strong>检测到死锁时，回滚当前事务，等待随机时间后重试</li>
                    </ul>
                    <p><strong>性能优化：</strong></p>
                    <ul>
                        <li><strong>减少事务持有时间：</strong>事务中只包含必要的操作，避免长时间锁定</li>
                        <li><strong>批量操作：</strong>如果可能，将多个更新合并为一个事务</li>
                        <li><strong>异步更新：</strong>对实时性要求不高的场景，可以使用MQ异步更新Redis</li>
                        <li><strong>读写分离：</strong>写操作走主节点，读操作走从节点，减轻主节点压力</li>
                    </ul>
                    <p><strong>业务价值：</strong>通过事务机制保证数据库和Redis的数据一致性，避免数据冲突和不一致，确保业务逻辑的正确性和用户体验的可靠性。</p>
                `;
            } else if (type === 'return-nginx') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>返回Nginx网关</h4>
                    <p><strong>作用：</strong>业务处理完成后，将结果返回给Nginx网关，由Nginx返回给前端。</p>
                    <p><strong>返回流程：</strong></p>
                    <ol>
                        <li>业务模块处理完成，生成响应数据</li>
                        <li>后端服务将响应返回给Nginx网关</li>
                        <li>Nginx网关进行必要的处理（如添加响应头、Gzip压缩等）</li>
                        <li>Nginx将响应返回给前端App/Web</li>
                    </ol>
                    <p><strong>适用场景：</strong></p>
                    <ul>
                        <li><strong>不需要数据库操作的业务：</strong>直接返回结果。</li>
                        <li><strong>纯计算操作：</strong>计算完成后返回结果。</li>
                        <li><strong>缓存命中：</strong>从Redis获取数据后返回。</li>
                        <li><strong>静态数据：</strong>返回配置数据或常量。</li>
                    </ul>
                    <p><strong>Nginx处理能力：</strong></p>
                    <ul>
                        <li><strong>负载均衡：</strong>将请求分发到健康的后端服务。</li>
                        <li><strong>反向代理：</strong>隐藏后端服务真实地址。</li>
                        <li><strong>响应缓存：</strong>缓存静态资源，减少后端压力。</li>
                        <li><strong>SSL终止：</strong>处理HTTPS加密解密。</li>
                    </ul>
                    <p><strong>优势：</strong>简化前端对接，统一接口入口，提高系统安全性。</p>
                `;
            } else if (type === 'health-monitor') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>后端服务健康监控</h4>
                    <p><strong>作用：</strong>Nginx持续监控后端服务的健康状态，确保只将流量分发到健康的服务。</p>
                    <p><strong>监控机制：</strong></p>
                    <ul>
                        <li><strong>主动健康检查：</strong>Nginx定期向后端服务发送健康检查请求（默认/health端点）。</li>
                        <li><strong>检查频率：</strong>可配置间隔时间（如每5秒检查一次）。</li>
                        <li><strong>超时设置：</strong>请求超时时间（如3秒未响应视为失败）。</li>
                        <li><strong>失败阈值：</strong>连续失败N次标记为不健康（如max_fails=3）。</li>
                    </ul>
                    <p><strong>健康状态：</strong></p>
                    <ul>
                        <li><strong>健康（Up）：</strong>服务正常运行，可以接收请求。</li>
                        <li><strong>不健康（Down）：</strong>服务故障或超时，不再接收新请求。</li>
                        <li><strong>恢复检测：</strong>不健康的服务恢复后，需要通过健康检查才能重新上线。</li>
                    </ul>
                    <p><strong>故障转移流程：</strong></p>
                    <ol>
                        <li>主服务连续失败max_fails次</li>
                        <li>Nginx将主服务标记为不健康</li>
                        <li>自动将流量切换到备用服务</li>
                        <li>主服务恢复后，健康检查通过重新上线</li>
                    </ol>
                    <p><strong>Nginx配置示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
upstream backend {
    server 192.168.2.10:8080 max_fails=3 fail_timeout=30s;
    server 192.168.2.11:8080 backup;

    # 主动健康检查（需要nginx_plus或第三方模块）
    check interval=5000 rise=2 fall=3 timeout=3000;
}
                    </pre>
                    <p><strong>优势：</strong>提高系统可用性，实现自动故障转移，减少人工干预。</p>
                `;
            } else if (type === 'nginx-switch') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>Nginx自动切换备用服务</h4>
                    <p><strong>作用：</strong>当主后端服务故障时，Nginx自动将流量切换到备用服务，确保业务连续性。</p>
                    <p><strong>工作原理：</strong></p>
                    <ul>
                        <li><strong>健康检查：</strong>Nginx定期向后端服务发送健康检查请求</li>
                        <li><strong>失败计数：</strong>连续失败max_fails次后，标记服务为不健康</li>
                        <li><strong>自动切换：</strong>主服务不健康时，自动将流量路由到备用服务</li>
                        <li><strong>恢复检测：</strong>主服务恢复后，健康检查通过后重新加入负载均衡池</li>
                    </ul>
                    <p><strong>实现方式：</strong></p>
                    <ul>
                        <li><strong>被动健康检查（Nginx开源版）：</strong>
                            <ul>
                                <li>通过max_fails和fail_timeout参数配置</li>
                                <li>max_fails=3：连续失败3次标记为不健康</li>
                                <li>fail_timeout=30s：30秒后重新尝试连接</li>
                                <li>backup标记：备用服务器只在工作服务器都不可用时才接收流量</li>
                            </ul>
                        </li>
                        <li><strong>主动健康检查（Nginx Plus或第三方模块）：</strong>
                            <ul>
                                <li>定期发送健康检查请求到指定端点（如/health）</li>
                                <li>可配置检查间隔、超时时间、成功/失败阈值</li>
                                <li>更灵活、更精确的健康状态监控</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>Nginx配置示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
upstream backend {
    # 主服务
    server 192.168.2.10:8080 max_fails=3 fail_timeout=30s;

    # 备用服务
    server 192.168.2.11:8080 backup;
}

# 主动健康检查（需要nginx_plus或第三方模块）
check interval=5000 rise=2 fall=3 timeout=3000;
                    </pre>
                    <p><strong>切换流程：</strong></p>
                    <ol>
                        <li>Nginx检测到主服务连续失败3次</li>
                        <li>将主服务标记为不健康（down）</li>
                        <li>自动将新请求发送到备用服务</li>
                        <li>30秒后定期尝试重新连接主服务</li>
                        <li>主服务恢复后，重新加入负载均衡池</li>
                    </ol>
                    <p><strong>优势：</strong>实现自动故障转移，无需人工干预，提高系统可用性达到99.9%以上。</p>
                `;
            } else if (type === 'hot-data-server') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>独立热数据服务器</h4>
                    <p><strong>定义：</strong>专门用于存储和管理频繁访问的"热数据"的高性能服务器。</p>
                    <p><strong>主要功能：</strong></p>
                    <ul>
                        <li><strong>快速响应：</strong>使用高性能存储（SSD、NVMe），确保低延迟访问</li>
                        <li><strong>高并发处理：</strong>优化数据库配置，支持大量并发查询</li>
                        <li><strong>内存缓存：</strong>增大内存配置，将更多热数据缓存到内存</li>
                        <li><strong>读写优化：</strong>优化索引、分区策略，提高读写性能</li>
                    </ul>
                    <p><strong>热数据特征：</strong></p>
                    <ul>
                        <li>频繁访问的数据（如最近7天的订单）</li>
                        <li>用户活跃数据（如在线用户信息）</li>
                        <li>实时业务数据（如当前直播间数据）</li>
                        <li>最近创建或修改的数据</li>
                    </ul>
                    <p><strong>硬件配置建议：</strong></p>
                    <ul>
                        <li>CPU：高性能多核处理器</li>
                        <li>内存：大容量内存（如64GB、128GB）</li>
                        <li>存储：SSD或NVMe高速存储</li>
                        <li>网络：万兆网卡，低延迟</li>
                    </ul>
                    <p><strong>优化策略：</strong></p>
                    <ul>
                        <li>合理的索引设计</li>
                        <li>定期分析慢查询并优化</li>
                        <li>合理设置缓存大小</li>
                        <li>读写分离，从库分担读压力</li>
                    </ul>
                    <p><strong>优势：</strong>显著提升热数据访问速度，改善用户体验，降低冷数据服务器的压力。</p>
                `;
            } else if (type === 'cold-data-server') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>集合冷数据服务器</h4>
                    <p><strong>定义：</strong>用于存储不常访问的"冷数据"的服务器，通常使用成本较低的存储方案。</p>
                    <p><strong>主要功能：</strong></p>
                    <ul>
                        <li><strong>归档存储：</strong>存储历史数据、过期数据</li>
                        <li><strong>数据备份：</strong>作为热数据的备份，防止数据丢失</li>
                        <li><strong>合规存储：</strong>满足法规要求的数据保留期限</li>
                        <li><strong>分析查询：</strong>支持数据分析、报表生成等操作</li>
                    </ul>
                    <p><strong>冷数据特征：</strong></p>
                    <ul>
                        <li>不常访问的历史数据（如一年前的订单）</li>
                        <li>已归档的业务数据</li>
                        <li>超过一定时间的数据（如一个月前）</li>
                        <li>用于审计、分析的数据</li>
                    </ul>
                    <p><strong>存储策略：</strong></p>
                    <ul>
                        <li><strong>压缩存储：</strong>使用数据压缩技术，节省存储空间</li>
                        <li><strong>分级存储：</strong>热数据、温数据、冷数据分层存储</li>
                        <li><strong>定期归档：</strong>自动将超期数据迁移到冷存储</li>
                        <li><strong>冗余备份：</strong>多副本存储，保证数据安全</li>
                    </ul>
                    <p><strong>硬件配置：</strong></p>
                    <ul>
                        <li>使用大容量HDD存储，成本较低</li>
                        <li>配置适中的CPU和内存</li>
                        <li>可以使用分布式存储系统</li>
                        <li>支持数据压缩和去重</li>
                    </ul>
                    <p><strong>访问特点：</strong></p>
                    <ul>
                        <li>查询性能较低，但不影响业务正常运行</li>
                        <li>主要用于后台分析、报表生成</li>
                        <li>支持批量查询，不支持高并发实时查询</li>
                    </ul>
                    <p><strong>优势：</strong>降低存储成本，优化热数据服务器性能，满足数据合规要求。</p>
                `;
            } else if (type === 'cold-backup') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>冷数据备份</h4>
                    <p><strong>作用：</strong>将一个月前的历史数据定期备份到冷数据库，释放热数据服务器的存储空间。</p>
                    <p><strong>备份策略：</strong></p>
                    <ul>
                        <li><strong>时间策略：</strong>定期执行（如每月1号凌晨执行数据迁移）</li>
                        <li><strong>数据筛选：</strong>将创建时间超过30天的数据标记为冷数据</li>
                        <li><strong>数据迁移：</strong>将冷数据从热数据库迁移到冷数据库</li>
                        <li><strong>数据清理：</strong>热数据库中删除已迁移的冷数据</li>
                    </ul>
                    <p><strong>备份流程：</strong></p>
                    <ol>
                        <li>扫描热数据库，识别超过30天的数据</li>
                        <li>将数据导出到临时文件或直接迁移到冷数据库</li>
                        <li>验证数据完整性</li>
                        <li>从热数据库删除已备份的数据</li>
                        <li>记录备份日志，便于追溯</li>
                    </ol>
                    <p><strong>数据保留策略：</strong></p>
                    <ul>
                        <li><strong>短期备份：</strong>保留最近3个月的冷数据</li>
                        <li><strong>中期备份：</strong>保留最近1年的数据</li>
                        <li><strong>长期归档：</strong>保留超过1年的数据，用于审计和分析</li>
                        <li><strong>永久保存：</strong>关键业务数据永久保存</li>
                    </ul>
                    <p><strong>注意事项：</strong></p>
                    <ul>
                        <li>备份前必须验证数据完整性</li>
                        <li>使用事务确保备份过程的原子性</li>
                        <li>备份过程中避免影响业务正常运行</li>
                        <li>定期测试备份恢复流程</li>
                    </ul>
                    <p><strong>优势：</strong>优化热数据存储，降低成本，满足数据合规要求，保留历史数据用于分析。</p>
                `;
            } else if (type === 'cold-db') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>可查询冷DB</h4>
                    <p><strong>作用：</strong>冷数据库虽然性能较低，但仍然支持查询操作，用于历史数据查询和数据分析。</p>
                    <p><strong>查询场景：</strong></p>
                    <ul>
                        <li><strong>历史订单查询：</strong>用户查询几个月前的订单记录</li>
                        <li><strong>数据分析：</strong>业务分析、趋势分析、报表生成</li>
                        <li><strong>审计查询：</strong>审计人员查询历史操作记录</li>
                        <li><strong>合规检查：</strong>满足监管要求的数据查询</li>
                    </ul>
                    <p><strong>查询特点：</strong></p>
                    <ul>
                        <li><strong>响应时间较慢：</strong>通常在秒级到分钟级</li>
                        <li><strong>支持批量查询：</strong>适合批量数据导出</li>
                        <li><strong>不支持高并发：</strong>限制并发查询数量</li>
                        <li><strong>只读优先：</strong>建议设计为只读数据库</li>
                    </ul>
                    <p><strong>查询优化：</strong></p>
                    <ul>
                        <li>建立合适的索引，加快查询速度</li>
                        <li>使用分区表，按时间分区</li>
                        <li>限制返回结果数量，使用分页</li>
                        <li>使用物化视图，预计算常用查询</li>
                    </ul>
                    <p><strong>访问权限：</strong></p>
                    <ul>
                        <li>限制访问权限，只允许授权用户查询</li>
                        <li>记录所有查询操作，用于审计</li>
                        <li>敏感数据需要脱敏处理</li>
                        <li>大数据导出需要审批</li>
                    </ul>
                    <p><strong>优势：</strong>保留历史数据查询能力，同时不影响热数据库性能，降低存储成本。</p>
                `;
            } else if (type === 'transaction') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>事务保护</h4>
                    <p><strong>作用：</strong>确保数据库操作的ACID特性，保证数据一致性和完整性。</p>
                    <p><strong>ACID特性：</strong></p>
                    <ul>
                        <li><strong>原子性（Atomicity）：</strong>事务中的操作要么全部成功，要么全部失败回滚</li>
                        <li><strong>一致性（Consistency）：</strong>事务执行前后，数据库从一个一致性状态变换到另一个一致性状态</li>
                        <li><strong>隔离性（Isolation）：</strong>并发事务之间相互隔离，不会互相干扰</li>
                        <li><strong>持久性（Durability）：</strong>事务一旦提交，对数据库的修改是永久性的</li>
                    </ul>
                    <p><strong>事务应用场景：</strong></p>
                    <ul>
                        <li><strong>转账操作：</strong>一个账户扣款，另一个账户加款，必须同时成功或同时失败</li>
                        <li><strong>订单创建：</strong>创建订单、扣减库存、生成物流单，必须保持一致性</li>
                        <li><strong>Redis和数据库同步：</strong>更新Redis和数据库，必须同时成功</li>
                        <li><strong>批量操作：</strong>批量插入、批量更新，必须全部成功或全部回滚</li>
                    </ul>
                    <p><strong>事务隔离级别：</strong></p>
                    <ul>
                        <li><strong>读未提交（READ UNCOMMITTED）：</strong>可能读到脏数据，不推荐使用</li>
                        <li><strong>读已提交（READ COMMITTED）：</strong>只能读到已提交的数据，推荐使用</li>
                        <li><strong>可重复读（REPEATABLE READ）：</strong>MySQL默认级别，防止幻读</li>
                        <li><strong>串行化（SERIALIZABLE）：</strong>最高隔离级别，性能较差</li>
                    </ul>
                    <p><strong>分布式事务：</strong></p>
                    <ul>
                        <li><strong>2PC（两阶段提交）：</strong>准备阶段和提交阶段</li>
                        <li><strong>TCC（Try-Confirm-Cancel）：</strong>尝试、确认、取消</li>
                        <li><strong>本地消息表：</strong>通过消息队列实现最终一致性</li>
                        <li><strong>Saga模式：</strong>长事务拆分为多个短事务</li>
                    </ul>
                    <p><strong>注意事项：</strong></p>
                    <ul>
                        <li>事务尽可能短小，避免长事务锁定资源</li>
                        <li>合理设置隔离级别，平衡性能和一致性</li>
                        <li>注意死锁问题，设置合理的锁超时时间</li>
                        <li>分布式事务会影响性能，谨慎使用</li>
                    </ul>
                    <p><strong>优势：</strong>保证数据一致性，避免数据异常，确保业务逻辑正确执行。</p>
                `;
            } else if (type === 'redis-refresh') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>定时刷新Redis-DB</h4>
                    <p><strong>作用：</strong>定期将Redis中的数据持久化到数据库，确保数据不丢失，同时保持Redis和数据库的数据一致性。</p>
                    <p><strong>刷新策略：</strong></p>
                    <ul>
                        <li><strong>定时刷新：</strong>每隔一段时间（如每5分钟）将Redis数据写入数据库</li>
                        <li><strong>增量刷新：</strong>只刷新有变化的数据，减少数据库压力</li>
                        <li><strong>批量刷新：</strong>将多个Redis操作合并为一个数据库事务</li>
                        <li><strong>异步刷新：</strong>使用后台线程异步执行，不阻塞主流程</li>
                    </ul>
                    <p><strong>刷新流程：</strong></p>
                    <ol>
                        <li>定时任务触发，扫描Redis中的所有key</li>
                        <li>识别有变化的key（通过版本号或时间戳）</li>
                        <li>将变化的数据批量写入数据库</li>
                        <li>清除Redis中已过期或不需要的数据</li>
                        <li>记录刷新日志，便于监控和排查问题</li>
                    </ol>
                    <p><strong>实现方式：</strong></p>
                    <ul>
                        <li><strong>定时任务：</strong>使用Quartz、Spring Scheduled等定时任务框架</li>
                        <li><strong>消息队列：</strong>通过MQ触发数据刷新任务</li>
                        <li><strong>变更日志：</strong>记录Redis操作日志，定期批量写入数据库</li>
                        <li><strong>双写一致性：</strong>写操作同时更新Redis和数据库</li>
                    </ul>
                    <p><strong>注意事项：</strong></p>
                    <ul>
                        <li>避免在高峰期执行刷新任务</li>
                        <li>合理设置刷新间隔，平衡实时性和性能</li>
                        <li>做好异常处理，刷新失败时记录日志并重试</li>
                        <li>监控Redis内存使用，防止内存溢出</li>
                    </ul>
                    <p><strong>优势：</strong>保证数据持久化，防止Redis故障导致数据丢失，保持数据一致性。</p>
                `;
            } else if (type === 'sharding') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>分库分表处理</h4>
                    <p><strong>作用：</strong>将大表拆分成多个小表，分布到多个数据库服务器上，提高系统性能和可扩展性。</p>
                    <p><strong>为什么要分库分表：</strong></p>
                    <ul>
                        <li><strong>性能瓶颈：</strong>单表数据量过大，查询变慢</li>
                        <li><strong>存储瓶颈：</strong>单机存储空间有限</li>
                        <li><strong>并发瓶颈：</strong>单机连接数有限，无法支持高并发</li>
                        <li><strong>扩展需求：</strong>业务增长需要扩容</li>
                    </ul>
                    <p><strong>分库分表策略：</strong></p>
                    <ul>
                        <li><strong>水平分表（Sharding）：</strong>
                            <ul>
                                <li>按范围分片：如按时间、按ID范围</li>
                                <li>按哈希分片：如user_id % 10，均匀分布</li>
                                <li>地理位置分片：按用户所在地区分布</li>
                            </ul>
                        </li>
                        <li><strong>垂直分库：</strong>
                            <ul>
                                <li>按业务模块分库：用户库、订单库、商品库</li>
                                <li>按表关系分库：频繁关联的表放在同一库</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>分片算法：</strong></p>
                    <ul>
                        <li><strong>取模分片：</strong>user_id % 分片数，简单均匀</li>
                        <li><strong>范围分片：</strong>ID范围分片，便于查询</li>
                        <li><strong>一致性哈希：</strong>节点扩容时数据迁移少</li>
                        <li><strong>地理位置：</strong>按地域分片，就近访问</li>
                    </ul>
                    <p><strong>数据路由：</strong></p>
                    <ul>
                        <li>客户端路由：应用层根据分片规则选择数据库</li>
                        <li>代理层路由：通过MyCat、ShardingSphere等中间件路由</li>
                        <li>支持跨库查询、聚合、排序</li>
                        <li>需要处理分布式事务</li>
                    </ul>
                    <p><strong>注意事项：</strong></p>
                    <ul>
                        <li>提前规划分片策略，避免后期扩容困难</li>
                        <li>跨库查询性能较差，避免频繁跨库操作</li>
                        <li>分布式ID生成，确保全局唯一</li>
                        <li>做好数据迁移和备份方案</li>
                    </ul>
                    <p><strong>优势：</strong>提高查询性能、支持高并发、易于扩展、降低单机压力。</p>
                `;
            } else if (type === 'sentinel-monitoring-process') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>哨兵监控：健康检查业务流程</h4>
                    <p><strong>业务含义：</strong>这是哨兵持续监控Redis主从节点健康状态的动态过程，是整个高可用机制的基础环节。</p>
                    <p><strong>触发条件：</strong></p>
                    <ul>
                        <li><strong>定时触发：</strong>哨兵启动后自动开启监控线程，每隔1秒（默认）执行一次健康检查</li>
                        <li><strong>持续运行：</strong>24小时不间断监控，无论是否有客户端请求</li>
                        <li><strong>全量覆盖：</strong>监控所有Redis节点（1个主节点 + N个从节点）</li>
                    </ul>
                    <p><strong>监控原理：</strong></p>
                    <ol>
                        <li><strong>PING-PONG心跳检测：</strong>
                            <ul>
                                <li>哨兵向Redis节点发送PING命令</li>
                                <li>记录发送时间戳，等待响应</li>
                                <li>收到PONG响应：计算往返时间（RTT），更新节点状态为"健康"</li>
                                <li>未收到响应：继续等待，直到超时</li>
                            </ul>
                        </li>
                        <li><strong>超时判定：</strong>
                            <ul>
                                <li>如果down-after-milliseconds时间内（默认30秒）未收到有效响应</li>
                                <li>哨兵标记该节点为"主观下线"（SDOWN）</li>
                                <li>记录下线时间、下线原因等信息到日志</li>
                            </ul>
                        </li>
                        <li><strong>询问其他哨兵：</strong>
                            <ul>
                                <li>发现节点主观下线后，哨兵向其他所有哨兵发送SENTINEL is-master-down-by-addr命令</li>
                                <li>询问："你们也认为这个主节点下线了吗？"</li>
                                <li>收集其他哨兵的回复（是/否）</li>
                                <li>统计认为主节点下线的哨兵数量</li>
                            </ul>
                        </li>
                        <li><strong>客观下线判定：</strong>
                            <ul>
                                <li>如果quorum个哨兵（如2个）都确认主节点下线</li>
                                <li>哨兵将主节点标记为"客观下线"（ODOWN）</li>
                                <li>触发下一个环节：自动故障转移</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>监控状态机：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
节点状态流转：
[在线] --(ping超时30s)--> [主观下线SDOWN] --(quorum确认)--> [客观下线ODOWN] --(故障转移)--> [新主节点上线]
    ↑                                                                           ↓
    └────────────────────────────────(节点恢复)─────────────────────────────────┘
                    </pre>
                    <p><strong>关键时间参数：</strong></p>
                    <ul>
                        <li><strong>down-after-milliseconds：</strong>判定主观下线的超时时间（默认30秒）</li>
                        <li><strong>ping间隔：</strong>发送PING命令的间隔（默认1秒）</li>
                        <li><strong>info-quorum间隔：</strong>发送INFO命令获取复制信息的间隔（默认10秒）</li>
                    </ul>
                    <p><strong>监控数据收集：</strong></p>
                    <ul>
                        <li><strong>INFO命令：</strong>每10秒发送一次，获取Redis运行状态、内存使用、复制偏移量等</li>
                        <li><strong>从节点发现：</strong>通过INFO命令自动发现新加入的从节点</li>
                        <li><strong>状态缓存：</strong>哨兵内存中维护所有节点的状态信息</li>
                    </ul>
                    <p><strong>异常情况处理：</strong></p>
                    <ul>
                        <li><strong>网络抖动：</strong>可能误判为主观下线，但不会触发客观下线（因为其他哨兵正常）</li>
                        <li><strong>哨兵自身故障：</strong>其他哨兵会监测到该哨兵下线，重新投票选举</li>
                        <li><strong>Redis节点重启：</strong>节点恢复后会自动重新连接哨兵，恢复正常状态</li>
                    </ul>
                    <p><strong>业务价值：</strong>通过持续监控，第一时间发现故障，为自动故障转移提供触发条件，确保Redis集群高可用。</p>
                `;
            } else if (type === 'sentinel-failover-process') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>自动故障转移：主节点切换业务流程</h4>
                    <p><strong>业务含义：</strong>当主节点客观下线后，哨兵自动执行的主从切换过程，是从故障发现到服务恢复的核心环节。</p>
                    <p><strong>触发条件：</strong></p>
                    <ul>
                        <li><strong>前置条件：</strong>主节点被标记为客观下线（ODOWN）</li>
                        <li><strong>quorum满足：</strong>至少quorum个哨兵确认主节点下线</li>
                        <li><strong>领头哨兵：</strong>某个哨兵被选为领头哨兵（Leader），负责执行故障转移</li>
                    </ul>
                    <p><strong>完整业务流程：</strong></p>
                    <ol>
                        <li><strong>阶段1：选举领头哨兵（Leader Election）</strong>
                            <ul>
                                <li><strong>发起选举：</strong>确认主节点客观下线的哨兵向其他哨兵发送SENTINEL is-master-down-by-addr命令</li>
                                <li><strong>投票机制：</strong>
                                    <ul>
                                        <li>每个哨兵只能投票一次</li>
                                        <li>投票给第一个请求投票的哨兵</li>
                                        <li>先到先得原则</li>
                                    </ul>
                                </li>
                                <li><strong>当选条件：</strong>获得超过半数哨兵的投票（如3个哨兵需要2票）</li>
                                <li><strong>领头哨兵职责：</strong>唯一的故障转移执行者，负责任务调度和状态管理</li>
                            </ul>
                        </li>
                        <li><strong>阶段2：选择新的主节点（Candidate Selection）</strong>
                            <ul>
                                <li><strong>筛选条件：</strong>
                                    <ol>
                                        <li>必须是健康的从节点（在线、正常复制）</li>
                                        <li>断线时间不超过down-after-milliseconds的10倍</li>
                                        <li>优先级最高（slave-priority配置）</li>
                                        <li>复制偏移量最大（数据最完整）</li>
                                        <li>run_id字典序最小（同优先级和偏移量时的tie-breaker）</li>
                                    </ol>
                                </li>
                                <li><strong>选择命令：</strong>领头哨兵内部算法评估所有从节点，选出最优者</li>
                                <li><strong>配置优先级：</strong>可以人工干预，将高性能从节点的slave-priority设置更高</li>
                            </ul>
                        </li>
                        <li><strong>阶段3：提升从节点为主节点（Promotion）</strong>
                            <ul>
                                <li><strong>发送命令：</strong>领头哨兵向选中的从节点发送SLAVEOF NO ONE命令</li>
                                <li><strong>节点转换：</strong>
                                    <ul>
                                        <li>从节点停止复制主节点</li>
                                        <li>解除只读限制（如果配置了slave-read-only yes）</li>
                                        <li>变身为独立的主节点，可以接受写操作</li>
                                    </ul>
                                </li>
                                <li><strong>确认成功：</strong>领头哨兵通过INFO命令确认节点已成功提升为主节点</li>
                            </ul>
                        </li>
                        <li><strong>阶段4：重新配置其他从节点（Reconfiguration）</strong>
                            <ul>
                                <li><strong>发送命令：</strong>领头哨兵向其他所有从节点发送SLAVEOF <new-master-ip> <new-master-port>命令</li>
                                <li><strong>数据同步：</strong>
                                    <ul>
                                        <li>从节点断开旧主节点（如果还在线）</li>
                                        <li>连接到新主节点</li>
                                        <li>发送SYNC命令，开始全量同步</li>
                                        <li>接收RDB快照文件，加载数据</li>
                                        <li>持续接收新主节点的写命令，保持数据一致</li>
                                    </ul>
                                </li>
                                <li><strong>并行控制：</strong>通过parallel-syncs参数控制同时同步的从节点数量，避免网络拥堵</li>
                            </ul>
                        </li>
                        <li><strong>阶段5：处理旧主节点（Old Master Handling）</strong>
                            <ul>
                                <li><strong>观察期：</strong>如果旧主节点在故障转移期间恢复，哨兵会将其标记为从节点</li>
                                <li><strong>数据同步：</strong>旧主节点向新主节点发起同步，丢弃自己未同步的写操作</li>
                                <li><strong>避免脑裂：</strong>确保旧主节点不会再次成为主节点，防止数据冲突</li>
                            </ul>
                        </li>
                        <li><strong>阶段6：更新配置状态（Configuration Update）</strong>
                            <ul>
                                <li><strong>更新哨兵状态：</strong>所有哨兵更新内存中的主节点地址信息</li>
                                <li><strong>持久化配置：</strong>新主节点信息写入哨兵的配置文件</li>
                                <li><strong>触发通知：</strong>进入"通知"环节，告知客户端主节点已切换</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>故障转移时间线（估算）：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
T+0s     : 主节点客观下线
T+0-5s   : 选举领头哨兵
T+5-10s  : 选择新主节点
T+10-15s : 提升从节点为主节点（SLAVEOF NO ONE）
T+15-30s : 其他从节点开始同步新主节点
T+30-60s : 所有从节点同步完成，故障转移结束
总计：30-60秒
                    </pre>
                    <p><strong>关键配置参数：</strong></p>
                    <ul>
                        <li><strong>failover-timeout：</strong>故障转移超时时间（默认180秒），超时后会重新尝试</li>
                        <li><strong>parallel-syncs：</strong>同时同步的从节点数量，默认1（逐个同步，避免网络压力）</li>
                        <li><strong>slave-priority：</strong>从节点优先级，影响新主节点的选择</li>
                    </ul>
                    <p><strong>失败重试机制：</strong></p>
                    <ul>
                        <li><strong>提升失败：</strong>如果选中的从节点无法提升（如网络故障），领头哨兵会选择下一个候选从节点</li>
                        <li><strong>同步失败：</strong>如果某个从节点同步失败，不影响其他从节点的同步</li>
                        <li><strong>超时重试：</strong>如果failover-timeout时间内未完成，会重新发起故障转移</li>
                    </ul>
                    <p><strong>数据一致性保证：</strong></p>
                    <ul>
                        <li><strong>可能丢失数据：</strong>旧主节点未同步到从节点的数据会丢失</li>
                        <li><strong>最小化丢失：</strong>通过选择复制偏移量最大的从节点，最小化数据丢失</li>
                        <li><strong>强一致性配置：</strong>配置min-slaves-to-write和min-slaves-max-lag，确保写操作至少同步到N个从节点</li>
                    </ul>
                    <p><strong>业务价值：</strong>实现主节点故障的自动切换，无需人工干预，在30-60秒内恢复服务，最大程度保证业务连续性。</p>
                `;
            } else if (type === 'sentinel-notification-process') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>通知：主节点切换信息发布业务流程</h4>
                    <p><strong>业务含义：</strong>故障转移完成后，哨兵将新的主节点地址信息告知后端服务（客户端），使客户端能够切换到新的主节点继续访问。</p>
                    <p><strong>触发条件：</strong></p>
                    <ul>
                        <li><strong>前置条件：</strong>自动故障转移完成，新主节点已上线</li>
                        <li><strong>从节点同步：</strong>所有从节点已开始或完成向新主节点的同步</li>
                        <li><strong>配置更新：</strong>哨兵已更新内存中的主节点地址信息</li>
                    </ul>
                    <p><strong>通知机制详解：</strong></p>
                    <ol>
                        <li><strong>机制1：发布/订阅（Pub/Sub）- 主动推送</strong>
                            <ul>
                                <li><strong>哨兵作为发布者：</strong>
                                    <ul>
                                        <li>哨兵通过Redis的发布/订阅机制发布事件消息</li>
                                        <li>使用专门的频道：__sentinel__:hello（哨兵间通信）</li>
                                        <li>使用事件频道：+switch-master（主节点切换）、+failover-end（故障转移结束）</li>
                                        <li>消息格式：JSON字符串，包含master-name、old-ip、new-ip、port等信息</li>
                                    </ul>
                                </li>
                                <li><strong>客户端作为订阅者：</strong>
                                    <ul>
                                        <li>后端服务启动时订阅哨兵的事件频道</li>
                                        <li>使用SUBSCRIBE命令订阅：SUBSCRIBE +switch-master</li>
                                        <li>建立长连接，实时接收哨兵发布的事件消息</li>
                                        <li>收到消息后解析JSON，提取新主节点的IP和端口</li>
                                    </ul>
                                </li>
                                <li><strong>实时性：</strong>毫秒级推送，客户端第一时间感知主节点变化</li>
                                <li><strong>可靠性：</strong>如果客户端断线，重连后可以重新订阅，但可能错过期间的消息</li>
                            </ul>
                        </li>
                        <li><strong>机制2：客户端主动查询 - 轮询拉取</strong>
                            <ul>
                                <li><strong>查询命令：</strong>客户端定期向哨兵发送SENTINEL get-master-addr-by-name <master-name>命令</li>
                                <li><strong>返回内容：</strong>当前主节点的IP和端口（如：192.168.2.10 6379）</li>
                                <li><strong>轮询间隔：</strong>客户端自己决定，通常为几秒到几十秒</li>
                                <li><strong>适用场景：</strong>
                                    <ul>
                                        <li>不支持订阅机制的客户端</li>
                                        <li>需要精确控制查询时机的场景</li>
                                        <li>作为订阅机制的补充和备份</li>
                                    </ul>
                                </li>
                                <li><strong>优点：</strong>简单可靠，客户端主动控制</li>
                                <li><strong>缺点：</strong>实时性差，可能延迟几秒到几十秒</li>
                            </ul>
                        </li>
                        <li><strong>机制3：哨兵配置文件 - 被动读取</strong>
                            <ul>
                                <li><strong>配置文件：</strong>哨兵会将当前主节点信息写入sentinel.conf配置文件</li>
                                <li><strong>持久化：</strong>即使哨兵重启，也能恢复主节点信息</li>
                                <li><strong>客户端读取：</strong>客户端可以读取配置文件获取主节点地址（较少使用）</li>
                                <li><strong>优点：</strong>持久化存储，不会丢失</li>
                                <li><strong>缺点：</strong>需要文件I/O，实时性最差</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>通知流程时序图：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
哨兵端：
T+0s   : 故障转移完成
T+0.1s : 发布事件到 +switch-master 频道
        消息内容：{"event":"+switch-master","master":"mymaster","from":"192.168.2.10","to":"192.168.2.11"}

客户端（订阅模式）：
T+0.2s : 收到订阅消息
        解析JSON，提取新主节点IP：192.168.2.11
T+0.3s : 关闭旧连接（连接192.168.2.10）
T+0.4s : 建立新连接（连接192.168.2.11）
T+0.5s : 发送PING命令测试新连接
T+0.6s : 继续业务操作

客户端（轮询模式）：
T+5s   : 发送SENTINEL get-master-addr-by-name mymaster
        返回：192.168.2.11 6379
T+5.1s : 更新连接，切换到新主节点
                    </pre>
                    <p><strong>客户端实现示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 伪代码：订阅模式
client.subscribe("+switch-master")
client.on("message", (channel, message) => {
    if (channel === "+switch-master") {
        const event = JSON.parse(message)
        if (event.master === "mymaster") {
            console.log("主节点切换: " + event.from + " -> " + event.to)
            // 更新连接
            redis_client.disconnect()
            redis_client.connect(event.to, 6379)
        }
    }
})

// 伪代码：轮询模式
setInterval(() => {
    const new_master = sentinel.get_master_addr_by_name("mymaster")
    if (new_master !== current_master) {
        console.log("检测到主节点变化: " + current_master + " -> " + new_master)
        current_master = new_master
        redis_client.reconnect(new_master)
    }
}, 5000)  // 每5秒查询一次
                    </pre>
                    <p><strong>通知内容（事件类型）：</strong></p>
                    <ul>
                        <li><strong>+switch-master：</strong>主节点切换事件（最重要）</li>
                        <li><strong>+failover-end：</strong>故障转移结束事件</li>
                        <li><strong>+redirect-to-master：</strong>从节点重定向到主节点</li>
                        <li><strong>-slave：</strong>从节点下线事件</li>
                        <li><strong>+slave：</strong>从节点上线事件</li>
                        <li><strong>+sdown：</strong>节点主观下线</li>
                        <li><strong>+odown：</strong>节点客观下线</li>
                    </ul>
                    <p><strong>同步 vs 异步通知：</strong></p>
                    <ul>
                        <li><strong>异步推送（订阅模式）：</strong>
                            <ul>
                                <li>哨兵发布消息后立即返回，不等待客户端确认</li>
                                <li>客户端异步接收消息，非阻塞</li>
                                <li>实时性高，但可能丢失消息（客户端断线期间）</li>
                            </ul>
                        </li>
                        <li><strong>同步拉取（轮询模式）：</strong>
                            <ul>
                                <li>客户端主动发起查询，等待哨兵响应</li>
                                <li>实时性差，但不会丢失信息</li>
                                <li>适合对实时性要求不高的场景</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>客户端连接切换最佳实践：</strong></p>
                    <ul>
                        <li><strong>同时使用两种机制：</strong>订阅模式为主，轮询模式为备份</li>
                        <li><strong>优雅重连：</strong>检测到连接断开后，延迟几秒再重连，避免频繁重连</li>
                        <li><strong>连接池管理：</strong>更新连接池中的所有连接，确保后续请求使用新主节点</li>
                        <li><strong>失败重试：</strong>切换到新主节点时，如果连接失败，记录日志并重试</li>
                        <li><strong>监控告警：</strong>主节点切换时发送告警通知，让运维人员感知</li>
                    </ul>
                    <p><strong>业务价值：</strong>通过主动推送和被动查询两种机制，确保客户端能够及时感知主节点变化并切换连接，最大程度减少业务中断时间，实现透明化的高可用切换。</p>
                `;
            } else if (type === 'connection-type') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>连接类型判断</h4>
                    <p><strong>作用：</strong>根据业务需求选择合适的通信协议。</p>
                    <p><strong>连接类型说明：</strong></p>
                    <ul>
                        <li><strong>HTTP连接：</strong>
                            <ul>
                                <li>适用于标准的请求-响应模式</li>
                                <li>无状态协议，每次请求独立</li>
                                <li>适合数据查询、表单提交等操作</li>
                                <li>支持缓存，易于扩展</li>
                            </ul>
                        </li>
                        <li><strong>WebSocket连接：</strong>
                            <ul>
                                <li>适用于实时双向通信场景</li>
                                <li>持久连接，低延迟</li>
                                <li>适合聊天、推送、实时通知等</li>
                                <li>服务器可主动推送数据给客户端</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>选择建议：</strong></p>
                    <ul>
                        <li>需要实时性：选择WebSocket</li>
                        <li>简单请求-响应：选择HTTP</li>
                        <li>需要服务器推送：选择WebSocket</li>
                        <li>需要广泛兼容性：选择HTTP</li>
                    </ul>
                    <p><strong>优势：</strong>灵活适应不同业务场景，优化用户体验和系统性能。</p>
                `;
            } else if (type === 'data-type') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>数据类型判断（热数据/冷数据）</h4>
                    <p><strong>作用：</strong>根据数据访问频率，将数据分类存储到不同的服务器。</p>
                    <p><strong>数据类型说明：</strong></p>
                    <ul>
                        <li><strong>热数据：</strong>
                            <ul>
                                <li>频繁访问的数据</li>
                                <li>最近创建或修改的数据</li>
                                <li>用户活跃数据</li>
                                <li>存储在独立的高性能服务器上</li>
                            </ul>
                        </li>
                        <li><strong>冷数据：</strong>
                            <li>不常访问的历史数据</li>
                            <li>归档数据</li>
                            <li>超过一定时间的数据（如一个月前）</li>
                            <li>存储在集合冷数据服务器上</li>
                        </ul>
                    </ul>
                    <p><strong>处理策略：</strong></p>
                    <ul>
                        <li><strong>热数据：</strong>快速响应，优先处理，使用高性能存储</li>
                        <li><strong>冷数据：</strong>定期备份到冷数据库，支持查询但性能较低</li>
                    </ul>
                    <p><strong>数据迁移：</strong></p>
                    <ul>
                        <li>定期（如每月）将热数据迁移到冷数据库</li>
                        <li>热数据服务器保留最近一段时间的数据</li>
                        <li>冷数据可以压缩存储，降低存储成本</li>
                    </ul>
                    <p><strong>优势：</strong>优化存储资源使用，提高热数据访问速度，降低存储成本。</p>
                `;
            }
            tooltip.innerHTML = content;

            document.body.appendChild(tooltip);

            // 定位到旁边
            const rect = target.getBoundingClientRect();
            const tooltipWidth = 300;
            const tooltipHeight = 200; // 估算
            let left, top = rect.top + window.scrollY;

            if (type === 'WebSocket') {
                left = rect.left + window.scrollX - tooltipWidth - 10;
            } else { // HTTP
                left = rect.right + window.scrollX + 10;
            }

            // 确保不超出视窗
            if (left < 0) left = 10;
            if (left + tooltipWidth > window.innerWidth) left = window.innerWidth - tooltipWidth - 10;
            if (top + tooltipHeight > window.innerHeight + window.scrollY) top = rect.top + window.scrollY - tooltipHeight - 10;

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';

            currentTooltip = tooltip;
            currentTarget = target;
        }

        function closeTooltip() {
            if (currentTooltip) {
                document.body.removeChild(currentTooltip);
                currentTooltip = null;
                currentTarget = null;
            }
        }
    </script>
</body>
</html>