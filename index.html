<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>前端App与后端交互业务流程（详细版）</title>
    <!-- 使用多个CDN源，确保在国内可以加载 -->
    <script src="https://cdn.bootcdn.net/ajax/libs/mermaid/10.6.1/mermaid.min.js"
            onerror="this.onerror=null; this.src='https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js'"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        h1, h2, h3 {
            color: #007bff;
        }
        .section {
            margin-bottom: 20px;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .step {
            cursor: pointer;
            padding: 10px;
            margin: 5px 0;
            background-color: #e9ecef;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        .step:hover {
            background-color: #d6d8db;
        }
        .details {
            display: none;
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-left: 4px solid #007bff;
        }
        .tooltip {
            position: absolute;
            background-color: #f8f9fa;
            border: 1px solid #007bff;
            border-radius: 5px;
            padding: 10px;
            max-width: 300px;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .tooltip .close-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            cursor: pointer;
            font-size: 16px;
            color: #007bff;
        }
        button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .module {
            background-color: #fff3cd;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>前端App与后端交互业务流程（详细版）</h1>
    <p>基于您的描述，重新梳理了详细业务流程，强调网关分发、数据校验、缓存策略、分库分表、冷热数据分离、备份等。整体设计高度解耦、高度内聚，模块化架构。</p>

    <div id="flowchart" class="section">
        <h2>整体架构与流程图</h2>
        <div class="mermaid">
            graph TD
                A[前端App/Web] --> CDN[CDN加速<br/>静态资源]
                CDN --> C
                A --> B{连接类型}
                B -->|HTTP| C[Nginx网关<br/>健康检查]
                B -->|WebSocket| C
                C -->|限流| C1[限流控制<br/>令牌桶/漏桶]
                C1 -->|通过| C2[熔断器<br/>服务熔断]
                C2 -->|健康主服务| D1[核心主后端服务]
                C2 -->|健康备用服务| D2[核心备用后端服务]
                C2 -->|功能拆分主| D3[拆分功能主后端服务]
                C2 -->|功能拆分备| D4[拆分功能备用后端服务]
                C2 -.降级.-> CE[降级处理<br/>默认值/静态页面]
                D1 --> DA[本地缓存<br/>Guava/Caffeine]
                D2 --> DA
                D3 --> DA
                D4 --> DA
                DA --> F[用户中台模块: 认证校验]
                D1 --> F
                D2 --> F
                D3 --> F
                D4 --> F
                F --> G[业务模块: 操作处理]
                G --> GA{需要分布式锁}
                GA -->|是| GB[Redis分布式锁<br/>SETNX/Redlock]
                GB --> GBB{抢锁成功?}
                GBB -->|是| GBC[执行业务逻辑]
                GBB -->|否| GBW[等待重试]
                GBW --> GB
                GBC --> DBOp{需要数据库操作}
                G --> DBOp
                DBOp -->|是| H{读/写操作}
                DBOp -->|否| X[返回Nginx网关]
                X --> C
                H -->|读| I[Redis哨兵集群<br/>获取主节点地址]
                DA -.多级缓存.-> I
                I --> J[Redis主节点查询]
                J -->|命中| K[返回数据]
                K --> G
                J -->|未命中| L[数据库查询]
                L --> M[更新Redis主节点]
                M --> K
                H -->|写| N[Redis哨兵<br/>获取主节点地址]
                N --> O[Redis主节点检查]
                O -->|有数据| P[更新Redis主节点 & 事务更新DB]
                O -->|无数据| Q[查询DB & 事务更新DB & 更新Redis主节点]
                P --> R[定时刷新Redis-DB]
                Q --> R
                R --> R2[Redis-DB定期同步<br/>数据一致性保障]
                R --> S[分库分表处理]
                R2 --> S
                S --> T{数据类型}
                T -->|热数据| U[独立热数据服务器]
                T -->|冷数据| V[集合冷数据服务器]
                V --> W[冷数据备份: 一个月前数据到备份DB]
                W --> Y[可查询冷DB]
                U --> Z[事务保护]
                V --> Z
                P --> MQ[消息队列<br/>异步解耦<br/>事件总线]
                Q --> MQ
                MQ -.事件分发.-> MQ1[日志服务]
                MQ -.事件分发.-> MQ2[统计服务]
                MQ -.事件分发.-> MQ3[通知服务]
                MQ -.事件分发.-> LOGIN[登录认证服务]
                MQ -.事件分发.-> IM[即时通讯服务]
                MQ -.事件分发.-> VIDEO[视频服务]
                MQ -.事件分发.-> ORDER[商品订单服务]
                MQ -.事件分发.-> CS[客服服务]
                MQ -.事件分发.-> MERCHANT[商户管理服务<br/>详细展开↓]

                LOGIN --> LOGIN_DB[(登录服务<br/>Redis+DB)]
                IM --> IM_DB[(即时通讯<br/>Redis+DB)]
                VIDEO --> VIDEO_DB[(视频服务<br/>Redis+DB)]
                ORDER --> ORDER_DB[(订单服务<br/>Redis+DB)]
                CS --> CS_DB[(客服服务<br/>Redis+DB)]

                MERCHANT --> M1[商户服务<br/>消费MQ消息]
                M1 --> M2{需要分布式锁?}
                M2 -->|是| M3[商户Redis分布式锁<br/>SET lock:merchant:*]
                M2 -->|否| M4[商户Redis哨兵集群<br/>获取主节点地址]
                M3 --> M3_OK{抢锁成功?}
                M3_OK -->|是| M5[商户Redis主节点查询<br/>GET merchant:balance]
                M3_OK -->|否| M3_WAIT[等待重试]
                M3_WAIT --> M3
                M5 --> M6{查询结果}
                M6 -->|命中| M7[返回余额数据]
                M6 -->|未命中| M8[(商户DB查询<br/>SELECT balance)]
                M8 --> M9[更新商户Redis主节点<br/>SET merchant:balance]
                M9 --> M7
                M4 --> M10[商户Redis主节点<br/>读写操作]
                M10 --> M11{读写操作}
                M11 -->|读| M12[商户Redis主节点查询]
                M11 -->|写| M13[商户Redis主节点检查]
                M12 --> M14[返回数据]
                M13 --> M15{有数据?}
                M15 -->|有| M16[(商户DB事务更新<br/>UPDATE + INSERT)]
                M15 -->|无| M17[(商户DB查询<br/>SELECT)]
                M16 --> M18[更新商户Redis主节点]
                M17 --> M18
                M18 --> M19[商户Redis-DB<br/>定期同步]

                M4 -.商户哨兵监控.-> MAA[商户Redis哨兵监控<br/>主从节点健康]
                MAA -.商户故障转移.-> MAB[商户Redis从节点<br/>提升主节点]
                MAB -.通知商户服务.-> M4
                M16 -.商户数据分片.-> MS[商户分库分表<br/>按商户ID分片]
                MS -.商户冷热分离.-> MT{商户数据类型}
                MT -->|热数据| MU[商户热数据DB<br/>最近3个月数据]
                MT -->|冷数据| MV[商户冷数据DB<br/>3个月前数据]

                I -.监控.-> AA[主流程Redis哨兵监控<br/>主从节点健康]
                AA -.自动故障转移.-> AB[主流程Redis从节点提升主节点]
                AB -.通知.-> I
                N -.监控.-> AA
                C -.健康检查.-> AC[后端服务健康监控]
                AC -.主服务故障.-> AD[Nginx自动切换备用服务]
                A -.全链路追踪.-> MON[全链路监控<br/>SkyWalking/Zipkin]
                C -.日志采集.-> MON
                DA -.缓存监控.-> MON
                I -.Redis监控.-> MON
                S -.数据库监控.-> MON
                MQ -.异步监控.-> MON
                MON -.告警通知.-> ALERT[告警中心<br/>Prometheus/Grafana]
        </div>
    </div>

    <button onclick="toggleAllDetails()">展开/折叠所有详情</button>

    <div class="section">
        <h2>1. 前端发送环节</h2>
        <div class="step" onclick="toggleDetails('frontend')">点击查看详情</div>
        <div id="frontend" class="details">
            <h3>前端连接与请求</h3>
            <p><strong>连接类型区分：</strong></p>
            <ul>
                <li><strong>普通网络连接（HTTP）：</strong>用于标准请求/响应，如GET/POST，无状态协议</li>
                <li><strong>WebSocket连接：</strong>用于实时双向通信，如聊天、推送，持久连接低延迟</li>
            </ul>
            <p><strong>CDN加速：</strong></p>
            <ul>
                <li>静态资源（图片、CSS、JS）通过CDN就近获取，响应时间从500ms降低到20-50ms</li>
                <li>减轻源站压力，源站带宽降低80-90%</li>
                <li>动态请求（API接口）直接访问后端，不经过CDN</li>
            </ul>
            <p><strong>Nginx网关分发：</strong></p>
            <ul>
                <li><strong>负载均衡：</strong>将请求分发到多个后端服务，提高系统吞吐量</li>
                <li><strong>限流控制：</strong>通过令牌桶/漏桶算法，拒绝超出系统处理能力的请求</li>
                <li><strong>熔断保护：</strong>检测到后端服务故障时，快速失败，避免级联崩溃</li>
                <li><strong>降级处理：</strong>系统负载过高时，关闭非核心功能，保障核心业务</li>
            </ul>
            <p><strong>请求基础数据准备：</strong></p>
            <ul>
                <li><strong>Token（令牌）：</strong>根据用户ID生成的唯一标识，放在HTTP Header中（Authorization: Bearer &lt;token&gt;）</li>
                <li><strong>用户ID：</strong>用于关联和识别用户</li>
                <li><strong>时间戳：</strong>防止重放攻击</li>
                <li><strong>业务数据：</strong>表单数据、查询参数、文件数据等</li>
            </ul>
            <p><strong>前端优化策略：</strong></p>
            <ul>
                <li><strong>本地缓存：</strong>缓存不常变化的数据（如用户信息、配置项），减少后端请求</li>
                <li><strong>请求合并：</strong>多个小请求合并为一个大请求，减少网络开销</li>
                <li><strong>懒加载：</strong>图片等资源按需加载，提升首屏加载速度</li>
            </ul>
        </div>
    </div>

    <div class="section">
        <h2>2. 后端接收与校验环节</h2>
        <div class="step" onclick="toggleDetails('validation')">点击查看详情</div>
        <div id="validation" class="details">
            <h3>后端服务接收与用户中台认证</h3>
            <p><strong>Nginx网关处理：</strong></p>
            <ul>
                <li><strong>负载均衡：</strong>根据健康检查结果，将请求分发到健康的后端服务（主服务优先）</li>
                <li><strong>健康检查：</strong>主动检查（定期发送心跳请求）和被动检查（根据请求响应判断）</li>
                <li><strong>自动故障转移：</strong>主服务故障时，自动切换到备用服务，确保高可用</li>
            </ul>
            <p><strong>本地缓存（L1缓存）：</strong></p>
            <ul>
                <li><strong>多级缓存架构：</strong>L1本地缓存（&lt;1ms）→ L2 Redis缓存（1-5ms）→ L3数据库（10-100ms）</li>
                <li><strong>适合缓存数据：</strong>热点数据（首页配置、热门商品）、静态配置（字典表、枚举值）、计算结果</li>
                <li><strong>性能优势：</strong>降低Redis压力90%+，提升系统吞吐量</li>
                <li><strong>一致性保证：</strong>定期刷新（5分钟TTL）、主动失效（MQ通知清除所有实例缓存）</li>
            </ul>
            <p><strong>用户中台模块（认证校验）：</strong></p>
            <ul>
                <li><strong>Token验证：</strong>解析JWT Token或OAuth令牌，验证签名和有效期</li>
                <li><strong>用户身份确认：</strong>从Token中提取用户ID、权限信息、角色信息</li>
                <li><strong>ID匹配校验：</strong>验证请求中的用户ID与Token中的用户ID是否一致，防止越权访问</li>
                <li><strong>权限校验：</strong>根据用户角色和权限，判断是否有权限访问该接口</li>
                <li><strong>请求日志：</strong>记录用户请求日志（用户ID、接口、时间、IP），用于审计和问题追踪</li>
            </ul>
            <p><strong>数据校验：</strong></p>
            <ul>
                <li><strong>参数校验：</strong>校验请求参数的合法性（如：非空、格式、长度、取值范围）</li>
                <li><strong>业务规则校验：</strong>校验业务逻辑（如：库存是否充足、账户余额是否足够）</li>
                <li><strong>防刷校验：</strong>检测异常行为（如：短时间内大量请求），防止恶意刷接口</li>
            </ul>
            <p><strong>用户上下文确定：</strong></p>
            <ul>
                <li>通过校验后，建立用户上下文（User Context），包含用户ID、权限、角色等信息</li>
                <li>将用户上下文传递给后续业务模块，用于业务逻辑处理和权限控制</li>
                <li>路由到相应的业务模块（如：订单模块、支付模块、查询模块）</li>
            </ul>
        </div>
    </div>

    <div class="section">
        <h2>3. 业务处理环节（读写操作）</h2>
        <div class="step" onclick="toggleDetails('business')">点击查看详情</div>
        <div id="business" class="details">
            <h3>业务模块操作处理</h3>
            <p><strong>是否需要分布式锁判断：</strong></p>
            <ul>
                <li><strong>需要分布式锁的场景：</strong>库存扣减（秒杀、抢购）、金额操作（账户余额、积分）、资源分配（订单号、优惠券）、状态机变更（订单状态流转）、分布式定时任务</li>
                <li><strong>不需要分布式锁的场景：</strong>纯查询操作、单机数据（JVM锁即可）、数据库唯一索引保证、乐观锁（版本号控制）</li>
            </ul>
            <p><strong>分布式锁处理流程：</strong></p>
            <ol>
                <li><strong>尝试获取锁：</strong>通过Redis SETNX命令尝试获取分布式锁（设置唯一标识和过期时间）</li>
                <li><strong>抢锁成功：</strong>执行业务逻辑（数据校验 → 数据操作 → 业务计算 → 后续处理），执行完毕后立即释放锁</li>
                <li><strong>抢锁失败：</strong>等待重试（固定间隔/指数退避），或快速失败返回"系统繁忙"</li>
            </ol>
            <p><strong>是否需要数据库操作判断：</strong></p>
            <ul>
                <li><strong>需要数据库：</strong>涉及数据查询、数据写入、事务处理</li>
                <li><strong>不需要数据库：</strong>纯计算、缓存查询、静态数据返回、外部API调用</li>
            </ul>
            <p><strong>读操作流程：</strong></p>
            <ol>
                <li><strong>Redis哨兵获取主节点地址：</strong>连接Redis哨兵集群，获取当前Redis主节点的IP和端口</li>
                <li><strong>查询Redis主节点：</strong>
                    <ul>
                        <li><strong>命中：</strong>直接返回数据（响应时间1-5ms）</li>
                        <li><strong>未命中：</strong>查询数据库，将结果写入Redis（设置TTL），返回数据</li>
                    </ul>
                </li>
                <li><strong>缓存更新：</strong>查询数据库后立即更新Redis（Cache Aside模式），保证下次命中</li>
            </ol>
            <p><strong>写操作流程：</strong></p>
            <ol>
                <li><strong>Redis哨兵获取主节点地址：</strong>获取Redis主节点连接</li>
                <li><strong>Redis主节点检查（有数据/无数据）：</strong></li>
            </ol>
            <ul>
                <li><strong>有数据（EXISTS=1）：</strong>更新场景
                    <ol>
                        <li>获取Redis中的旧数据</li>
                        <li>合并新数据和旧数据</li>
                        <li>更新Redis主节点（异步同步到从节点）</li>
                        <li>事务更新数据库（保证ACID）</li>
                    </ol>
                </li>
                <li><strong>无数据（EXISTS=0）：</strong>插入/缓存过期场景
                    <ol>
                        <li>查询数据库是否存在该数据</li>
                        <li><strong>DB有数据：</strong>执行UPDATE操作，更新DB和Redis</li>
                        <li><strong>DB无数据：</strong>执行INSERT操作，插入DB和Redis</li>
                        <li>通过事务保证DB和Redis的一致性</li>
                    </ol>
                </li>
            </ul>
            <p><strong>Redis-DB定期同步：</strong></p>
            <ul>
                <li><strong>同步原因：</strong>缓存是易失性存储（Redis重启数据丢失）、长时间运行后数据不一致</li>
                <li><strong>同步方式：</strong>全量同步（凌晨低峰期）、增量同步（基于写操作日志）、基于时间戳同步</li>
                <li><strong>同步策略：</strong>实时同步（一致性最好）、准实时同步（MQ异步）、定期同步（性能最好）、混合策略</li>
            </ul>
            <p><strong>异步解耦（消息队列）：</strong></p>
            <ul>
                <li><strong>核心价值：</strong>异步解耦（发送者和接收者无需直接依赖）、提升性能（同步变异步）、削峰填谷（高峰期消息堆积）、消息持久化保证可靠性</li>
                <li><strong>典型应用：</strong>异步处理（注册后发送邮件）、系统解耦（订单系统→库存/物流/通知）、流量削峰（秒杀请求写入MQ）、事件驱动（数据变更触发缓存刷新）</li>
                <li><strong>消息可靠性：</strong>消息持久化、消费确认（ACK）、重试机制（指数退避）、死信队列</li>
            </ul>
        </div>
    </div>

    <div class="section">
        <h2>4. 数据库架构与优化</h2>
        <div class="step" onclick="toggleDetails('database')">点击查看详情</div>
        <div id="database" class="details">
            <h3>数据库（Database）介绍</h3>
            <p><strong>什么是数据库：</strong>数据库是持久化存储系统，用于长期保存和管理结构化数据，提供完整的事务支持（ACID），是系统数据的最终存储位置。</p>
            <p><strong>核心作用：</strong></p>
            <ul>
                <li><strong>数据持久化：</strong>数据永久存储，不会因断电或重启而丢失</li>
                <li><strong>事务保证：</strong>支持ACID特性（原子性、一致性、隔离性、持久性），确保数据操作的可靠性</li>
                <li><strong>复杂查询：</strong>支持SQL查询语言，可以进行复杂的数据检索、聚合、统计</li>
                <li><strong>关系维护：</strong>通过外键、索引等机制维护数据之间的关系和完整性</li>
            </ul>
            <p><strong>数据库特点：</strong></p>
            <ul>
                <li><strong>优点：</strong>数据安全可靠、支持复杂查询、事务保证、数据一致性高、支持数据分析和报表</li>
                <li><strong>缺点：</strong>性能相对较慢（响应时间10-100ms）、并发能力有限、扩展性较差（垂直扩展为主）</li>
            </ul>
            <p><strong>常见数据库：</strong>MySQL、PostgreSQL、Oracle、SQL Server等关系型数据库</p>

            <h4>数据库 vs Redis对比</h4>
            <table border="1" cellpadding="10" style="border-collapse: collapse; width: 100%; margin-top: 10px;">
                <tr style="background-color: #f0f0f0;">
                    <th><strong>对比维度</strong></th>
                    <th><strong>数据库（DB）</strong></th>
                    <th><strong>Redis缓存</strong></th>
                </tr>
                <tr>
                    <td><strong>存储介质</strong></td>
                    <td>磁盘（SSD/HDD），数据持久化</td>
                    <td>内存（RAM），数据易失</td>
                </tr>
                <tr>
                    <td><strong>响应速度</strong></td>
                    <td>慢（10-100ms），磁盘IO是瓶颈</td>
                    <td>快（1-5ms），内存访问</td>
                </tr>
                <tr>
                    <td><strong>数据持久性</strong></td>
                    <td>永久存储，不会丢失</td>
                    <td>易失性存储，重启数据丢失（可配置RDB/AOF持久化）</td>
                </tr>
                <tr>
                    <td><strong>事务支持</strong></td>
                    <td>完整的事务支持（ACID）</td>
                    <td>有限的事务支持（MULTI/EXEC）</td>
                </tr>
                <tr>
                    <td><strong>查询能力</strong></td>
                    <td>强大的SQL查询，支持复杂关联、聚合、统计</td>
                    <td>简单的Key-Value查询，不支持复杂查询</td>
                </tr>
                <tr>
                    <td><strong>并发能力</strong></td>
                    <td>有限（受限于磁盘IO和连接数）</td>
                    <td>极高（QPS可达10万+）</td>
                </tr>
                <tr>
                    <td><strong>扩展性</strong></td>
                    <td>垂直扩展（升级硬件）、读写分离、分库分表</td>
                    <td>水平扩展（Redis集群、分片）</td>
                </tr>
                <tr>
                    <td><strong>适用场景</strong></td>
                    <td>数据持久化、复杂查询、事务处理、数据分析</td>
                    <td>缓存、分布式锁、限流、消息队列、实时排行榜</td>
                </tr>
                <tr>
                    <td><strong>成本</strong></td>
                    <td>存储成本高，但性能稳定</td>
                    <td>内存成本高，但性能极快</td>
                </tr>
            </table>

            <h4>数据库与Redis的协作关系</h4>
            <p><strong>为什么需要Redis：</strong>数据库性能是系统的瓶颈（磁盘IO慢），无法满足高并发需求（QPS通常几千到一万），因此引入Redis作为缓存层，将热点数据存储在内存中，大幅提升系统性能。</p>
            <p><strong>多级缓存架构：</strong></p>
            <ul>
                <li><strong>L1本地缓存：</strong>应用内存缓存（Guava/Caffeine），响应时间&lt;1ms，降低Redis压力</li>
                <li><strong>L2 Redis缓存：</strong>分布式缓存，响应时间1-5ms，提升系统吞吐量</li>
                <li><strong>L3数据库：</strong>最终数据存储，响应时间10-100ms，保证数据持久化和一致性</li>
            </ul>
            <p><strong>典型查询流程：</strong>查询L1本地缓存 → 未命中则查询L2 Redis → 未命中则查询L3数据库 → 查询后回填L2和L1</p>

            <h3>数据库架构优化</h3>
            <p><strong>分库分表：</strong>根据业务拆分数据库和表，降低单库压力，提升并发能力</p>
            <ul>
                <li><strong>垂直分库：</strong>按业务拆分（用户库、订单库、商品库）</li>
                <li><strong>水平分表：</strong>按数据量拆分（订单表按月拆分、用户表按ID取模分表）</li>
            </ul>
            <p><strong>热数据分离：</strong></p>
            <ul>
                <li><strong>热数据服务器：</strong>存储频繁查询的数据（最近一个月的数据），独立服务器，性能优化</li>
                <li><strong>冷数据服务器：</strong>存储不常访问的历史数据（一个月前的数据），集合存储，成本优化</li>
                <li><strong>冷数据备份：</strong>定期将热数据迁移到冷数据库，冷数据支持查询但性能较低</li>
            </ul>
            <p><strong>事务保护：</strong>确保读写一致性，避免并发问题（脏读、幻读、不可重复读）</p>
            <ul>
                <li><strong>隔离级别：</strong>读未提交、读已提交、可重复读（MySQL默认）、串行化</li>
                <li><strong>并发控制：</strong>乐观锁（版本号）、悲观锁（SELECT FOR UPDATE）</li>
            </ul>
        </div>
    </div>

    <div class="section">
        <h2>5. Redis哨兵机制（Redis Sentinel）</h2>
        <div class="step" onclick="toggleDetails('sentinel')">点击查看详情</div>
        <div id="sentinel" class="details">
            <h3>Redis介绍</h3>
            <p><strong>什么是Redis：</strong>Redis（Remote Dictionary Server）是一个开源的内存数据结构存储系统，可以用作数据库、缓存和消息中间件。它支持多种数据结构（String、Hash、List、Set、Sorted Set等），并提供丰富的操作命令。</p>
            <p><strong>核心作用：</strong></p>
            <ul>
                <li><strong>缓存层：</strong>将热点数据存储在内存中，大幅提升系统性能（响应时间从10-100ms降低到1-5ms）</li>
                <li><strong>分布式锁：</strong>通过SETNX命令实现跨进程、跨服务器的互斥锁，保证并发安全</li>
                <li><strong>限流：</strong>通过计数器、令牌桶等算法实现接口限流</li>
                <li><strong>消息队列：</strong>通过List、Pub/Sub实现简单的消息队列</li>
                <li><strong>排行榜：</strong>通过Sorted Set实现实时排行榜（如游戏排名、热门商品）</li>
                <li><strong>计数器：</strong>通过INCR命令实现原子性计数（如：点赞数、浏览数）</li>
            </ul>
            <p><strong>Redis特点：</strong></p>
            <ul>
                <li><strong>优点：</strong>性能极高（QPS可达10万+）、支持丰富数据结构、支持数据持久化（RDB/AOF）、支持主从复制、支持集群分片</li>
                <li><strong>缺点：</strong>内存成本高、数据易失（重启丢失，除非配置持久化）、查询能力有限（不支持复杂SQL）、事务支持有限</li>
            </ul>
            <p><strong>Redis vs 数据库对比总结：</strong>Redis是内存型数据库，性能极高但数据易失，适合作为缓存层；数据库（MySQL等）是磁盘型数据库，性能较慢但数据持久，适合作为最终存储。两者结合使用（多级缓存架构）才能同时满足高性能和数据可靠性的需求。</p>

            <h3>Redis哨兵机制（Redis Sentinel）</h3>
            <p><strong>哨兵核心概念：</strong>Redis哨兵是Redis高可用性的解决方案，用于监控、通知和自动故障转移，解决Redis主节点故障时需要人工切换的问题。</p>
            <p><strong>为什么需要哨兵：</strong>Redis主从架构中，主节点故障后需要手动将从节点提升为主节点，并更新应用配置。哨兵实现了这一过程的自动化，最大程度减少服务中断时间（通常30-60秒完成故障转移）。</p>
            <p><strong>主要功能：</strong></p>
            <ul>
                <li><strong>监控（Monitoring）：</strong>持续监控Redis主节点和从节点是否正常运行（定期PING-PONG心跳检测）</li>
                <li><strong>通知（Notification）：</strong>当被监控的Redis服务器出现问题时，通过API通知系统管理员或其他应用</li>
                <li><strong>自动故障转移（Automatic Failover）：</strong>主节点故障时，自动将从节点提升为新的主节点，整个过程30-60秒</li>
                <li><strong>配置提供者（Configuration Provider）：</strong>客户端连接哨兵获取当前主节点的地址，无需硬编码</li>
            </ul>
            <p><strong>哨兵工作流程：</strong></p>
            <ol>
                <li><strong>健康检查：</strong>哨兵定期向所有Redis节点发送PING命令，检查节点状态（默认每秒1次）</li>
                <li><strong>主观下线（SDOWN）：</strong>单个哨兵认为主节点下线（主观判断，如：连续3次PING超时）</li>
                <li><strong>客观下线（ODOWN）：</strong>多个哨兵通过协商确认主节点下线（客观判断，需要quorum个哨兵同意）</li>
                <li><strong>故障转移：</strong>哨兵集群选举领头哨兵，由领头哨兵执行6个阶段的故障转移
                    <ul>
                        <li>阶段1：选择合适的从节点作为新主节点（优先级、复制偏移量、运行ID）</li>
                        <li>阶段2：将从节点提升为主节点（SLAVEOF NO ONE）</li>
                        <li>阶段3：将其他从节点重新配置为复制新的主节点</li>
                        <li>阶段4：将旧主节点（恢复后）配置为从节点，复制新主节点</li>
                        <li>阶段5：更新哨兵配置，记录新的主节点信息</li>
                        <li>阶段6：通知客户端主节点已切换（通过Pub/Sub发布+switch-master消息）</li>
                    </ul>
                </li>
                <li><strong>通知应用：</strong>应用通过哨兵获取新的主节点地址，自动切换连接</li>
            </ol>
            <p><strong>哨兵架构：</strong></p>
            <ul>
                <li><strong>哨兵节点数：</strong>至少3个哨兵节点（奇数），避免脑裂（quorum通常设置为2）</li>
                <li><strong>部署方式：</strong>哨兵节点应该部署在不同的物理机或容器中，避免单点故障</li>
                <li><strong>仲裁机制：</strong>当quorum个哨兵确认主节点下线时，才触发故障转移（防止误判）</li>
            </ul>
            <p><strong>应用集成：</strong></p>
            <ul>
                <li>应用不直接连接Redis主节点，而是连接哨兵集群</li>
                <li>哨兵返回当前主节点的地址（IP和端口）</li>
                <li>主节点切换时，应用自动获取新主节点地址（通过订阅+switch-master消息或轮询查询）</li>
            </ul>
        </div>
    </div>

    <div class="section">
        <h2>6. 后端服务高可用架构</h2>
        <div class="step" onclick="toggleDetails('backend-ha')">点击查看详情</div>
        <div id="backend-ha" class="details">
            <p><strong>后端服务分类：</strong></p>
            <ul>
                <li><strong>核心主后端服务：</strong>处理核心业务逻辑的主服务器。</li>
                <li><strong>核心备用后端服务：</strong>核心业务的备用服务器，主服务故障时接管。</li>
                <li><strong>拆分功能主后端服务：</strong>特定功能（如AI推理、高资源占用）的主服务器。</li>
                <li><strong>拆分功能备用后端服务：</strong>特定功能的备用服务器。</li>
            </ul>
            <p><strong>Nginx健康检查机制：</strong></p>
            <ul>
                <li><strong>主动健康检查：</strong>Nginx定期向后端服务发送健康检查请求。</li>
                <li><strong>被动健康检查：</strong>根据请求响应判断服务状态（连续失败标记为不健康）。</li>
                <li><strong>自动故障转移：</strong>主服务故障时，Nginx自动将流量切换到备用服务。</li>
                <li><strong>恢复检测：</strong>故障服务恢复后，健康检查通过后重新加入负载均衡。</li>
            </ul>
            <p><strong>Nginx配置示例：</strong></p>
            <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px;">
upstream backend_core {
    server 192.168.2.10:8080 max_fails=3 fail_timeout=30s;  # 主服务
    server 192.168.2.11:8080 backup;  # 备用服务
}

upstream backend_ai {
    server 192.168.2.20:8080 max_fails=3 fail_timeout=30s;  # AI主服务
    server 192.168.2.21:8080 backup;  # AI备用服务
}

# 主动健康检查（需要nginx_plus或第三方模块）
check interval=3000 rise=2 fall=3 timeout=1000;
            </pre>
            <p><strong>与Redis哨兵的区别：</strong></p>
            <ul>
                <li><strong>Redis哨兵：</strong>专门用于Redis数据库的自动故障转移。</li>
                <li><strong>Nginx健康检查：</strong>用于应用层（后端服务）的负载均衡和故障转移。</li>
                <li><strong>配合使用：</strong>Nginx负责后端服务的高可用，哨兵负责Redis的高可用，两者独立工作。</li>
            </ul>
            <p><strong>完整的高可用流程：</strong></p>
            <ol>
                <li>用户请求 → Nginx网关</li>
                <li>Nginx通过健康检查选择健康的后端服务（主服务优先）</li>
                <li>后端服务连接Redis哨兵获取主节点地址</li>
                <li>操作Redis主节点或数据库</li>
                <li>如果主服务故障，Nginx自动切换到备用服务</li>
                <li>如果Redis主节点故障，哨兵自动提升从节点为主节点</li>
                <li>后端服务从哨兵获取新的Redis主节点地址</li>
            </ol>
        </div>
    </div>

    <div class="section">
        <h2>7. 模块化设计（高度解耦、内聚）</h2>
        <div class="step" onclick="toggleDetails('modules')">点击查看详情</div>
        <div id="modules" class="details">
            <div class="module"><strong>用户中台模块：</strong>负责认证、用户管理、权限控制。</div>
            <div class="module"><strong>缓存模块：</strong>Redis操作、定时刷新逻辑。</div>
            <div class="module"><strong>数据库模块：</strong>ORM、分库分表、事务管理。</div>
            <div class="module"><strong>业务模块：</strong>具体业务逻辑，如订单、查询等。</div>
            <div class="module"><strong>网关模块：</strong>Nginx配置、路由分发、健康检查。</div>
            <div class="module"><strong>哨兵模块：</strong>Redis哨兵集群，监控和自动故障转移。</div>
            <div class="module"><strong>备份模块：</strong>冷数据迁移、备份策略。</div>
            <p>每个模块独立部署，支持微服务架构。</p>
        </div>
    </div>

    <div class="section">
        <h2>8. 高并发核心组件</h2>
        <div class="step" onclick="toggleDetails('cdn-detail')">点击查看 CDN加速 详情</div>
        <div id="cdn-detail" class="details">
            <h3>CDN内容分发网络</h3>
            <p><strong>核心原理：</strong></p>
            <ul>
                <li><strong>智能调度：</strong>根据用户IP、运营商、地域，自动分配最近的边缘节点</li>
                <li><strong>边缘缓存：</strong>静态资源（图片、CSS、JS、视频）缓存在CDN节点</li>
                <li><strong>回源机制：</strong>节点无缓存时，从源站拉取并缓存</li>
                <li><strong>缓存更新：</strong>通过TTL、版本号、手动刷新控制缓存有效性</li>
            </ul>
            <p><strong>缓存资源类型：</strong></p>
            <ul>
                <li><strong>静态文件：</strong>图片（JPG/PNG/WebP）、样式（CSS）、脚本（JS）、字体（WOFF/TTF）</li>
                <li><strong>媒体资源：</strong>视频（MP4）、音频（MP3）、流媒体（HLS/DASH）</li>
                <li><strong>不缓存内容：</strong>HTML、API接口、用户个性化数据</li>
            </ul>
            <p><strong>性能指标：</strong>响应时间从500ms降低到20-50ms，源站带宽降低80-90%</p>
        </div>

        <div class="step" onclick="toggleDetails('rate-limiter-detail')">点击查看 限流控制 详情</div>
        <div id="rate-limiter-detail" class="details">
            <h3>限流控制</h3>
            <p><strong>四种限流算法：</strong></p>
            <ul>
                <li><strong>固定窗口：</strong>实现简单，但有边界突刺问题</li>
                <li><strong>滑动窗口：</strong>精度高，无边界突刺，内存占用大</li>
                <li><strong>漏桶算法：</strong>平滑流量，恒定速率处理，无法应对突发</li>
                <li><strong>令牌桶算法：</strong>允许突发流量，推荐使用</li>
            </ul>
            <p><strong>限流维度：</strong></p>
            <ul>
                <li><strong>IP限流：</strong>防止单IP恶意请求</li>
                <li><strong>用户限流：</strong>根据用户ID限流</li>
                <li><strong>接口限流：</strong>对每个接口单独限流</li>
                <li><strong>全局限流：</strong>保护整个系统</li>
            </ul>
            <p><strong>实现方式：</strong>Nginx层限流（推荐）、应用层限流（Guava/Redis）、中间件限流（Sentinel）</p>
        </div>

        <div class="step" onclick="toggleDetails('circuit-breaker-detail')">点击查看 熔断器 详情</div>
        <div id="circuit-breaker-detail" class="details">
            <h3>熔断器</h3>
            <p><strong>三种状态：</strong></p>
            <ul>
                <li><strong>关闭状态（Closed）：</strong>正常工作，统计失败率</li>
                <li><strong>开启状态（Open）：</strong>熔断触发，直接拒绝请求，快速失败</li>
                <li><strong>半开状态（Half-Open）：</strong>试探状态，允许少量请求验证服务是否恢复</li>
            </ul>
            <p><strong>熔断触发条件：</strong>失败率阈值（如50%）、异常比例、慢调用比例（响应时间>500ms）、异常数</p>
            <p><strong>关键配置：</strong>滑动窗口大小（100个请求/10秒）、失败率阈值（50%）、熔断开启时长（10秒）</p>
            <p><strong>实现框架：</strong>Resilience4j（推荐）、Sentinel（功能强大）、Hystrix（已停止维护）</p>
        </div>

        <div class="step" onclick="toggleDetails('degradation-detail')">点击查看 降级处理 详情</div>
        <div id="degradation-detail" class="details">
            <h3>降级处理</h3>
            <p><strong>三种降级类型：</strong></p>
            <ul>
                <li><strong>功能降级：</strong>关闭非核心功能（评论、点赞），保留核心功能（下单、支付）</li>
                <li><strong>数据降级：</strong>返回默认值、返回缓存旧数据、返回静态页面</li>
                <li><strong>服务降级：</strong>拒绝部分请求、限流、延迟非实时任务</li>
            </ul>
            <p><strong>降级触发条件：</strong></p>
            <ul>
                <li><strong>主动降级：</strong>预知流量高峰（双11、秒杀）、系统维护、人工开关</li>
                <li><strong>自动降级：</strong>系统负载过高（CPU>80%）、下游服务故障、熔断器触发</li>
            </ul>
            <p><strong>降级策略优先级：</strong>完全降级 → 默认值降级 → 缓存降级 → 限流降级</p>
        </div>

        <div class="step" onclick="toggleDetails('local-cache-detail')">点击查看 本地缓存 详情</div>
        <div id="local-cache-detail" class="details">
            <h3>本地缓存（多级缓存L1）</h3>
            <p><strong>多级缓存架构：</strong></p>
            <ul>
                <li><strong>L1本地缓存：</strong>应用内存缓存（Guava/Caffeine），响应时间&lt;1ms</li>
                <li><strong>L2分布式缓存：</strong>Redis集群，响应时间1-5ms</li>
                <li><strong>L3数据库：</strong>MySQL/PostgreSQL，响应时间10-100ms</li>
            </ul>
            <p><strong>本地缓存特点：</strong></p>
            <ul>
                <li><strong>优点：</strong>速度极快（内存访问）、降低Redis压力90%+、提升吞吐量</li>
                <li><strong>缺点：</strong>容量受限、数据不一致（多实例不同步）、重启丢失</li>
            </ul>
            <p><strong>适合缓存的数据：</strong>热点数据（首页配置、热门商品）、静态配置（字典表）、计算结果（统计数据）</p>
            <p><strong>缓存一致性保证：</strong>定期刷新（5分钟TTL）、主动失效（MQ通知）、版本号控制</p>
        </div>

        <div class="step" onclick="toggleDetails('distributed-lock-detail')">点击查看 Redis分布式锁 详情</div>
        <div id="distributed-lock-detail" class="details">
            <h3>Redis分布式锁</h3>
            <p><strong>核心原理：</strong>利用Redis的SETNX命令（SET if Not eXists），只有当key不存在时才能设置成功</p>
            <p><strong>基础实现要素：</strong></p>
            <ul>
                <li><strong>唯一标识：</strong>UUID + 线程ID，解锁时校验</li>
                <li><strong>过期时间：</strong>必须设置，防止死锁（如30秒）</li>
                <li><strong>原子性：</strong>SET NX PX、Lua脚本保证原子操作</li>
            </ul>
            <p><strong>高级特性：</strong></p>
            <ul>
                <li><strong>Redlock算法：</strong>向5个独立Redis节点申请锁，大多数节点成功才算成功</li>
                <li><strong>Watch Dog续期：</strong>后台线程定期延长锁的过期时间（Redisson自动支持）</li>
                <li><strong>可重入锁：</strong>同一线程可多次获取同一把锁（计数器记录）</li>
            </ul>
            <p><strong>使用注意事项：</strong>锁粒度尽量细（锁订单ID而非整个用户）、根据业务执行时间设置超时、异常时也要释放锁</p>
        </div>

        <div class="step" onclick="toggleDetails('redis-db-sync-detail')">点击查看 Redis-DB定期同步 详情</div>
        <div id="redis-db-sync-detail" class="details">
            <h3>Redis-DB定期同步</h3>
            <p><strong>同步原因：</strong>缓存是易失性存储（Redis重启数据丢失）、缓存更新失败、长时间运行后数据不一致</p>
            <p><strong>三种同步方式：</strong></p>
            <ul>
                <li><strong>全量同步：</strong>扫描Redis所有数据写入DB（凌晨低峰期执行，耗时长）</li>
                <li><strong>增量同步：</strong>记录Redis写操作日志（RDB/AOF），定期同步（速度快，实现复杂）</li>
                <li><strong>基于时间戳同步：</strong>为缓存数据设置同步时间戳，定期查询未同步的数据</li>
            </ul>
            <p><strong>四种同步策略：</strong>实时同步（一致性最好）、准实时同步（MQ异步）、定期同步（性能最好）、混合策略</p>
            <p><strong>同步冲突处理：</strong>时间戳比较（取最新值）、版本号/CAS机制、以DB为准、人工介入</p>
        </div>

        <div class="step" onclick="toggleDetails('message-queue-detail')">点击查看 消息队列 详情</div>
        <div id="message-queue-detail" class="details">
            <h3>消息队列（异步解耦）</h3>
            <p><strong>核心价值：</strong>异步解耦、提升性能（同步变异步）、削峰填谷、消息持久化保证可靠性</p>
            <p><strong>常见消息队列对比：</strong></p>
            <ul>
                <li><strong>Kafka：</strong>高吞吐量（百万级/秒），适合日志采集、流式处理</li>
                <li><strong>RabbitMQ：</strong>功能完善，支持复杂路由、延迟队列、事务消息</li>
                <li><strong>RocketMQ：</strong>阿里开源，适合电商，支持事务消息、定时消息、顺序消息</li>
            </ul>
            <p><strong>消息模式：</strong>点对点（一条消息被一个消费者消费）、发布订阅（一条消息被多个消费者消费）、顺序消费、事务消息</p>
            <p><strong>典型应用场景：</strong>异步处理（注册后发送邮件）、系统解耦（订单系统→库存/物流/通知系统）、流量削峰（秒杀请求写入MQ）、事件驱动（数据变更触发缓存刷新）</p>
            <p><strong>消息可靠性保证：</strong>消息持久化、消费确认（ACK）、重试机制（指数退避）、死信队列</p>
        </div>

        <div class="step" onclick="toggleDetails('full-link-monitoring-detail')">点击查看 全链路监控 详情</div>
        <div id="full-link-monitoring-detail" class="details">
            <h3>全链路监控</h3>
            <p><strong>核心能力：</strong>链路追踪（记录请求经过的所有服务）、性能分析（统计每个环节耗时、吞吐量、成功率）、故障定位（快速定位慢查询、异常调用）、依赖拓扑（自动生成服务调用关系图）</p>
            <p><strong>常见工具：</strong></p>
            <ul>
                <li><strong>SkyWalking：</strong>国产开源，专注于APM，可视化友好</li>
                <li><strong>Zipkin：</strong>Twitter开源，轻量级，适合微服务</li>
                <li><strong>Jaeger：</strong>Uber开源，兼容OpenTelemetry标准</li>
                <li><strong>Pinpoint：</strong>韩国开源，字节码注入无侵入，定位精确到代码行</li>
            </ul>
            <p><strong>核心概念：</strong>Trace（完整调用链路）、Span（单个调用）、TraceID（链路唯一标识）、SpanID（跨度标识）</p>
            <p><strong>监控指标：</strong>响应时间（RT、P99）、吞吐量（QPS）、错误率、慢查询（响应时间>1秒）</p>
        </div>

        <div class="step" onclick="toggleDetails('alert-center-detail')">点击查看 告警中心 详情</div>
        <div id="alert-center-detail" class="details">
            <h3>告警中心</h3>
            <p><strong>核心功能：</strong>数据采集（系统指标、应用指标）、告警规则（配置阈值）、告警聚合（避免告警轰炸）、告警通知（邮件、短信、钉钉、电话）、告警确认</p>
            <p><strong>常见监控系统：</strong></p>
            <ul>
                <li><strong>Prometheus + Grafana：</strong>适合云原生、容器化环境</li>
                <li><strong>Zabbix：</strong>老牌监控工具，适合传统服务器</li>
                <li><strong>ELK Stack：</strong>日志采集、存储、分析、可视化</li>
            </ul>
            <p><strong>告警级别：</strong>P0严重（系统不可用，立即处理）、P1重要（核心功能异常，快速处理）、P2一般（非核心功能异常）、P4提示（性能下降，需要关注）</p>
            <p><strong>告警规则示例：</strong>CPU>80%持续5分钟、错误率>5%、响应时间P99>2秒、QPS突然下降50%</p>
            <p><strong>告警收敛策略：</strong>时间窗口（相同告警N分钟内只发一次）、告警升级（P4未确认自动升级为P2）、告警聚合（多实例相同告警合并）、静默期（维护期间屏蔽）</p>
        </div>
    </div>

    <div class="section">
        <h2>9. 事件驱动架构与微服务解耦</h2>
        <div class="step" onclick="toggleDetails('event-driven')">点击查看详情</div>
        <div id="event-driven" class="details">
            <h3>消息队列作为事件总线</h3>
            <p><strong>核心思想：</strong>通过消息队列（MQ）作为事件总线（Event Bus），将各个微服务完全解耦。业务服务只需发送事件消息到MQ，不需要知道有哪些服务订阅了这个事件。各个订阅服务独立从MQ消费消息，互不影响，实现真正的松耦合架构。</p>

            <h4>为什么需要事件驱动架构</h4>
            <p><strong>传统同步调用的问题：</strong></p>
            <ul>
                <li><strong>紧耦合：</strong>服务A调用服务B，必须知道服务B的地址、接口格式，如果服务B故障，服务A也受影响</li>
                <li><strong>性能差：</strong>服务A需要等待服务B返回结果才能继续，总耗时 = 服务A耗时 + 服务B耗时 + 网络耗时</li>
                <li><strong>扩展困难：</strong>新增一个服务C需要消费服务A的数据，需要修改服务A的代码，增加调用服务C的逻辑</li>
                <li><strong>级联故障：</strong>服务B故障可能导致服务A阻塞，最终导致整个系统雪崩</li>
            </ul>
            <p><strong>事件驱动架构的优势：</strong></p>
            <ul>
                <li><strong>完全解耦：</strong>服务A只需发送事件到MQ，不需要知道有哪些服务消费，也不需要知道消费者的地址和接口</li>
                <li><strong>高性能：</strong>服务A发送消息到MQ后立即返回，耗时&lt;10ms，不阻塞后续流程</li>
                <li><strong>易扩展：</strong>新增服务只需订阅MQ消息即可，无需修改现有服务代码</li>
                <li><strong>削峰填谷：</strong>高峰期消息堆积在MQ，低峰期消费，避免系统被压垮</li>
                <li><strong>故障隔离：</strong>某个消费者故障不影响其他消费者，也不影响消息发送者</li>
            </ul>

            <h4>典型事件流程示例</h4>
            <p><strong>场景：用户下单后的事件分发</strong></p>
            <ol>
                <li><strong>订单服务</strong>完成订单创建，将订单信息写入DB，更新Redis缓存</li>
                <li><strong>订单服务</strong>发送"订单创建成功"事件到MQ（消息包含：订单ID、用户ID、商品ID、金额、时间戳）</li>
                <li><strong>MQ作为事件总线</strong>，将消息分发给所有订阅了"订单创建成功"事件的服务：
                    <ul>
                        <li><strong>通知服务：</strong>发送订单确认短信、邮件、App推送</li>
                        <li><strong>积分服务：</strong>给用户增加积分（消费金额 × 积分比例）</li>
                        <li><strong>客服服务：</strong>创建工单记录，准备售后支持</li>
                        <li><strong>商户管理服务：</strong>通知商户有新订单，发送订单详情</li>
                        <li><strong>日志服务：</strong>记录订单创建日志，用于审计和问题追踪</li>
                        <li><strong>统计服务：</strong>更新销售统计、用户消费统计</li>
                    </ul>
                </li>
                <li>所有服务<strong>并行处理</strong>，互不影响，总耗时 = max(各服务耗时)，而非sum(各服务耗时)</li>
            </ol>

            <h4>各个微服务的事件订阅</h4>
            <div class="module">
                <strong>1. 登录认证服务（Login Service）</strong>
                <p><strong>订阅事件：</strong>用户注册成功、密码修改成功、手机号变更</p>
                <p><strong>处理逻辑：</strong>
                    <ul>
                        <li>用户注册 → 发送欢迎短信/邮件</li>
                        <li>密码修改 → 发送安全通知（短信/邮件）</li>
                        <li>手机号变更 → 重新验证新手机号</li>
                    </ul>
                </p>
                <p><strong>自身数据存储：</strong>用户登录信息（Redis缓存Token）、用户认证历史（DB记录登录日志）</p>
            </div>

            <div class="module">
                <strong>2. 即时通讯服务（IM Service）</strong>
                <p><strong>订阅事件：</strong>用户注册成功、订单创建成功、订单状态变更、客服消息</p>
                <p><strong>处理逻辑：</strong>
                    <ul>
                        <li>用户注册 → 创建IM账号，分配好友列表</li>
                        <li>订单创建 → 推送订单通知到用户App</li>
                        <li>订单状态变更 → 推送物流信息、发货通知</li>
                        <li>客服消息 → 实时推送给用户和客服</li>
                    </ul>
                </p>
                <p><strong>自身数据存储：</strong>用户会话信息（Redis在线状态）、聊天消息记录（DB存储历史消息）、离线消息（Redis缓存未读消息）</p>
            </div>

            <div class="module">
                <strong>3. 视频服务（Video Service）</strong>
                <p><strong>订阅事件：</strong>用户注册成功、视频上传完成、视频审核通过</p>
                <p><strong>处理逻辑：</strong>
                    <ul>
                        <li>用户注册 → 初始化用户视频空间，分配默认权限</li>
                        <li>视频上传 → 触发转码（标清、高清、超清），生成缩略图</li>
                        <li>审核通过 → 更新视频状态为"已发布"，通知用户</li>
                    </ul>
                </p>
                <p><strong>自身数据存储：</strong>视频元信息（Redis缓存视频基本信息）、视频文件（对象存储OSS）、播放记录（DB记录播放历史）</p>
            </div>

            <div class="module">
                <strong>4. 商品订单服务（Order Service）</strong>
                <p><strong>订阅事件：</strong>订单创建成功、订单支付成功、订单取消、订单退款</p>
                <p><strong>处理逻辑：</strong>
                    <ul>
                        <li>订单创建 → 扣减库存（分布式锁保证），生成订单号</li>
                        <li>支付成功 → 更新订单状态为"已支付"，通知发货服务</li>
                        <li>订单取消 → 恢复库存，处理退款</li>
                    </ul>
                </p>
                <p><strong>自身数据存储：</strong>订单信息（Redis缓存热点订单）、订单详情（DB存储完整订单）、库存信息（Redis缓存实时库存）</p>
            </div>

            <div class="module">
                <strong>5. 客服服务（Customer Service）</strong>
                <p><strong>订阅事件：</strong>订单创建成功、用户投诉、退款申请、评价提交</p>
                <p><strong>处理逻辑：</strong>
                    <ul>
                        <li>订单创建 → 自动创建工单，准备售后支持</li>
                        <li>用户投诉 → 分配客服人员，优先处理</li>
                        <li>退款申请 → 触发退款流程，通知财务</li>
                    </ul>
                </p>
                <p><strong>自身数据存储：</strong>工单信息（Redis缓存待处理工单）、聊天记录（DB存储客服对话）、常见问题（Redis缓存FAQ）</p>
            </div>

            <div class="module">
                <strong>6. 商户管理服务（Merchant Service）</strong>
                <p><strong>订阅事件：</strong>订单创建成功、订单支付成功、商户入驻申请</p>
                <p><strong>处理逻辑：</strong>
                    <ul>
                        <li>订单创建 → 推送新订单通知到商户App，发送短信提醒</li>
                        <li>支付成功 → 更新商户账户余额，生成结算单</li>
                        <li>入驻申请 → 触发审核流程，通知运营人员</li>
                    </ul>
                </p>
                <p><strong>自身数据存储：</strong>商户信息（Redis缓存商户基本信息）、账户余额（DB+Redis双重保障）、订单统计（DB存储经营数据）</p>
            </div>

            <div class="module">
                <strong>7. 日志服务（Log Service）</strong>
                <p><strong>订阅事件：</strong>所有业务事件（用户行为、订单变更、支付记录等）</p>
                <p><strong>处理逻辑：</strong>
                    <ul>
                        <li>接收所有服务发送的事件消息</li>
                        <li>按照日志级别（INFO/WARN/ERROR）分类存储</li>
                        <li>支持按时间、用户ID、订单ID等维度查询</li>
                    </ul>
                </p>
                <p><strong>自身数据存储：</strong>日志索引（Redis缓存近期日志）、日志详情（Elasticsearch存储历史日志）</p>
            </div>

            <div class="module">
                <strong>8. 统计服务（Statistics Service）</strong>
                <p><strong>订阅事件：</strong>所有业务事件（订单、支付、用户行为等）</p>
                <p><strong>处理逻辑：</strong>
                    <ul>
                        <li>实时统计：当前在线人数、今日订单数、今日GMV</li>
                        <li>离线统计：用户增长趋势、商品销售排行、用户消费画像</li>
                        <li>生成报表：日报、周报、月报，支持可视化展示</li>
                    </ul>
                </p>
                <p><strong>自身数据存储：</strong>实时统计数据（Redis缓存热点指标）、历史统计数据（DB存储时序数据）、统计结果（预聚合，提升查询性能）</p>
            </div>

            <div class="module">
                <strong>9. 通知服务（Notification Service）</strong>
                <p><strong>订阅事件：</strong>所有需要通知用户的事件（订单、支付、物流、促销等）</p>
                <p><strong>处理逻辑：</strong>
                    <ul>
                        <li>短信通知：验证码、订单状态、营销短信</li>
                        <li>邮件通知：账单、报表、系统公告</li>
                        <li>App推送：订单消息、活动通知、系统消息</li>
                        <li>站内信：用户通知、客服回复</li>
                    </ul>
                </p>
                <p><strong>自身数据存储：</strong>通知记录（DB存储发送历史）、发送状态（Redis缓存待发送队列）、用户偏好（DB存储用户通知设置）</p>
            </div>

            <h4>每个微服务内部的Redis-DB架构</h4>
            <p><strong>重要原则：</strong>每个微服务都有自己独立的Redis和DB实例，不共享数据存储。服务间通过MQ交换数据，而非直接访问对方的DB。这是微服务架构的核心原则：每个服务独占自己的数据。</p>
            <p><strong>为什么每个服务需要独立的Redis+DB：</strong></p>
            <ul>
                <li><strong>数据隔离：</strong>服务间的数据完全隔离，避免误操作（如：日志服务误删订单数据）</li>
                <li><strong>独立扩展：</strong>每个服务可以根据自己的负载独立扩展（如：订单服务数据量大，分100个表；日志服务数据量更大，分1000个表）</li>
                <li><strong>技术选型灵活：</strong>不同服务可以选择不同的存储（如：订单服务用MySQL，日志服务用MongoDB，视频服务用对象存储）</li>
                <li><strong>故障隔离：</strong>某个服务的DB故障不影响其他服务</li>
            </ul>
            <p><strong>典型微服务数据存储架构：</strong></p>
            <table border="1" cellpadding="10" style="border-collapse: collapse; width: 100%; margin-top: 10px;">
                <tr style="background-color: #f0f0f0;">
                    <th><strong>微服务</strong></th>
                    <th><strong>Redis存储内容</strong></th>
                    <th><strong>DB存储内容</strong></th>
                    <th><strong>数据量级</strong></th>
                </tr>
                <tr>
                    <td>登录认证服务</td>
                    <td>Token（30分钟TTL）、用户登录状态、验证码（5分钟TTL）</td>
                    <td>用户基本信息、登录历史、认证日志</td>
                    <td>百万级用户</td>
                </tr>
                <tr>
                    <td>即时通讯服务</td>
                    <td>在线用户列表、未读消息数、WebSocket连接信息</td>
                    <td>聊天消息记录、群组信息、好友关系</td>
                    <td>亿级消息</td>
                </tr>
                <tr>
                    <td>视频服务</td>
                    <td>视频基本信息（标题、时长、播放数）、热门视频排行榜</td>
                    <td>视频元信息、转码记录、播放历史</td>
                    <td>百万级视频</td>
                </tr>
                <tr>
                    <td>商品订单服务</td>
                    <td>热点订单信息（最近7天）、实时库存、购物车数据</td>
                    <td>订单详情、商品信息、交易流水</td>
                    <td>亿级订单</td>
                </tr>
                <tr>
                    <td>客服服务</td>
                    <td>待处理工单队列、客服在线状态、常见问题FAQ</td>
                    <td>工单详情、聊天记录、评价信息</td>
                    <td>百万级工单</td>
                </tr>
                <tr>
                    <td>商户管理服务</td>
                    <td>商户基本信息、账户余额（实时）、今日订单数</td>
                    <td>商户详细信息、结算记录、交易明细</td>
                    <td>十万级商户</td>
                </tr>
            </table>

            <h4>事件驱动架构的业务价值</h4>
            <ul>
                <li><strong>完全解耦：</strong>服务间通过MQ异步通信，无需知道对方的存在，新增服务只需订阅MQ消息</li>
                <li><strong>高性能：</strong>主流程快速返回（&lt;10ms），耗时操作异步处理，提升系统吞吐量10倍+</li>
                <li><strong>高可用：</strong>某个消费者故障不影响其他消费者，也不影响消息发送者，故障隔离</li>
                <li><strong>易扩展：</strong>新增功能只需新增服务并订阅MQ消息，无需修改现有代码，符合开闭原则</li>
                <li><strong>削峰填谷：</strong>高峰期消息堆积在MQ（支持百万级消息堆积），低峰期慢慢消费，避免系统压垮</li>
                <li><strong>数据最终一致性：</strong>通过MQ保证最终一致性（即使某个服务暂时故障，恢复后可继续消费消息）</li>
            </ul>

            <h3>商户管理服务案例：完整的Redis+DB业务流程</h3>
            <p><strong>为什么选择商户管理服务作为案例：</strong>商户管理服务是一个典型的微服务，包含读取、写入、金额计算、并发控制等多个场景，能够完整展示Redis+DB的协作机制。</p>

            <h4>商户管理服务架构图</h4>
            <div class="mermaid">
                graph TD
                    MQ[消息队列<br/>订单创建成功事件] --> CONSUME[商户管理服务<br/>消费消息]
                    CONSUME --> CHECK{订单类型判断}

                    CHECK -->|新订单| NOTI[通知商户<br/>短信+App推送]
                    CHECK -->|支付成功| BALANCE[更新商户余额<br/>分布式锁保护]
                    CHECK -->|订单退款| REFUND[处理退款<br/>扣减余额]

                    NOTI --> NOTI_REDIS[Redis查询<br/>商户基本信息]
                    NOTI_REDIS --> NOTI_REDIS_HIT{Redis有数据?}
                    NOTI_REDIS_HIT -->|是| NOTI_SEND[发送通知]
                    NOTI_REDIS_HIT -->|否| NOTI_DB[(查询商户DB)]
                    NOTI_DB --> NOTI_REDIS_WRITE[更新Redis缓存]
                    NOTI_REDIS_WRITE --> NOTI_SEND

                    BALANCE --> LOCK[Redis分布式锁<br/>lock:merchant:balance:商户ID]
                    LOCK --> LOCK_CHECK{抢锁成功?}
                    LOCK_CHECK -->|否| LOCK_WAIT[等待10ms重试]
                    LOCK_WAIT --> LOCK
                    LOCK_CHECK -->|是| BALANCE_REDIS[Redis查询<br/>当前余额]
                    BALANCE_REDIS --> BALANCE_CALC[计算新余额<br/>当前余额+订单金额]
                    BALANCE_CALC --> BALANCE_DB[(DB事务更新<br/>START TRANSACTION]
                    BALANCE_DB --> BALANCE_DB_UPDATE[UPDATE账户余额<br/>SET balance=新余额]
                    BALANCE_DB_UPDATE --> BALANCE_DB_INSERT[INSERT交易流水<br/>商户ID,订单ID,金额,时间]
                    BALANCE_DB_INSERT --> BALANCE_DB_COMMIT[COMMIT<br/>提交事务]
                    BALANCE_DB_COMMIT --> BALANCE_REDIS_UPDATE[更新Redis缓存<br/>SET商户余额=新余额]
                    BALANCE_REDIS_UPDATE --> BALANCE_RELEASE[释放分布式锁<br/>DEL lock]

                    REFUND --> REFUND_LOCK[Redis分布式锁<br/>lock:merchant:refund:商户ID]
                    REFUND_LOCK --> REFUND_DB[(DB查询订单<br/>确认可退款)]
                    REFUND_DB --> REFUND_CHECK{退款金额检查}
                    REFUND_CHECK -->|余额不足| REFUND_FAIL[退款失败<br/>发送通知]
                    REFUND_CHECK -->|余额充足| REFUND_DB_UPDATE[(DB事务更新<br/>扣减余额,记录退款)]
                    REFUND_DB_UPDATE --> REFUND_REDIS[更新Redis余额]
                    REFUND_REDIS --> REFUND_OK[退款成功<br/>发送通知]

                    style LOCK fill:#ff9999
                    style REFUND_LOCK fill:#ff9999
                    style BALANCE_DB fill:#99ccff
                    style REFUND_DB fill:#99ccff
                    style NOTI_REDIS fill:#99ff99
                    style BALANCE_REDIS fill:#99ff99
                    style REFUND_REDIS fill:#99ff99
            </div>

            <h4>场景1：新订单通知商户</h4>
            <p><strong>业务场景：</strong>用户下单成功后，需要通知商户有新订单</p>
            <p><strong>处理流程：</strong></p>
            <ol>
                <li><strong>接收MQ消息：</strong>消费"订单创建成功"事件，提取商户ID、订单ID、订单金额、商品信息</li>
                <li><strong>查询商户基本信息（优先Redis）：</strong>
                    <ul>
                        <li>查询Redis：GET merchant:info:{商户ID}</li>
                        <li><strong>Redis命中（&lt;5ms）：</strong>获取商户名称、手机号、App推送Token，直接发送通知</li>
                        <li><strong>Redis未命中：</strong>查询DB（SELECT * FROM merchant WHERE id={商户ID}），将结果写入Redis（TTL=30分钟），再发送通知</li>
                    </ul>
                </li>
                <li><strong>发送通知：</strong>
                    <ul>
                        <li><strong>短信通知：</strong>调用短信网关，发送订单详情（商品名称、金额、收货地址）</li>
                        <li><strong>App推送：</strong>通过商户App的推送Token，推送新订单消息</li>
                        <li><strong>WebSocket推送：</strong>如果商户在后台管理系统在线，实时推送订单弹窗</li>
                    </ul>
                </li>
            </ol>
            <p><strong>为什么先查Redis：</strong>商户基本信息不常变更（手机号、商户名称），非常适合缓存。Redis命中率>95%，只有5%的请求需要查DB，性能提升20倍。</p>

            <h4>场景2：订单支付成功，更新商户余额（核心场景）</h4>
            <p><strong>业务场景：</strong>用户支付订单成功后，需要给商户账户增加订单金额（扣除平台佣金后）</p>
            <p><strong>核心挑战：</strong>并发问题！如果用户同时支付多个订单，多个线程同时更新商户余额，可能导致余额计算错误。</p>
            <p><strong>处理流程（使用分布式锁保证并发安全）：</strong></p>
            <ol>
                <li><strong>接收MQ消息：</strong>消费"订单支付成功"事件，提取商户ID、订单金额、平台佣金率</li>
                <li><strong>计算到账金额：</strong>到账金额 = 订单金额 × (1 - 平台佣金率)</li>
                <li><strong>获取分布式锁（关键步骤）：</strong>
                    <ul>
                        <li>执行Redis命令：SET lock:merchant:balance:{商户ID} "unique_value" NX PX 30000</li>
                        <li><strong>抢锁成功：</strong>继续后续流程</li>
                        <li><strong>抢锁失败：</strong>等待10ms重试，最多重试3次</li>
                    </ul>
                </li>
                <li><strong>查询当前余额（Redis）：</strong>GET merchant:balance:{商户ID}</li>
                <li><strong>计算新余额：</strong>新余额 = 当前余额 + 到账金额</li>
                <li><strong>DB事务更新（ACID保证）：</strong>
                    <ul>
                        <li>START TRANSACTION（开启事务）</li>
                        <li>UPDATE merchant_account SET balance = 新余额 WHERE merchant_id = {商户ID}</li>
                        <li>INSERT INTO transaction_log (merchant_id, order_id, amount, type, create_time) VALUES (...)</li>
                        <li>COMMIT（提交事务）</li>
                    </ul>
                </li>
                <li><strong>更新Redis缓存：</strong>SET merchant:balance:{商户ID} {新余额}</li>
                <li><strong>释放分布式锁：</strong>删除锁（Lua脚本保证原子性）</li>
            </ol>
            <p><strong>为什么需要分布式锁：</strong>防止并发问题！示例：</p>
            <ul>
                <li><strong>没有锁的情况：</strong>当前余额100元，订单A（+50元）和订单B（+30元）同时支付</li>
                <li>线程1读取余额100元，计算新余额150元</li>
                <li>线程2读取余额100元（此时线程1还未写入），计算新余额130元</li>
                <li>线程1写入150元</li>
                <li>线程2写入130元（错误！应该是180元）</li>
                <li><strong>结果：丢失50元，商户投诉</strong></li>
            </ul>
            <p><strong>有锁的情况：</strong></p>
            <ul>
                <li>线程1抢到锁，读取余额100元，计算新余额150元，写入DB，释放锁</li>
                <li>线程2等待线程1释放锁后，抢到锁，读取余额150元（正确！），计算新余额180元，写入DB，释放锁</li>
                <li><strong>结果：余额正确180元</strong></li>
            </ul>

            <h4>场景3：订单退款，扣减商户余额</h4>
            <p><strong>业务场景：</strong>用户退款，需要从商户账户扣减退款金额</p>
            <p><strong>处理流程：</strong></p>
            <ol>
                <li><strong>接收MQ消息：</strong>消费"订单退款"事件，提取商户ID、退款金额</li>
                <li><strong>获取分布式锁：</strong>SET lock:merchant:refund:{商户ID} "unique_value" NX PX 30000</li>
                <li><strong>DB查询当前余额：</strong>SELECT balance FROM merchant_account WHERE merchant_id = {商户ID} FOR UPDATE（悲观锁）</li>
                <li><strong>余额充足性检查：</strong>IF 当前余额 >= 退款金额 THEN 继续 ELSE 退款失败</li>
                <li><strong>DB事务更新：</strong>
                    <ul>
                        <li>UPDATE merchant_account SET balance = balance - 退款金额</li>
                        <li>INSERT INTO transaction_log (..., type='退款', ...)</li>
                        <li>COMMIT</li>
                    </ul>
                </li>
                <li><strong>更新Redis缓存：</strong>SET merchant:balance:{商户ID} {新余额}</li>
                <li><strong>释放分布式锁</li>
            </ol>
            <p><strong>为什么查询DB而非Redis：</strong>退款涉及金额扣减，必须从DB读取最新余额，保证100%准确。即使Redis有缓存，也要查DB。</p>

            <h4>商户管理服务 vs 主流程的Redis-DB架构对比</h4>
            <table border="1" cellpadding="10" style="border-collapse: collapse; width: 100%; margin-top: 10px;">
                <tr style="background-color: #f0f0f0;">
                    <th><strong>对比维度</strong></th>
                    <th><strong>主流程（分布式锁→Redis→DB）</strong></th>
                    <th><strong>商户管理服务（微服务独立）</strong></th>
                    <th><strong>相同点</strong></th>
                </tr>
                <tr>
                    <td><strong>Redis作用</strong></td>
                    <td>L2分布式缓存，存储热点数据</td>
                    <td>L2分布式缓存，存储商户信息、余额</td>
                    <td>✅ 都是分布式缓存，提升性能</td>
                </tr>
                <tr>
                    <td><strong>DB作用</strong></td>
                    <td>L3持久化存储，最终数据保障</td>
                    <td>商户服务专用DB，持久化存储</td>
                    <td>✅ 都是持久化存储，保证数据安全</td>
                </tr>
                <tr>
                    <td><strong>分布式锁</strong></td>
                    <td>通用分布式锁，适用于所有业务</td>
                    <td>商户专用锁（lock:merchant:*），粒度更细</td>
                    <td>✅ 都使用Redis SETNX实现，保证并发安全</td>
                </tr>
                <tr>
                    <td><strong>Redis哨兵</strong></td>
                    <td>全服务共享的Redis哨兵集群</td>
                    <td>共享同一个Redis哨兵集群（通常）</td>
                    <td>✅ 都依赖Redis哨兵保证高可用</td>
                </tr>
                <tr>
                    <td><strong>数据隔离</strong></td>
                    <td>所有业务共享Redis和DB</td>
                    <td>商户服务独占自己的数据（不与其他服务共享DB）</td>
                    <td>❌ 主流程共享，微服务隔离</td>
                </tr>
                <tr>
                    <td><strong>扩展性</strong></td>
                    <td>单体应用，扩展需要整体扩容</td>
                    <td>独立服务，可单独扩容（如：商户数据量大，单独加机器）</td>
                    <td>❌ 微服务架构扩展性更强</td>
                </tr>
                <tr>
                    <td><strong>故障影响</strong></td>
                    <td>故障影响所有业务</td>
                    <td>故障只影响商户功能，不影响其他服务（如：IM、视频）</td>
                    <td>❌ 微服务故障隔离更好</td>
                </tr>
                <tr>
                    <td><strong>技术选型</strong></td>
                    <td>统一技术栈（如：都用MySQL）</td>
                    <td>可选不同技术（如：商户用MySQL，日志用MongoDB，视频用OSS）</td>
                    <td>❌ 微服务技术选型更灵活</td>
                </tr>
                <tr>
                    <td><strong>部署方式</strong></td>
                    <td>单体应用，部署在一起</td>
                    <td>独立部署（Docker容器），独立扩缩容</td>
                    <td>❌ 微服务部署更灵活</td>
                </tr>
            </table>

            <h4>核心区别总结</h4>
            <p><strong>1. 数据隔离（最重要）：</strong></p>
            <ul>
                <li><strong>主流程：</strong>所有业务共享同一个Redis和DB，不同业务的数据混在一起（如：订单数据、用户数据、商户数据都在同一个DB）</li>
                <li><strong>商户服务：</strong>独占自己的Redis和DB，数据完全隔离。即使日志服务被删除所有数据，也不会影响商户服务</li>
            </ul>
            <p><strong>2. 扩展性：</strong></p>
            <ul>
                <li><strong>主流程：</strong>如果订单数据量大，需要分库分表，会影响所有业务</li>
                <li><strong>商户服务：</strong>如果商户数据量大，只对商户服务分库分表，不影响其他服务</li>
            </ul>
            <p><strong>3. 故障隔离：</strong></p>
            <ul>
                <li><strong>主流程：</strong>DB故障，所有业务都不可用</li>
                <li><strong>商户服务：</strong>商户DB故障，只影响商户功能，IM、视频、订单等其他服务正常运行</li>
            </ul>
            <p><strong>相同点：</strong></p>
            <ul>
                <li><strong>都使用Redis作为缓存层：</strong>先查Redis，未命中再查DB，查询后更新Redis</li>
                <li><strong>都使用DB作为持久化层：</strong>最终数据都存储在DB，保证数据不丢失</li>
                <li><strong>都使用分布式锁保证并发安全：</strong>通过Redis SETNX实现锁机制</li>
                <li><strong>都依赖Redis哨兵保证高可用：</strong>Redis主节点故障，哨兵自动切换</li>
                <li><strong>都使用事务保证数据一致性：</strong>DB操作使用事务（ACID）</li>
            </ul>

            <h4>商户管理服务的完整技术栈</h4>
            <div class="module">
                <strong>缓存层（Redis）：</strong>
                <ul>
                    <li>商户基本信息：merchant:info:{商户ID}（TTL=30分钟）</li>
                    <li>商户余额：merchant:balance:{商户ID}（实时更新，不设置TTL）</li>
                    <li>今日订单数：merchant:orders:today:{商户ID}（每天凌晨清零）</li>
                    <li>分布式锁：lock:merchant:balance:{商户ID}、lock:merchant:refund:{商户ID}</li>
                </ul>
            </div>
            <div class="module">
                <strong>持久化层（MySQL）：</strong>
                <ul>
                    <li>商户表（merchant）：商户ID、名称、手机号、邮箱、状态</li>
                    <li>商户账户表（merchant_account）：商户ID、余额、冻结金额、创建时间</li>
                    <li>交易流水表（transaction_log）：流水ID、商户ID、订单ID、金额、类型（入账/出账）、时间</li>
                    <li>结算记录表（settlement_record）：结算ID、商户ID、结算金额、结算时间、状态</li>
                </ul>
            </div>
            <div class="module">
                <strong>消息队列（Kafka/RabbitMQ）：</strong>
                <ul>
                    <li>订阅主题：order.created（订单创建）、order.paid（订单支付）、order.refunded（订单退款）</li>
                    <li>发布主题（如果有）：merchant.settlement（商户结算完成）</li>
                </ul>
            </div>
            <div class="module">
                <strong>外部服务：</strong>
                <ul>
                    <li>短信网关：发送订单通知短信</li>
                    <li>推送服务：发送App推送通知</li>
                    <li>支付网关：查询订单支付状态、处理退款</li>
                </ul>
            </div>

            <h4>性能优化技巧</h4>
            <ul>
                <li><strong>Redis缓存预热：</strong>服务启动时，将热点商户数据加载到Redis</li>
                <li><strong>Redis Pipeline：</strong>批量查询多个商户信息时，使用Pipeline减少网络往返</li>
                <li><strong>DB读写分离：</strong>查询走从库，更新走主库</li>
                <li><strong>DB连接池：</strong>使用连接池（如：HikariCP），避免频繁创建连接</li>
                <li><strong>异步通知：</strong>余额更新成功后，异步发送短信和App推送（不阻塞主流程）</li>
            </ul>
        </div>
    </div>

    <!-- 如果图表显示为文字，请按F12打开控制台查看错误信息 -->
    <script>
        // 检查Mermaid是否加载成功
        if (typeof mermaid === 'undefined') {
            console.error('Mermaid库加载失败！请检查网络连接或CDN是否可访问');
            document.addEventListener('DOMContentLoaded', function() {
                const mermaidDivs = document.querySelectorAll('.mermaid');
                mermaidDivs.forEach(function(div) {
                    div.style.border = '2px solid red';
                    div.innerHTML = '<p style="color: red; padding: 20px;">⚠️ Mermaid库加载失败，无法渲染流程图。<br>请检查网络连接，或刷新页面重试。<br>按F12打开控制台查看详细错误信息。</p>';
                });
            });
        } else {
            console.log('✅ Mermaid库加载成功，版本:', mermaid.version);
        }

        mermaid.initialize({ startOnLoad: true });

        window.addEventListener('load', function() {
            console.log('Window loaded');
            // 等待Mermaid渲染完成
            setTimeout(function() {
                console.log('Timeout triggered');
                const svg = document.querySelector('.mermaid svg');
                console.log('SVG found:', svg);
                if (svg) {
                    // 定义节点类型映射
                    const nodeTypes = [
                        { text: 'HTTP', type: 'HTTP' },
                        { text: 'WebSocket', type: 'WebSocket' },
                        { text: '前端App/Web', type: 'frontend' },
                        { text: '连接类型', type: 'connection-type' },
                        { text: '核心主后端服务', type: 'backend' },
                        { text: '核心备用后端服务', type: 'backend' },
                        { text: '拆分功能主后端服务', type: 'backend' },
                        { text: '拆分功能备用后端服务', type: 'backend' },
                        { text: '用户中台模块: 认证校验', type: 'user-middle-tier' },
                        { text: '业务模块: 操作处理', type: 'business-module' },
                        { text: '需要数据库操作', type: 'need-db' },
                        { text: '读/写操作', type: 'read-write' },
                        { text: '返回Nginx网关', type: 'return-nginx' },
                        { text: '数据类型', type: 'data-type' },
                        { text: 'Redis哨兵集群', type: 'redis-sentinel-cluster' },
                        { text: 'Redis哨兵', type: 'redis-sentinel-cluster' },
                        { text: 'Redis哨兵监控', type: 'redis-sentinel-monitor' },
                        { text: 'Redis主节点健康', type: 'redis-sentinel-monitor' },
                        { text: 'Redis主节点查询', type: 'redis-read-query' },
                        { text: 'Redis主节点检查', type: 'redis-write-check' },
                        { text: 'Redis从节点提升主节点', type: 'redis-failover' },
                        { text: '有数据', type: 'write-has-data' },
                        { text: '无数据', type: 'write-no-data' },
                        { text: '查询DB & 事务更新DB & 更新Redis主节点', type: 'write-query-db-transaction' },
                        { text: '后端服务健康监控', type: 'health-monitor' },
                        { text: 'Nginx自动切换备用服务', type: 'nginx-switch' },
                        { text: 'Nginx网关', type: 'nginx' },
                        { text: '独立热数据服务器', type: 'hot-data-server' },
                        { text: '集合冷数据服务器', type: 'cold-data-server' },
                        { text: '冷数据备份:', type: 'cold-backup' },
                        { text: '可查询冷DB', type: 'cold-db' },
                        { text: '事务保护', type: 'transaction' },
                        { text: '定时刷新Redis-DB', type: 'redis-refresh' },
                        { text: '分库分表处理', type: 'sharding' },
                        { text: '监控', type: 'sentinel-monitoring-process' },
                        { text: '自动故障转移', type: 'sentinel-failover-process' },
                        { text: '通知', type: 'sentinel-notification-process' },
                        { text: '命中', type: 'cache-hit' },
                        { text: '未命中', type: 'cache-miss' },
                        { text: '数据库查询', type: 'db-query' },
                        { text: '更新Redis主节点', type: 'update-redis-master' },
                        { text: 'CDN加速', type: 'cdn' },
                        { text: '限流控制', type: 'rate-limiter' },
                        { text: '熔断器', type: 'circuit-breaker' },
                        { text: '降级处理', type: 'degradation' },
                        { text: '本地缓存', type: 'local-cache' },
                        { text: '需要分布式锁', type: 'need-distributed-lock' },
                        { text: 'Redis分布式锁', type: 'distributed-lock' },
                        { text: '抢锁成功', type: 'lock-result' },
                        { text: '执行业务逻辑', type: 'execute-business' },
                        { text: '等待重试', type: 'lock-retry' },
                        { text: 'Redis-DB定期同步', type: 'redis-db-sync' },
                        { text: '消息队列', type: 'message-queue' },
                        { text: '消息队列<br/>异步解耦<br/>事件总线', type: 'message-queue' },
                        { text: '日志服务', type: 'mq-log-service' },
                        { text: '统计服务', type: 'mq-stats-service' },
                        { text: '通知服务', type: 'mq-notify-service' },
                        { text: '登录认证服务', type: 'login-service' },
                        { text: '即时通讯服务', type: 'im-service' },
                        { text: '视频服务', type: 'video-service' },
                        { text: '商品订单服务', type: 'order-service' },
                        { text: '客服服务', type: 'customer-service' },
                        { text: '商户管理服务', type: 'merchant-service' },
                        { text: '登录服务<br/>Redis+DB', type: 'login-service-db' },
                        { text: '即时通讯<br/>Redis+DB', type: 'im-service-db' },
                        { text: '视频服务<br/>Redis+DB', type: 'video-service-db' },
                        { text: '订单服务<br/>Redis+DB', type: 'order-service-db' },
                        { text: '客服服务<br/>Redis+DB', type: 'customer-service-db' },
                        { text: '商户管理<br/>Redis+DB', type: 'merchant-service-db' },
                        { text: '全链路监控', type: 'full-link-monitoring' },
                        { text: '告警中心', type: 'alert-center' }
                    ];

                    // 查找所有可能包含文本的元素
                    const allElements = svg.querySelectorAll('*');
                    console.log('Total elements found:', allElements.length);

                    // 为每个节点添加点击事件
                    allElements.forEach(element => {
                        const textContent = element.textContent ? element.textContent.trim() : '';

                        // 检查是否匹配我们定义的节点
                        for (let nodeType of nodeTypes) {
                            if (textContent === nodeType.text || textContent.includes(nodeType.text)) {
                                console.log('Matched:', textContent, '->', nodeType.type);

                                // 设置鼠标样式
                                element.style.cursor = 'pointer';

                                // 添加点击事件
                                element.addEventListener('click', function(e) {
                                    e.stopPropagation();
                                    console.log('Clicked:', nodeType.type, 'for text:', textContent);
                                    toggleTooltip(element, nodeType.type);
                                });

                                // 改变颜色提示可点击
                                if (element.tagName === 'text' || element.tagName === 'tspan') {
                                    element.style.fill = '#007bff';
                                }

                                break; // 找到匹配就跳出循环
                            }
                        }
                    });

                    console.log('Tooltip setup completed');
                }
            }, 3000); // 增加延迟到3秒，确保Mermaid完全渲染
        });

        let currentTooltip = null;
        let currentTarget = null;

        function toggleTooltip(target, type) {
            if (currentTooltip && currentTarget === target) {
                // 隐藏
                document.body.removeChild(currentTooltip);
                currentTooltip = null;
                currentTarget = null;
                return;
            }

            // 隐藏之前的
            if (currentTooltip) {
                document.body.removeChild(currentTooltip);
            }

            // 创建新的
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';

            let content = '';
            if (type === 'HTTP') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>HTTP连接说明</h4>
                    <p><strong>定义：</strong>超文本传输协议（HyperText Transfer Protocol），用于客户端和服务器之间的请求-响应通信。</p>
                    <p><strong>主要功能：</strong></p>
                    <ul>
                        <li><strong>请求-响应模式：</strong>客户端发送请求，服务器返回响应</li>
                        <li><strong>无状态协议：</strong>每次请求独立，不保留上下文</li>
                        <li><strong>灵活可扩展：</strong>通过请求头传递元信息</li>
                        <li><strong>支持多种方法：</strong>GET、POST、PUT、DELETE等</li>
                    </ul>
                    <p><strong>重要概念：</strong></p>
                    <ul>
                        <li><strong>无状态：</strong>服务器不保存客户端状态，需要通过Cookie/Session维持会话</li>
                        <li><strong>连接复用：</strong>HTTP/1.1支持keep-alive，减少连接建立开销</li>
                        <li><strong>缓存机制：</strong>支持强缓存和协商缓存，提高性能</li>
                    </ul>
                    <p><strong>应用场景：</strong></p>
                    <ul>
                        <li><strong>用户登录注册：</strong>表单提交、身份验证</li>
                        <li><strong>数据查询：</strong>获取列表、详情、搜索等</li>
                        <li><strong>数据提交：</strong>创建、更新、删除资源</li>
                        <li><strong>文件上传：</strong>图片、视频、文档上传</li>
                        <li><strong>API调用：</strong>RESTful API、GraphQL等</li>
                        <li><strong>页面加载：</strong>HTML、CSS、JS等静态资源加载</li>
                    </ul>
                    <p><strong>优势：</strong>广泛支持、易缓存、简单易用、防火墙友好。</p>
                    <p><strong>劣势：</strong>服务器无法主动推送、每次请求携带头部开销、不适合实时通信。</p>
                `;
            } else if (type === 'WebSocket') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>WebSocket连接说明</h4>
                    <p><strong>定义：</strong>全双工通信协议，在单个TCP连接上提供全双工、双向通信通道，允许服务器主动推送数据给客户端。</p>
                    <p><strong>主要功能：</strong></p>
                    <ul>
                        <li><strong>持久连接：</strong>建立连接后保持打开状态，避免重复握手</li>
                        <li><strong>双向通信：</strong>客户端和服务器可以随时发送消息</li>
                        <li><strong>低延迟：</strong>连接建立后数据传输实时，无需HTTP请求头开销</li>
                        <li><strong>轻量级：</strong>数据帧格式简单，开销小</li>
                    </ul>
                    <p><strong>重要概念：</strong></p>
                    <ul>
                        <li><strong>握手阶段：</strong>使用HTTP进行初始握手，升级为WebSocket协议</li>
                        <li><strong>心跳机制：</strong>定期发送ping/pong帧保持连接活跃</li>
                        <li><strong>连接状态：</strong>CONNECTING、OPEN、CLOSING、CLOSED</li>
                        <li><strong>同源策略：</strong>WebSocket受同源策略限制，需要CORS支持跨域</li>
                    </ul>
                    <p><strong>应用场景：</strong></p>
                    <ul>
                        <li><strong>即时通讯：</strong>聊天室、私聊、群聊、消息推送</li>
                        <li><strong>实时通知：</strong>系统消息、提醒通知、公告推送</li>
                        <li><strong>在线游戏：</strong>多人对战、实时同步、位置更新</li>
                        <li><strong>实时协作：</strong>在线文档、协同编辑、白板共享</li>
                        <li><strong>数据监控：</strong>服务器监控、IoT设备状态、股票行情</li>
                        <li><strong>直播互动：</strong>弹幕、礼物、点赞实时展示</li>
                        <li><strong>位置服务：</strong>实时定位、路线导航、配送跟踪</li>
                    </ul>
                    <p><strong>优势：</strong>实时性强、服务器可主动推送、连接复用、延迟低。</p>
                    <p><strong>劣势：</strong>实现相对复杂、无状态代理服务器支持差、连接管理需要考虑重连机制。</p>
                `;
            } else if (type === 'cdn') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>CDN内容分发网络</h4>
                    <p><strong>作用：</strong>将静态资源分发到全球边缘节点，用户就近访问，降低延迟，减轻源站压力。</p>
                    <p><strong>核心原理：</strong></p>
                    <ul>
                        <li><strong>智能调度：</strong>根据用户IP、运营商、地域，自动分配最近的边缘节点</li>
                        <li><strong>边缘缓存：</strong>静态资源（图片、CSS、JS、视频）缓存在CDN节点</li>
                        <li><strong>回源机制：</strong>节点无缓存时，从源站拉取并缓存</li>
                        <li><strong>缓存更新：</strong>通过TTL、版本号、手动刷新控制缓存有效性</li>
                    </ul>
                    <p><strong>缓存资源类型：</strong></p>
                    <ul>
                        <li><strong>静态文件：</strong>图片（JPG/PNG/WebP）、样式（CSS）、脚本（JS）、字体（WOFF/TTF）</li>
                        <li><strong>媒体资源：</strong>视频（MP4）、音频（MP3）、流媒体（HLS/DASH）</li>
                        <li><strong>文档资源：</strong>PDF、Word、Excel等下载文件</li>
                        <li><strong>不缓存内容：</strong>HTML、API接口、用户个性化数据</li>
                    </ul>
                    <p><strong>CDN配置关键点：</strong></p>
                    <ul>
                        <li><strong>CNAME配置：</strong>将域名解析到CDN提供的CNAME地址</li>
                        <li><strong>缓存规则：</strong>根据文件扩展名、路径设置不同TTL（推荐静态资源1年，HTML不缓存）</li>
                        <li><strong>HTTPS支持：</strong>CDN节点自动配置SSL证书</li>
                        <li><strong>防盗链：</strong>通过Referer、Token防止盗链</li>
                        <li><strong>缓存预热：</strong>热门资源提前推送到CDN节点</li>
                    </ul>
                    <p><strong>性能指标：</strong></p>
                    <ul>
                        <li><strong>响应时间：</strong>从500ms降低到20-50ms（就近访问）</li>
                        <li><strong>带宽节省：</strong>源站带宽降低80-90%</li>
                        <li><strong>可用性：</strong>CDN节点故障自动切换到其他节点</li>
                    </ul>
                    <p><strong>业务价值：</strong>提升用户访问速度，降低源站负载和带宽成本，提高系统可用性和扩展能力。</p>
                `;
            } else if (type === 'rate-limiter') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>限流控制</h4>
                    <p><strong>作用：</strong>保护系统不被突发流量击垮，拒绝超出系统处理能力的请求，保障核心服务稳定运行。</p>
                    <p><strong>核心目标：</strong></p>
                    <ul>
                        <li><strong>保护系统：</strong>防止CPU、内存、数据库连接耗尽</li>
                        <li><strong>保证SLA：</strong>确保大部分请求能够正常响应</li>
                        <li><strong>公平性：</strong>防止少数用户占用过多资源</li>
                        <li><strong>防止攻击：</strong>拒绝DDoS攻击、恶意爬虫</li>
                    </ul>
                    <p><strong>常见限流算法：</strong></p>
                    <ul>
                        <li><strong>固定窗口算法（Fixed Window）：</strong>
                            <ul>
                                <li>原理：将时间划分为固定窗口（如1秒），计数器累加请求</li>
                                <li>优点：实现简单，内存占用小</li>
                                <li>缺点：窗口边界流量突刺（窗口结束时请求突然涌向下一窗口）</li>
                                <li>适用场景：对精度要求不高的场景</li>
                            </ul>
                        </li>
                        <li><strong>滑动窗口算法（Sliding Window）：</strong>
                            <ul>
                                <li>原理：记录每个请求的时间戳，统计最近N秒内的请求数</li>
                                <li>优点：精度高，无边界突刺问题</li>
                                <li>缺点：内存占用较大（需存储请求时间戳）</li>
                                <li>适用场景：对限流精度要求高的场景</li>
                            </ul>
                        </li>
                        <li><strong>漏桶算法（Leaky Bucket）：</strong>
                            <ul>
                                <li>原理：请求进入漏桶，以恒定速率流出（处理请求），桶满则拒绝</li>
                                <li>优点：平滑流量，保证系统处理速率恒定</li>
                                <li>缺点：无法应对突发流量（即使系统有空余能力）</li>
                                <li>适用场景：保护数据库、保护第三方接口调用</li>
                            </ul>
                        </li>
                        <li><strong>令牌桶算法（Token Bucket）：</strong>
                            <ul>
                                <li>原理：以恒定速率向桶中添加令牌，请求消耗令牌，无令牌则拒绝</li>
                                <li>优点：允许一定程度的突发流量（桶中有令牌累积）</li>
                                <li>缺点：实现相对复杂</li>
                                <li>适用场景：需要应对突发流量的场景（推荐）</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>限流维度：</strong></p>
                    <ul>
                        <li><strong>IP限流：</strong>防止单IP恶意请求（如：每IP每秒100次）</li>
                        <li><strong>用户限流：</strong>根据用户ID限流（防止单用户占用过多资源）</li>
                        <li><strong>接口限流：</strong>对每个接口单独限流（如：登录接口每秒50次，查询接口每秒1000次）</li>
                        <li><strong>全局限流：</strong>保护整个系统（如：系统总QPS不超过10000）</li>
                    </ul>
                    <p><strong>限流实现方式：</strong></p>
                    <ul>
                        <li><strong>Nginx层限流：</strong>通过limit_req模块实现（推荐在网关层限流，尽早拦截）</li>
                        <li><strong>应用层限流：</strong>通过Guava RateLimiter、Redis+Lua实现</li>
                        <li><strong>中间件限流：</strong>通过Sentinel、Hystrix实现</li>
                    </ul>
                    <p><strong>配置示例（令牌桶）：</strong></p>
                    <ul>
                        <li>限流阈值：100 QPS（每秒100次请求）</li>
                        <li>突发容量：200令牌（允许突发流量最多200次）</li>
                        <li>超出处理：直接拒绝（返回429 Too Many Requests）</li>
                    </ul>
                    <p><strong>业务价值：</strong>保障系统在高并发、恶意攻击下的稳定运行，保护核心资源，确保服务可用性。</p>
                `;
            } else if (type === 'circuit-breaker') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>熔断器</h4>
                    <p><strong>作用：</strong>当检测到下游服务故障时，快速失败，避免请求堆积，保护系统级联崩溃。</p>
                    <p><strong>核心思想：</strong>类比电路保险丝，当电流过大（服务故障）时自动断开，防止故障蔓延。</p>
                    <p><strong>三种状态：</strong></p>
                    <ul>
                        <li><strong>关闭状态（Closed）：</strong>
                            <ul>
                                <li>正常工作状态，请求正常通过</li>
                                <li>统计失败率/响应时间</li>
                                <li>当失败率超过阈值时，切换到开启状态</li>
                            </ul>
                        </li>
                        <li><strong>开启状态（Open）：</strong>
                            <ul>
                                <li>熔断触发状态，直接拒绝所有请求</li>
                                <li>快速失败，返回降级数据或错误提示</li>
                                <li>经过一段时间（冷却时间）后，进入半开状态</li>
                            </ul>
                        </li>
                        <li><strong>半开状态（Half-Open）：</strong>
                            <ul>
                                <li>试探状态，允许少量请求通过</li>
                                <li>如果请求成功，说明服务恢复，切换到关闭状态</li>
                                <li>如果请求失败，说明服务未恢复，切换回开启状态</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>熔断触发条件：</strong></p>
                    <ul>
                        <li><strong>失败率阈值：</strong>如：最近100个请求中，失败率达到50%</li>
                        <li><strong>异常比例：</strong>如：异常请求占比超过30%</li>
                        <li><strong>慢调用比例：</strong>如：响应时间超过500ms的请求占比超过30%</li>
                        <li><strong>异常数：</strong>如：最近1分钟内异常数超过50次</li>
                    </ul>
                    <p><strong>关键配置参数：</strong></p>
                    <ul>
                        <li><strong>滑动窗口大小：</strong>统计周期，如：100个请求或10秒</li>
                        <li><strong>失败率阈值：</strong>触发熔断的失败率，如：50%</li>
                        <li><strong>熔断开启时长：</strong>熔断后等待多久进入半开状态，如：10秒</li>
                        <li><strong>半开状态允许请求数：</strong>试探时允许通过的请求数，如：10个</li>
                    </ul>
                    <p><strong>熔断器实现框架：</strong></p>
                    <ul>
                        <li><strong>Resilience4j：</strong>轻量级，推荐用于Java项目</li>
                        <li><strong>Sentinel：</strong>阿里巴巴开源，功能强大，支持动态配置</li>
                        <li><strong>Hystrix：</strong>Netflix开源，已停止维护（不推荐新项目使用）</li>
                    </ul>
                    <p><strong>业务价值：</strong>防止级联故障（雪崩效应），快速失败避免资源耗尽，提供系统自愈能力。</p>
                `;
            } else if (type === 'degradation') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>降级处理</h4>
                    <p><strong>作用：</strong>当系统负载过高或服务故障时，主动关闭非核心功能，释放资源保障核心业务运行。</p>
                    <p><strong>核心思想：</strong>丢卒保帅，优先保障核心业务，牺牲次要功能。</p>
                    <p><strong>降级类型：</strong></p>
                    <ul>
                        <li><strong>功能降级：</strong>
                            <ul>
                                <li>关闭非核心功能（如：评论、点赞、推荐）</li>
                                <li>保留核心功能（如：下单、支付、查询）</li>
                                <li>示例：双十一期间关闭评论功能，保障下单功能</li>
                            </ul>
                        </li>
                        <li><strong>数据降级：</strong>
                            <ul>
                                <li>返回默认值（如：推荐列表返回空列表）</li>
                                <li>返回缓存数据（如：展示几分钟前的数据）</li>
                                <li>返回静态页面（如：系统繁忙提示页面）</li>
                            </ul>
                        </li>
                        <li><strong>服务降级：</strong>
                            <ul>
                                <li>拒绝部分请求（返回"系统繁忙，请稍后再试"）</li>
                                <li>限流（只允许部分请求通过）</li>
                                <li>延迟非实时任务（如：日志、统计）</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>降级触发条件：</strong></p>
                    <ul>
                        <li><strong>主动降级：</strong>
                            <ul>
                                <li>预知流量高峰（如：双11、秒杀活动）</li>
                                <li>系统维护（如：数据库升级）</li>
                                <li>人工开关（如：通过配置中心手动降级）</li>
                            </ul>
                        </li>
                        <li><strong>自动降级：</strong>
                            <ul>
                                <li>检测到系统负载过高（CPU使用率>80%）</li>
                                <li>检测到下游服务故障（超时、失败率过高）</li>
                                <li>熔断器触发（自动降级）</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>降级策略优先级：</strong></p>
                    <ol>
                        <li><strong>完全降级：</strong>直接返回错误提示（资源最省）</li>
                        <li><strong>默认值降级：</strong>返回预设的默认值（用户体验较好）</li>
                        <li><strong>缓存降级：</strong>返回缓存旧数据（实时性差但可用）</li>
                        <li><strong>限流降级：</strong>只允许部分请求通过（部分用户受影响）</li>
                    </ol>
                    <p><strong>降级实现要点：</strong></p>
                    <ul>
                        <li><strong>开关配置：</strong>通过配置中心（如Nacos、Apollo）动态控制降级开关</li>
                        <li><strong>降级接口：</strong>预先设计好降级接口的返回值</li>
                        <li><strong>监控告警：</strong>降级时发送告警通知运维人员</li>
                        <li><strong>快速恢复：</strong>故障恢复后自动或手动恢复服务</li>
                    </ul>
                    <p><strong>业务价值：</strong>在极端情况下保障核心业务可用，避免系统全面崩溃，提升系统容错能力。</p>
                `;
            } else if (type === 'local-cache') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>本地缓存（多级缓存L1）</h4>
                    <p><strong>作用：</strong>在应用进程内存中缓存热点数据，避免频繁查询Redis，降低Redis压力和网络开销。</p>
                    <p><strong>多级缓存架构：</strong></p>
                    <ul>
                        <li><strong>L1本地缓存：</strong>应用内存缓存（Guava/Caffeine），响应时间<1ms</li>
                        <li><strong>L2分布式缓存：</strong>Redis集群，响应时间1-5ms</li>
                        <li><strong>L3数据库：</strong>MySQL/PostgreSQL，响应时间10-100ms</li>
                    </ul>
                    <p><strong>缓存查询流程：</strong></p>
                    <ol>
                        <li>查询L1本地缓存，命中则返回（最快）</li>
                        <li>未命中则查询L2 Redis，命中则回填L1并返回</li>
                        <li>未命中则查询L3数据库，命中则回填L2、L1并返回</li>
                    </ol>
                    <p><strong>本地缓存实现：</strong></p>
                    <ul>
                        <li><strong>Guava Cache：</strong>Google开源，功能完善，适合Java项目</li>
                        <li><strong>Caffeine：</strong>基于Guava优化，性能更高，推荐使用</li>
                        <li><strong>ehcache：</strong>老牌缓存框架，支持磁盘持久化</li>
                    </ul>
                    <p><strong>本地缓存特点：</strong></p>
                    <ul>
                        <li><strong>优点：</strong>
                            <ul>
                                <li>速度极快（内存访问，无网络IO）</li>
                                <li>降低Redis压力（减少90%+查询量）</li>
                                <li>提升系统吞吐量</li>
                            </ul>
                        </li>
                        <li><strong>缺点：</strong>
                            <ul>
                                <li>容量受限（受限于JVM堆内存）</li>
                                <li>数据不一致（多实例本地缓存不同步）</li>
                                <li>重启丢失（应用重启后缓存清空）</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>适合本地缓存的数据：</strong></p>
                    <ul>
                        <li><strong>热点数据：</strong>访问频率极高的数据（如：首页配置、热门商品）</li>
                        <li><strong>静态配置：</strong>变化较少的配置数据（如：字典表、枚举值）</li>
                        <li><strong>计算结果：</strong>复杂计算的结果（如：统计数据、聚合数据）</li>
                    </ul>
                    <p><strong>不适合本地缓存的数据：</strong></p>
                    <ul>
                        <li><strong>实时性要求高：</strong>需要立即感知更新的数据</li>
                        <li><strong>数据量大：</strong>无法全部放入内存的数据</li>
                        <li><strong>个性化数据：</strong>每个用户数据不同，缓存命中率低</li>
                    </ul>
                    <p><strong>本地缓存配置：</strong></p>
                    <ul>
                        <li><strong>最大容量：</strong>如：10000条记录（防止OOM）</li>
                        <li><strong>过期时间：</strong>如：5分钟（确保数据最终一致性）</li>
                        <li><strong>淘汰策略：</strong>LRU（最近最少使用）或LFU（最不经常使用）</li>
                    </ul>
                    <p><strong>缓存一致性保证：</strong></p>
                    <ul>
                        <li><strong>定期刷新：</strong>设置较短的过期时间（如5分钟），自动重新加载</li>
                        <li><strong>主动失效：</strong>数据更新时，通过消息队列通知所有实例清除本地缓存</li>
                        <li><strong>版本号：</strong>为缓存数据增加版本号，版本不一致则重新加载</li>
                    </ul>
                    <p><strong>业务价值：</strong>通过多级缓存架构，大幅降低Redis和数据库压力，提升系统响应速度和吞吐量。</p>
                `;
            } else if (type === 'frontend') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>前端App/Web说明</h4>
                    <p><strong>作用：</strong>用户交互界面，负责接收用户输入，展示数据，与后端服务器进行通信。</p>
                    <p><strong>主要功能：</strong></p>
                    <ul>
                        <li><strong>用户交互：</strong>接收用户操作（点击、输入、滑动等）</li>
                        <li><strong>数据展示：</strong>将后端返回的数据以可视化的方式呈现给用户</li>
                        <li><strong>数据提交：</strong>收集用户输入的数据，发送到后端服务器</li>
                        <li><strong>状态管理：</strong>管理应用状态（如登录状态、用户信息等）</li>
                        <li><strong>本地缓存：</strong>缓存部分数据，提高用户体验</li>
                    </ul>
                    <p><strong>基础校验数据准备：</strong></p>
                    <ul>
                        <li><strong>Token（令牌）：</strong>根据用户ID生成的唯一标识，用于身份验证和授权</li>
                        <li><strong>Token位置：</strong>通常放在HTTP请求头（Header）中，如Authorization: Bearer <token></li>
                        <li><strong>其他必传数据：</strong>
                            <ul>
                                <li>用户ID：用于关联和识别用户</li>
                                <li>时间戳：防止重放攻击</li>
                                <li>请求签名：可选，用于额外安全性验证</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>业务数据准备：</strong></p>
                    <ul>
                        <li>表单数据（用户注册、信息修改等）</li>
                        <li>查询参数（搜索关键词、筛选条件等）</li>
                        <li>文件数据（头像上传、文档上传等）</li>
                        <li>操作指令（点赞、关注、分享等）</li>
                    </ul>
                    <p><strong>技术栈：</strong></p>
                    <ul>
                        <li><strong>移动端：</strong>原生iOS、Android、React Native、Flutter</li>
                        <li><strong>Web端：</strong>HTML、CSS、JavaScript、React、Vue、Angular</li>
                        <li><strong>小程序：</strong>微信小程序、支付宝小程序等</li>
                    </ul>
                    <p><strong>注意事项：</strong>确保数据格式正确，敏感信息加密传输，做好错误处理和用户提示。</p>
                `;
            } else if (type === 'nginx') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>Nginx网关说明</h4>
                    <p><strong>作用：</strong>作为反向代理和负载均衡器，接收前端请求，分发到后端服务。</p>
                    <p><strong>主要功能：</strong></p>
                    <ul>
                        <li>负载均衡：轮询、IP哈希、最少连接等算法。</li>
                        <li>SSL/TLS终止：处理HTTPS加密。</li>
                        <li>缓存：静态资源缓存，减少后端压力。</li>
                        <li>安全：防火墙、限流、DDoS防护。</li>
                        <li>日志记录：请求日志，便于监控。</li>
                    </ul>
                    <p><strong>配置示例：</strong>upstream backend { server 127.0.0.1:8080; server 127.0.0.1:8081; } location /api { proxy_pass http://backend; }</p>
                    <p><strong>优势：</strong>高性能、轻量、易扩展。</p>
                `;
            } else if (type === 'distribution') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>分发到后端服务说明</h4>
                    <p><strong>作用：</strong>将请求分发到多个后端服务器，实现负载均衡和高可用性。</p>
                    <p><strong>主要功能：</strong></p>
                    <ul>
                        <li>负载均衡：根据算法（如轮询、权重）分配请求到不同服务器。</li>
                        <li>故障转移：检测服务器健康状态，自动切换到可用服务器。</li>
                        <li>扩展性：支持动态添加/移除服务器。</li>
                        <li>性能优化：减少单点压力，提高响应速度。</li>
                    </ul>
                    <p><strong>示例：</strong>请求被分发到后端服务1、2、3中的一个或多个。</p>
                    <p><strong>优势：</strong>提高系统可用性和性能。</p>
                `;
            } else if (type === 'backend') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>后端服务高可用架构</h4>
                    <p><strong>服务分类说明：</strong></p>
                    <ul>
                        <li><strong>核心主后端服务：</strong>处理核心业务逻辑的主服务器，正常情况下处理所有请求。</li>
                        <li><strong>核心备用后端服务：</strong>核心业务的备用服务器，主服务故障时自动接管。</li>
                        <li><strong>拆分功能主后端服务：</strong>特定功能（如AI推理、高资源占用业务）的主服务器。</li>
                        <li><strong>拆分功能备用后端服务：</strong>特定功能的备用服务器，主服务故障时自动接管。</li>
                    </ul>
                    <p><strong>Nginx健康检查机制：</strong></p>
                    <ul>
                        <li><strong>主动健康检查：</strong>Nginx定期向后端服务发送健康检查请求（如/health端点）。</li>
                        <li><strong>被动健康检查：</strong>根据请求响应判断服务状态，连续失败max_fails次标记为不健康。</li>
                        <li><strong>自动故障转移：</strong>主服务故障时，Nginx自动将流量切换到备用服务（backup服务器）。</li>
                        <li><strong>恢复检测：</strong>故障服务恢复后，健康检查通过后重新加入负载均衡池。</li>
                    </ul>
                    <p><strong>Nginx配置示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
upstream backend_core {
    server 192.168.2.10:8080 max_fails=3 fail_timeout=30s;
    server 192.168.2.11:8080 backup;
}

upstream backend_ai {
    server 192.168.2.20:8080 max_fails=3 fail_timeout=30s;
    server 192.168.2.21:8080 backup;
}
                    </pre>
                    <p><strong>与Redis哨兵的区别：</strong></p>
                    <ul>
                        <li><strong>Redis哨兵：</strong>专门用于Redis数据库的自动故障转移，监控Redis主从节点。</li>
                        <li><strong>Nginx健康检查：</strong>用于应用层（后端服务）的负载均衡和故障转移。</li>
                        <li><strong>配合使用：</strong>Nginx负责后端服务的高可用，哨兵负责Redis的高可用，两者独立工作。</li>
                    </ul>
                    <p><strong>完整的高可用流程：</strong></p>
                    <ol>
                        <li>用户请求 → Nginx网关</li>
                        <li>Nginx通过健康检查选择健康的后端服务（主服务优先）</li>
                        <li>后端服务连接Redis哨兵获取主节点地址</li>
                        <li>操作Redis主节点或数据库</li>
                        <li>如果主服务故障，Nginx自动切换到备用服务</li>
                        <li>如果Redis主节点故障，哨兵自动提升从节点为主节点</li>
                        <li>后端服务从哨兵获取新的Redis主节点地址</li>
                    </ol>
                    <p><strong>优势：</strong>提高可用性、性能和安全性，实现应用层和数据层的双重高可用。</p>
                `;
            } else if (type === 'user-middle-tier') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>用户中台模块: 认证校验与ID生成</h4>
                    <p><strong>核心功能：</strong>生成全局唯一ID，用于用户注册时的手机号、名字、密码等信息。</p>
                    <p><strong>数据库设计：</strong></p>
                    <ul>
                        <li><strong>号段概念：</strong>预分配ID号段，避免每次生成都访问数据库。</li>
                        <li><strong>步长概念：</strong>每次申请的ID数量，控制性能。</li>
                        <li><strong>表结构：</strong>t_id_generate_config，管理所有业务的ID生成配置。</li>
                    </ul>
                    <p><strong>并发控制机制：</strong></p>
                    <ul>
                        <li><strong>信号量：</strong>保证只有一个线程申请新号段，避免并发冲突。</li>
                        <li><strong>乐观锁：</strong>version字段控制并发更新，只有匹配版本的线程才能成功。</li>
                        <li><strong>异步线程池：</strong>号段刷新异步执行，不阻塞ID生成。</li>
                        <li><strong>阈值策略：</strong>号段使用率超过75%时异步申请新号段。</li>
                    </ul>
                    <p><strong>核心机制：</strong>一张表管理所有业务的ID生成，支持扩展枚举(IdTypeEnum)添加新业务类型。</p>
                    <p><strong>数据隔离方式：</strong></p>
                    <table border="1" style="border-collapse: collapse; width: 100%;">
                        <thead>
                            <tr>
                                <th>id</th>
                                <th>remark</th>
                                <th>step</th>
                                <th>current_start</th>
                                <th>next_threshold</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>1</td>
                                <td>用户ID</td>
                                <td>1000</td>
                                <td>1000</td>
                                <td>2000</td>
                            </tr>
                            <tr>
                                <td>2</td>
                                <td>订单ID</td>
                                <td>5000</td>
                                <td>10000</td>
                                <td>15000</td>
                            </tr>
                            <tr>
                                <td>3</td>
                                <td>礼物ID</td>
                                <td>10000</td>
                                <td>100000</td>
                                <td>110000</td>
                            </tr>
                            <tr>
                                <td>4</td>
                                <td>房间ID</td>
                                <td>1000</td>
                                <td>1000000</td>
                                <td>1001000</td>
                            </tr>
                        </tbody>
                    </table>
                    <p><strong>示例：</strong>用户ID从1开始，订单ID从10000开始，各有独立号段和步长配置。</p>
                `;
            } else if (type === 'business-module') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>业务模块: 操作处理</h4>
                    <p><strong>模块功能：</strong>根据用户请求进行具体业务逻辑处理，区分是否需要数据库操作。</p>
                    <p><strong>处理逻辑：</strong></p>
                    <ul>
                        <li><strong>无需数据库操作：</strong>直接返回前端，数据闭环完成。</li>
                        <li><strong>需要数据库操作：</strong>进入Redis查询流程。</li>
                    </ul>
                    <p><strong>Redis查询命中后的循环处理：</strong></p>
                    <ul>
                        <li>数据返回业务模块，由业务模块再次处理。</li>
                        <li>业务模块判断是否需要进一步查询数据库。</li>
                        <li>如果需要，继续走数据库查询逻辑。</li>
                        <li>如果不需要，直接返回前端。</li>
                    </ul>
                    <p><strong>不需要读写查询数据库的操作（直接返回）：</strong></p>
                    <ul>
                        <li><strong>纯计算操作：</strong>如数学计算、数据格式转换、加密解密等。</li>
                        <li><strong>缓存查询：</strong>从Redis等缓存中获取数据，无需访问数据库。</li>
                        <li><strong>静态数据返回：</strong>返回配置数据、常量、枚举值等。</li>
                        <li><strong>外部API调用：</strong>调用第三方服务，处理结果后返回。</li>
                        <li><strong>状态检查：</strong>检查系统状态、服务可用性等。</li>
                    </ul>
                    <p><strong>需要读写查询数据库的操作（继续流程）：</strong></p>
                    <ul>
                        <li><strong>数据查询：</strong>从数据库读取用户数据、历史记录等。</li>
                        <li><strong>数据写入：</strong>插入新记录、更新现有数据、删除操作。</li>
                        <li><strong>事务处理：</strong>涉及多表操作，需要保证数据一致性。</li>
                        <li><strong>复杂业务逻辑：</strong>需要结合数据库数据进行判断和处理。</li>
                        <li><strong>数据验证：</strong>检查数据完整性、业务规则验证。</li>
                    </ul>
                    <p><strong>处理流程：</strong>根据操作类型决定是否进入读/写数据库流程，支持循环处理以优化性能。</p>
                `;
            } else if (type === 'redis-sentinel-cluster') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>Redis哨兵集群：获取主节点地址</h4>
                    <p><strong>作用：</strong>后端服务连接哨兵集群，获取当前Redis主节点的IP地址和端口。</p>
                    <p><strong>为什么需要哨兵集群：</strong></p>
                    <ul>
                        <li><strong>主节点可能变化：</strong>当主节点故障时，哨兵会自动将某个从节点提升为新的主节点。</li>
                        <li><strong>避免硬编码：</strong>应用不应该硬编码主节点地址，因为主节点地址会动态变化。</li>
                        <li><strong>高可用性：</strong>哨兵集群本身也是高可用的，即使部分哨兵故障，仍能提供服务。</li>
                    </ul>
                    <p><strong>Redis主从架构说明：</strong></p>
                    <ul>
                        <li><strong>Redis主节点（Master）：</strong>负责处理所有写操作，也可以处理读操作。数据写入主节点后，会自动同步到所有从节点。</li>
                        <li><strong>Redis从节点（Slave）：</strong>只能处理读操作，数据通过复制机制从主节点同步。一个主节点可以有多个从节点。</li>
                        <li><strong>主从复制关系：</strong>
                            <ul>
                                <li>从节点连接到主节点，发送SYNC命令</li>
                                <li>主节点创建快照（RDB文件），发送给从节点</li>
                                <li>主节点持续将写命令发送给从节点</li>
                                <li>从节点执行接收到的写命令，保持数据一致</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>哨兵与主从节点的关系：</strong></p>
                    <ul>
                        <li><strong>哨兵监控：</strong>哨兵节点独立于Redis数据节点，专门用于监控Redis主从节点的健康状态。</li>
                        <li><strong>哨兵数量：</strong>通常部署3个或5个哨兵节点（奇数个），避免脑裂问题。</li>
                        <li><strong>哨兵部署：</strong>哨兵节点应该部署在不同的物理机或容器中，确保哨兵本身的高可用。</li>
                        <li><strong>服务发现：</strong>后端服务不直接连接Redis主节点，而是先连接哨兵集群，询问"当前的主节点地址是什么？"</li>
                        <li><strong>地址更新：</strong>当主节点切换时，哨兵会通知后端服务新的主节点地址，或者后端服务定期向哨兵查询最新地址。</li>
                    </ul>
                    <p><strong>获取主节点地址的流程：</strong></p>
                    <ol>
                        <li>后端服务启动时，配置哨兵集群的地址列表（如：192.168.2.100:26379, 192.168.2.101:26379, 192.168.2.102:26379）</li>
                        <li>后端服务向哨兵发送命令：SENTINEL get-master-addr-by-name <master-name></li>
                        <li>哨兵返回当前主节点的IP和端口（如：192.168.2.10:6379）</li>
                        <li>后端服务连接到主节点，进行数据操作</li>
                        <li>如果主节点故障，后端服务会重新连接哨兵，获取新的主节点地址</li>
                    </ol>
                    <p><strong>客户端（后端服务）连接示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 伪代码示例
sentinel_hosts = ["192.168.2.100:26379", "192.168.2.101:26379", "192.168.2.102:26379"]
master_name = "mymaster"

// 连接到哨兵集群
master_info = sentinel.get_master_addr_by_name(master_name)
// 返回：{ip: "192.168.2.10", port: 6379}

// 连接到主节点
redis_client.connect(master_info.ip, master_info.port)
                    </pre>
                    <p><strong>重要配置：</strong></p>
                    <ul>
                        <li><strong>master-name：</strong>Redis主节点组的名称，在哨兵配置文件中定义（如：mymaster）</li>
                        <li><strong>quorum：</strong>确认主节点下线所需的最少哨兵数量</li>
                        <li><strong>down-after-milliseconds：</strong>哨兵认为主节点下线的超时时间</li>
                        <li><strong>failover-timeout：</strong>故障转移完成的最大时间</li>
                    </ul>
                    <p><strong>优势：</strong>实现Redis高可用，主节点故障时自动切换，应用无需人工干预即可获取新的主节点地址。</p>
                `;
            } else if (type === 'redis-sentinel-monitor') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>Redis哨兵监控：主从节点健康检查</h4>
                    <p><strong>作用：</strong>哨兵持续监控Redis主节点和所有从节点的健康状态，及时发现故障。</p>
                    <p><strong>监控对象：</strong></p>
                    <ul>
                        <li><strong>Redis主节点：</strong>监控主节点是否正常响应命令。</li>
                        <li><strong>Redis从节点：</strong>监控从节点是否正常复制主节点数据。</li>
                        <li><strong>哨兵节点间互相监控：</strong>哨兵节点之间也会互相通信，监控其他哨兵节点的健康状态。</li>
                    </ul>
                    <p><strong>监控机制详解：</strong></p>
                    <ol>
                        <li><strong>PING-PONG机制：</strong>
                            <ul>
                                <li>哨兵每隔1秒（可配置）向Redis主从节点发送PING命令</li>
                                <li>如果在down-after-milliseconds时间内（默认30秒）没有收到有效回复，认为该节点下线</li>
                                <li>有效回复包括：PONG、LOADING、MASTERDOWN等</li>
                            </ul>
                        </li>
                        <li><strong>主观下线（Subjectively Down, SDOWN）：</strong>
                            <ul>
                                <li>单个哨兵认为某个Redis节点下线（超过down-after-milliseconds时间未响应）</li>
                                <li>这是哨兵自己的判断，可能因为网络问题误判</li>
                                <li>主观下线后，哨兵会询问其他哨兵对该节点的判断</li>
                            </ul>
                        </li>
                        <li><strong>客观下线（Objectively Down, ODOWN）：</strong>
                            <ul>
                                <li>当足够多数量的哨兵（quorum个）都认为主节点下线时，确认主节点客观下线</li>
                                <li>需要达到配置文件中quorum的数量（通常设置为哨兵总数的大多数，如3个哨兵设置quorum为2）</li>
                                <li>客观下线确认后，才开始触发故障转移流程</li>
                                <li>从节点下线通常不需要客观下线确认，因为从节点故障不影响主服务</li>
                            </ul>
                        </li>
                        <li><strong>INFO命令监控：</strong>
                            <ul>
                                <li>哨兵每10秒向Redis节点发送INFO命令</li>
                                <li>获取Redis的运行状态、复制信息、从节点列表等</li>
                                <li>自动发现新的从节点</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>哨兵配置示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
# sentinel.conf
port 26379
sentinel monitor mymaster 192.168.2.10 6379 2
# 2表示至少2个哨兵同意才确认主节点下线

sentinel down-after-milliseconds mymaster 30000
# 30秒未响应认为主观下线

sentinel parallel-syncs mymaster 1
# 故障转移后，同时同步的从节点数量

sentinel failover-timeout mymaster 180000
# 故障转移超时时间：180秒
                    </pre>
                    <p><strong>监控流程图：</strong></p>
                    <ol>
                        <li>哨兵启动，连接到Redis主节点和从节点</li>
                        <li>哨兵定期发送PING命令检查节点健康</li>
                        <li>如果主节点未响应 → 主观下线（SDOWN）</li>
                        <li>哨兵询问其他哨兵对主节点的判断</li>
                        <li>如果足够多哨兵确认主节点下线 → 客观下线（ODOWN）</li>
                        <li>触发自动故障转移流程</li>
                    </ol>
                    <p><strong>信息发布与订阅：</strong></p>
                    <ul>
                        <li>哨兵通过Redis的发布/订阅机制，向所有连接的客户端发布主节点切换事件</li>
                        <li>客户端订阅哨兵的频道，实时获取主节点变化通知</li>
                        <li>常用频道：+switch-master（主节点切换）、+failover-end（故障转移结束）</li>
                    </ul>
                    <p><strong>优势：</strong>实现自动监控、自动发现故障、自动通知，确保Redis集群的高可用性。</p>
                `;
            } else if (type === 'redis-failover') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>Redis从节点提升为主节点：自动故障转移</h4>
                    <p><strong>什么是自动故障转移：</strong></p>
                    <ul>
                        <li>当Redis主节点故障时，哨兵自动从从节点中选择一个，提升为新的主节点。</li>
                        <li>整个过程完全自动化，无需人工干预。</li>
                        <li>故障转移期间，Redis服务会短暂不可用（通常几秒到几十秒）。</li>
                    </ul>
                    <p><strong>故障转移的完整流程：</strong></p>
                    <ol>
                        <li><strong>发现主节点故障：</strong>
                            <ul>
                                <li>哨兵通过PING命令发现主节点未响应</li>
                                <li>达到down-after-milliseconds时间后，标记为主观下线（SDOWN）</li>
                                <li>足够多的哨兵确认后，标记为客观下线（ODOWN）</li>
                            </ul>
                        </li>
                        <li><strong>选举领头哨兵（Leader Sentinel）：</strong>
                            <ul>
                                <li>确认主节点客观下线的哨兵发起领头哨兵选举</li>
                                <li>所有在线的哨兵投票选择领头哨兵</li>
                                <li>第一个获得多数票的哨兵成为领头哨兵</li>
                                <li>领头哨兵负责执行故障转移操作</li>
                            </ul>
                        </li>
                        <li><strong>选择新的主节点：</strong>
                            <ul>
                                <li>领头哨兵从所有健康的从节点中选择最优的从节点</li>
                                <li><strong>选择优先级：</strong>
                                    <ol>
                                        <li><strong>优先级（slave-priority）：</strong>配置文件中设置的优先级，值越高越优先（默认100）</li>
                                        <li><strong>复制偏移量（replication offset）：</strong>复制数据最完整的从节点（offset最大）优先</li>
                                        <li><strong>运行ID（run_id）：</strong>如果偏移量相同，选择run_id字典序较小的</li>
                                    </ol>
                                </li>
                                <li>排除不健康的从节点（断线时间超过down-after-milliseconds的10倍）</li>
                            </ul>
                        </li>
                        <li><strong>提升从节点为主节点：</strong>
                            <ul>
                                <li>领头哨兵向选中的从节点发送SLAVEOF NO ONE命令</li>
                                <li>该从节点停止复制，变身为新的主节点</li>
                                <li>新主节点开始接受写操作</li>
                            </ul>
                        </li>
                        <li><strong>重新配置其他从节点：</strong>
                            <ul>
                                <li>领头哨兵向其他从节点发送SLAVEOF命令</li>
                                <li>让所有从节点复制新的主节点</li>
                                <li>确保所有从节点的数据与新主节点同步</li>
                            </ul>
                        </li>
                        <li><strong>处理旧主节点：</strong>
                            <ul>
                                <li>如果旧主节点恢复上线，哨兵会将其配置为从节点</li>
                                <li>旧主节点开始复制新主节点的数据，保证数据一致性</li>
                            </ul>
                        </li>
                        <li><strong>通知应用：</strong>
                            <ul>
                                <li>哨兵通过发布/订阅机制发布主节点切换消息</li>
                                <li>应用收到通知后，更新连接配置，连接到新的主节点</li>
                                <li>应用也可以主动查询哨兵获取最新主节点地址</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>故障转移时间估算：</strong></p>
                    <ul>
                        <li>主观下线检测：30秒（down-after-milliseconds）</li>
                        <li>客观下线确认：几秒到几十秒（取决于哨兵通信）</li>
                        <li>领头哨兵选举：几秒</li>
                        <li>提升新主节点：几秒</li>
                        <li>从节点重新配置：几秒到几十秒</li>
                        <li><strong>总计：</strong>通常30-60秒完成整个故障转移</li>
                    </ul>
                    <p><strong>重要配置：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
# 从节点优先级配置（在redis.conf中）
slave-priority 100

# 优先级越高，越优先被选为新主节点
# 可以将性能好的从节点设置更高优先级
                    </pre>
                    <p><strong>故障转移期间的数据一致性：</strong></p>
                    <ul>
                        <li><strong>可能丢失数据：</strong>如果旧主节点在故障前还未将数据同步到从节点，这部分数据会丢失</li>
                        <li><strong>避免数据丢失：</strong>配置min-slaves-to-write和min-slaves-max-lag，确保至少N个从节点同步成功后才确认写操作</li>
                        <li><strong>数据恢复：</strong>旧主节点恢复后，会作为从节点同步新主节点的数据，丢弃未同步的写操作</li>
                    </ul>
                    <p><strong>优势：</strong>实现Redis主节点的自动切换，最大程度减少服务中断时间，提高系统可用性。</p>
                `;
            } else if (type === 'need-distributed-lock') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>需要分布式锁判断</h4>
                    <p><strong>作用：</strong>判断当前业务操作是否需要使用分布式锁来保证并发安全。</p>
                    <p><strong>需要分布式锁的场景：</strong></p>
                    <ul>
                        <li><strong>库存扣减：</strong>秒杀、抢购等场景，防止超卖</li>
                        <li><strong>金额操作：</strong>账户余额、积分变动，防止数据不一致</li>
                        <li><strong>资源分配：</strong>分配唯一资源（如：订单号、优惠券），防止重复</li>
                        <li><strong>状态机变更：</strong>订单状态流转，防止并发导致状态错乱</li>
                        <li><strong>定时任务：</strong>分布式定时任务，防止重复执行</li>
                    </ul>
                    <p><strong>不需要分布式锁的场景：</strong></p>
                    <ul>
                        <li><strong>纯查询操作：</strong>不涉及数据变更</li>
                        <li><strong>单机数据：</strong>使用JVM锁（synchronized、Lock）即可</li>
                        <li><strong>数据库唯一索引：</strong>通过数据库唯一约束保证（如：INSERT唯一键）</li>
                        <li><strong>乐观锁：</strong>通过版本号控制（CAS更新）</li>
                    </ul>
                    <p><strong>判断流程：</strong></p>
                    <ul>
                        <li><strong>是：</strong>尝试获取分布式锁，继续后续抢锁流程</li>
                        <li><strong>否：</strong>直接执行业务逻辑</li>
                    </ul>
                    <p><strong>业务价值：</strong>避免分布式环境下并发竞争导致的数据不一致问题，保证业务逻辑正确性。</p>
                `;
            } else if (type === 'distributed-lock') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>Redis分布式锁实现</h4>
                    <p><strong>作用：</strong>在分布式系统环境下，通过Redis实现跨进程、跨服务器的互斥锁，保证同一时刻只有一个节点能执行关键业务逻辑。</p>
                    <p><strong>核心原理：</strong>利用Redis的SETNX命令（SET if Not eXists），只有当key不存在时才能设置成功，从而实现锁机制。</p>
                    <p><strong>基础实现（SETNX）：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 加锁
SET lock:order:123 "unique_value" NX PX 30000

// NX: 仅当key不存在时设置（互斥）
// PX: 设置过期时间30000ms（防止死锁）
// unique_value: 唯一标识（用于解锁时校验，防止误删其他线程的锁）

// 执行业务逻辑
doBusiness()

// 解锁（Lua脚本保证原子性）
if redis.call("get", KEYS[1]) == ARGV[1] then
    return redis.call("del", KEYS[1])
else
    return 0
end
                    </pre>
                    <p><strong>关键要素：</strong></p>
                    <ul>
                        <li><strong>唯一标识：</strong>每个锁请求必须有唯一值（如：UUID + 线程ID），解锁时校验</li>
                        <li><strong>过期时间：</strong>必须设置过期时间，防止获取锁后进程崩溃导致死锁</li>
                        <li><strong>原子性：</strong>加锁和解锁必须保证原子操作（SET NX PX、Lua脚本）</li>
                    </ul>
                    <p><strong>高级实现（Redlock算法）：</strong></p>
                    <ul>
                        <li><strong>问题：</strong>单节点Redis故障时，锁可能丢失</li>
                        <li><strong>解决方案：</strong>同时向N个（通常5个）独立的Redis节点申请锁</li>
                        <li><strong>成功条件：</strong>大多数节点（N/2 + 1）加锁成功，且耗时小于锁的有效时间</li>
                        <li><strong>解锁：</strong>向所有节点发送解锁请求</li>
                    </ul>
                    <p><strong>锁续期机制（Watch Dog）：</strong></p>
                    <ul>
                        <li><strong>问题：</strong>业务执行时间超过锁的过期时间，锁自动释放导致其他线程获取锁</li>
                        <li><strong>解决：</strong>后台线程定期检测业务执行状态，如果未执行完则延长锁的过期时间</li>
                        <li><strong>实现：</strong>Redisson框架自动支持Watch Dog机制（默认锁30秒，每10秒续期一次）</li>
                    </ul>
                    <p><strong>可重入锁：</strong></p>
                    <ul>
                        <li><strong>概念：</strong>同一个线程可以多次获取同一把锁</li>
                        <li><strong>实现：</strong>通过计数器记录重入次数，加锁时+1，解锁时-1，计数为0时真正释放锁</li>
                        <li><strong>场景：</strong>递归调用、同一线程内的多个方法需要同一把锁</li>
                    </ul>
                    <p><strong>分布式锁框架：</strong></p>
                    <ul>
                        <li><strong>Redisson：</strong>推荐，支持可重入锁、公平锁、读写锁、红锁（Redlock）</li>
                        <li><strong>Redis分布式锁（自研）：</strong>基于SET NX + Lua实现，适合简单场景</li>
                    </ul>
                    <p><strong>使用注意事项：</strong></p>
                    <ul>
                        <li><strong>锁粒度：</strong>尽量细粒度（如：锁订单ID而非整个用户），减少锁竞争</li>
                        <li><strong>锁超时：</strong>根据业务执行时间合理设置（太短可能导致业务未执行完就释放）</li>
                        <li><strong>锁等待：</strong>设置合理的等待时间，避免无限等待阻塞线程</li>
                        <li><strong>异常处理：</strong>业务异常时也要释放锁（使用try-finally）</li>
                    </ul>
                    <p><strong>业务价值：</strong>保证分布式环境下的并发安全，防止超卖、数据不一致等严重问题，是高并发业务的核心保障机制。</p>
                `;
            } else if (type === 'grab-lock-success') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>抢锁成功/失败判断</h4>
                    <p><strong>核心作用：</strong>判断分布式锁获取是否成功，决定后续执行路径。<strong>这是保证并发安全的关键节点，是防止超卖、数据不一致、重复操作等严重问题的第一道防线。</strong></p>

                    <p><strong>为什么抢锁如此重要：</strong></p>
                    <ul>
                        <li><strong>防止超卖：</strong>秒杀场景下，100个商品可能有10000个用户同时抢购，如果没有锁，可能超卖出1000个商品，造成严重损失</li>
                        <li><strong>防止重复扣款：</strong>用户双击支付按钮，如果没有锁，可能扣款两次，引发客诉和资金风险</li>
                        <li><strong>防止数据覆盖：</strong>多个实例同时修改同一条数据，如果没有锁，后执行的数据会覆盖前面的修改，导致数据丢失</li>
                        <li><strong>保证状态机正确性：</strong>订单状态流转（待支付→已支付→发货），如果没有锁，可能状态错乱（如：直接从待支付跳到发货）</li>
                    </ul>

                    <p><strong>抢锁成功（是）：</strong></p>
                    <ul>
                        <li><strong>含义：</strong>当前实例成功获取到分布式锁，获得执行业务逻辑的<strong>唯一权限</strong></li>
                        <li><strong>排他性保证：</strong>在锁的有效期内（如30秒），<strong>同一时刻只有一个实例</strong>在执行该业务，其他实例无法获取锁</li>
                        <li><strong>后续操作：</strong>进入"执行业务逻辑"节点，进行数据校验、数据操作、业务计算、后续处理</li>
                        <li><strong>释放时机：</strong>业务逻辑执行完毕后立即释放锁（通过finally块确保），其他等待的实例才能抢锁</li>
                    </ul>

                    <p><strong>抢锁失败（否）：</strong></p>
                    <ul>
                        <li><strong>含义：</strong>锁已被其他实例持有，当前实例无法获取锁（其他实例正在执行相同业务）</li>
                        <li><strong>原因：</strong>其他实例正在操作同一个资源（如：同一个订单的库存扣减、同一个用户的账户余额修改）</li>
                        <li><strong>后续操作：</strong>进入"等待重试"流程，等待一段时间后重新尝试抢锁</li>
                        <li><strong>用户体验：</strong>根据业务场景选择快速失败（返回"系统繁忙"）或等待重试</li>
                    </ul>

                    <p><strong>典型应用场景：</strong></p>
                    <ul>
                        <li><strong>秒杀扣库存：</strong>100个商品，10000个用户同时抢购，只有抢到锁的前100个用户能成功购买，其他用户看到"商品已售罄"</li>
                        <li><strong>账户转账：</strong>用户A向用户B转账100元，只有抢到锁的实例能操作账户A和账户B，防止重复扣款或余额不一致</li>
                        <li><strong>订单状态流转：</strong>订单从"待支付"变为"已支付"，只有抢到锁的实例能修改订单状态，防止状态错乱</li>
                        <li><strong>优惠券发放：</strong>1000张优惠券，10000个用户同时抢，只有抢到锁的前1000个用户能领到，其他用户看到"已领完"</li>
                    </ul>

                    <p><strong>性能优化策略：</strong></p>
                    <ul>
                        <li><strong>快速失败：</strong>抢锁失败立即返回错误，不等待（适合高并发抢购场景，用户体验好，避免长时间等待）</li>
                        <li><strong>等待重试：</strong>抢锁失败后等待一段时间再重试（适合对实时性要求不高的场景，提高成功率）</li>
                        <li><strong>指数退避：</strong>每次失败后等待时间加倍（100ms → 200ms → 400ms），避免频繁重试冲击系统</li>
                    </ul>

                    <p><strong>业务价值：</strong>抢锁成功/失败判断是分布式环境下并发安全的<strong>核心保障机制</strong>，通过锁机制确保同一时刻只有一个实例能操作关键资源，防止超卖、数据不一致、重复操作等严重问题，是高并发业务（秒杀、抢购、支付）不可或缺的组件。</p>
                `;
            } else if (type === 'execute-business') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>执行业务逻辑</h4>
                    <p><strong>作用：</strong>在获得分布式锁后，执行具体的业务逻辑操作。</p>
                    <p><strong>执行内容：</strong></p>
                    <ul>
                        <li><strong>数据校验：</strong>校验业务规则（如：库存是否充足、账户余额是否足够）</li>
                        <li><strong>数据操作：</strong>更新数据库、更新缓存</li>
                        <li><strong>业务计算：</strong>金额计算、积分计算、状态流转</li>
                        <li><strong>后续处理：</strong>发送消息、触发下游服务</li>
                    </ul>
                    <p><strong>执行要点：</strong></p>
                    <ul>
                        <li><strong>快速执行：</strong>业务逻辑尽量简短高效，避免长时间占用锁</li>
                        <li><strong>异常处理：</strong>业务异常时及时释放锁，避免锁一直被占用</li>
                        <li><strong>事务保证：</strong>确保数据库操作和Redis操作的一致性</li>
                        <li><strong>锁释放：</strong>业务执行完毕后立即释放锁（通过finally块确保）</li>
                    </ul>
                    <p><strong>典型业务场景：</strong></p>
                    <ul>
                        <li><strong>秒杀扣库存：</strong>查询库存 → 判断是否充足 → 扣减库存 → 创建订单</li>
                        <li><strong>账户转账：</strong>查询账户余额 → 判断是否充足 → 扣减金额 → 增加对方账户余额</li>
                        <li><strong>状态机变更：</strong>查询当前状态 → 校验是否允许流转 → 更新状态为下一状态</li>
                    </ul>
                    <p><strong>业务价值：</strong>在锁保护下执行关键业务逻辑，保证并发安全和数据一致性。</p>
                `;
            } else if (type === 'wait-retry') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>等待重试</h4>
                    <p><strong>作用：</strong>当抢锁失败时，等待一段时间后重新尝试获取锁。</p>
                    <p><strong>等待策略：</strong></p>
                    <ul>
                        <li><strong>固定间隔重试：</strong>每隔固定时间（如100ms）重试一次</li>
                        <li><strong>指数退避：</strong>每次失败后等待时间加倍（100ms → 200ms → 400ms），避免频繁重试冲击系统</li>
                        <li><strong>随机间隔：</strong>等待时间加上随机值，避免多个实例同时重试造成惊群效应</li>
                    </ul>
                    <p><strong>重试次数限制：</strong></p>
                    <ul>
                        <li>设置最大重试次数（如：3次、5次），避免无限重试消耗资源</li>
                        <li>超过最大重试次数后，返回"系统繁忙，请稍后再试"</li>
                    </ul>
                    <p><strong>业务提示：</strong></p>
                    <ul>
                        <li><strong>前端提示：</strong>"操作太频繁，请稍后再试"</li>
                        <li><strong>用户体验：</strong>根据业务场景选择合适的重试策略（如：秒杀场景建议快速失败）</li>
                    </ul>
                    <p><strong>业务价值：</strong>通过合理的重试机制，平衡用户体验和系统负载，避免因锁竞争导致的用户体验下降。</p>
                `;
            } else if (type === 'need-db') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>需要数据库操作判断</h4>
                    <p><strong>作用：</strong>判断当前业务操作是否需要访问数据库。</p>
                    <p><strong>判断依据：</strong></p>
                    <ul>
                        <li><strong>需要数据库：</strong>涉及数据查询、数据写入、事务处理等操作。</li>
                        <li><strong>不需要数据库：</strong>纯计算、缓存查询、静态数据返回、外部API调用等。</li>
                    </ul>
                    <p><strong>处理流程：</strong></p>
                    <ul>
                        <li><strong>否：</strong>直接返回结果给前端，完成请求闭环。</li>
                        <li><strong>是：</strong>进入读写操作判断，继续后续流程。</li>
                    </ul>
                    <p><strong>优化目的：</strong>避免不必要的数据库访问，提高响应速度，降低数据库压力。</p>
                `;
            } else if (type === 'read-write') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>读/写操作判断</h4>
                    <p><strong>作用：</strong>区分读操作和写操作，采用不同的处理策略。</p>
                    <p><strong>读操作流程：</strong></p>
                    <ol>
                        <li>通过Redis哨兵获取主节点地址</li>
                        <li>查询Redis主节点缓存</li>
                        <li>命中：直接返回数据</li>
                        <li>未命中：查询数据库，更新Redis缓存</li>
                    </ol>
                    <p><strong>写操作流程：</strong></p>
                    <ol>
                        <li>通过Redis哨兵获取主节点地址</li>
                        <li>检查Redis是否有相关数据</li>
                        <li>有数据：更新Redis和数据库（事务操作）</li>
                        <li>无数据：查询数据库，更新数据库和Redis（事务操作）</li>
                    </ol>
                    <p><strong>注意事项：</strong></p>
                    <ul>
                        <li>写操作必须操作主节点，确保数据一致性</li>
                        <li>读写分离时，读操作可以从节点获取数据</li>
                        <li>事务操作保证原子性，要么全部成功，要么全部失败</li>
                    </ul>
                `;
            } else if (type === 'redis-read-query') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>Redis主节点查询：读操作缓存查询</h4>
                    <p><strong>作用：</strong>后端服务从Redis主节点查询数据，判断缓存中是否有所需数据。</p>
                    <p><strong>查询流程：</strong></p>
                    <ol>
                        <li><strong>连接Redis主节点：</strong>
                            <ul>
                                <li>后端服务通过哨兵获取主节点地址</li>
                                <li>建立TCP连接到Redis主节点（默认端口6379）</li>
                                <li>发送AUTH命令进行身份验证（如果配置了密码）</li>
                                <li>选择数据库（SELECT命令，默认DB 0）</li>
                            </ul>
                        </li>
                        <li><strong>发送查询命令：</strong>
                            <ul>
                                <li><strong>单值查询：</strong>GET key（查询字符串）</li>
                                <li><strong>哈希查询：</strong>HGET hash key field（查询哈希字段）</li>
                                <li><strong>列表查询：</strong>LRANGE list start stop（查询列表范围）</li>
                                <li><strong>集合查询：</strong>SMEMBERS set（查询集合所有成员）</li>
                                <li><strong>有序集合：</strong>ZRANGE zset start stop（查询有序集合范围）</li>
                            </ul>
                        </li>
                        <li><strong>判断查询结果：</strong>
                            <ul>
                                <li><strong>命中（Cache Hit）：</strong>Redis返回了数据（非空、非nil）</li>
                                <li><strong>未命中（Cache Miss）：</strong>Redis返回nil或key不存在</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>什么是命中（Cache Hit）：</strong></p>
                    <ul>
                        <li><strong>定义：</strong>Redis主节点的内存中存在所查询的key，并且返回了对应的value</li>
                        <li><strong>体现：</strong>GET命令返回了具体的数据（如字符串、数字、JSON等），而不是nil</li>
                        <li><strong>返回值示例：</strong>
                            <ul>
                                <li>字符串："user:1001" → "张三"</li>
                                <li>哈希："HGET user:1001 name" → "张三"</li>
                                <li>JSON："GET order:5001" → '{"id":5001,"status":"paid"}'</li>
                            </ul>
                        </li>
                        <li><strong>性能优势：</strong>内存读取，微秒级响应（通常<1ms）</li>
                        <li><strong>业务处理：</strong>直接返回数据给业务模块，跳过数据库查询</li>
                    </ul>
                    <p><strong>什么是未命中（Cache Miss）：</strong></p>
                    <ul>
                        <li><strong>定义：</strong>Redis主节点的内存中不存在所查询的key，或者key已过期</li>
                        <li><strong>体现：</strong>GET命令返回nil（空值），表示key不存在</li>
                        <li><strong>返回值示例：</strong>
                            <ul>
                                <li>查询不存在的key："GET user:9999" → (nil)</li>
                                <li>查询已过期的key："GET session:expired" → (nil)</li>
                            </ul>
                        </li>
                        <li><strong>未命中原因：</strong>
                            <ol>
                                <li>数据从未写入Redis（首次访问）</li>
                                <li>数据已过期（TTL到期，Redis自动删除）</li>
                                <li>数据被主动删除（DEL命令或FLUSHDB）</li>
                                <li>内存不足，Redis淘汰了该key（LRU/LFU策略）</li>
                            </ol>
                        </li>
                        <li><strong>业务处理：</strong>需要进入"数据库查询"流程，从数据库加载数据</li>
                    </ul>
                    <p><strong>查询示例代码：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 伪代码：Redis查询
redis_client.connect(master_ip, master_port)
redis_client.auth(password)

// 查询用户信息
user_key = "user:" + user_id
user_data = redis_client.get(user_key)

if (user_data != null) {
    // 命中：缓存中有数据
    parse_json(user_data)
    return user_data  // 直接返回
} else {
    // 未命中：缓存中无数据
    return null  // 进入数据库查询流程
}
                    </pre>
                    <p><strong>缓存穿透保护：</strong></p>
                    <ul>
                        <li><strong>空值缓存：</strong>如果数据库中也不存在该数据，将key值设为空字符串或特殊标记，防止频繁查询数据库</li>
                        <li><strong>布隆过滤器：</strong>使用布隆过滤器快速判断key是否可能存在，避免查询不存在的key</li>
                        <li><strong>限流降级：</strong>对于高频未命中的查询，限制查询频率，避免压垮数据库</li>
                    </ul>
                    <p><strong>性能指标：</strong></p>
                    <ul>
                        <li><strong>命中率：</strong>命中的查询次数 / 总查询次数（通常要求>80%）</li>
                        <li><strong>响应时间：</strong>Redis查询通常<1ms，数据库查询通常10-100ms</li>
                        <li><strong>QPS提升：</strong>使用Redis缓存后，QPS可提升10-100倍</li>
                    </ul>
                    <p><strong>业务价值：</strong>通过缓存命中避免数据库查询，大幅提升查询性能，降低数据库压力。</p>
                `;
            } else if (type === 'redis-write-check') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>Redis主节点检查：写操作数据检查</h4>
                    <p><strong>作用：</strong>后端服务在执行写操作前，检查Redis主节点中是否已存在相关数据，决定后续处理策略。</p>
                    <p><strong>检查流程：</strong></p>
                    <ol>
                        <li><strong>连接Redis主节点：</strong>
                            <ul>
                                <li>通过哨兵获取主节点地址</li>
                                <li>建立连接并进行身份验证</li>
                                <li>选择目标数据库</li>
                            </ul>
                        </li>
                        <li><strong>执行检查命令：</strong>
                            <ul>
                                <li><strong>EXISTS key：</strong>检查key是否存在（返回1表示存在，0表示不存在）</li>
                                <li><strong>GET key：</strong>获取key的当前值（返回数据或nil）</li>
                                <li><strong>HGETALL hash：</strong>获取哈希表的所有字段和值</li>
                                <li><strong>TTL key：</strong>获取key的剩余过期时间</li>
                            </ul>
                        </li>
                        <li><strong>判断检查结果：</strong>
                            <ul>
                                <li><strong>有数据：</strong>Redis中存在该key，需要执行更新操作</li>
                                <li><strong>无数据：</strong>Redis中不存在该key，需要执行插入操作</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>有数据场景（Update）：</strong></p>
                    <ul>
                        <li><strong>定义：</strong>Redis主节点内存中已存在所查询的key，并且有对应的value</li>
                        <li><strong>体现：</strong>EXISTS命令返回1，GET命令返回了具体数据</li>
                        <li><strong>业务逻辑：</strong>
                            <ol>
                                <li>更新Redis主节点中的数据（SET/HMSET等命令）</li>
                                <li>同时更新数据库中的数据（事务操作）</li>
                                <li>确保Redis和数据库的数据一致性</li>
                            </ol>
                        </li>
                        <li><strong>示例：</strong>
                            <ul>
                                <li>用户修改信息："user:1001"已存在，更新name字段</li>
                                <li>订单状态变更："order:5001"已存在，更新status为"shipped"</li>
                                <li>库存扣减："inventory:product:100"已存在，更新count字段</li>
                            </ul>
                        </li>
                        <li><strong>操作命令：</strong>
                            <ul>
                                <li>字符串：SET key value</li>
                                <li>哈希：HMSET hash field1 value1 field2 value2</li>
                                <li>JSON：JSON.SET key $ json_value</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>无数据场景（Insert）：</strong></p>
                    <ul>
                        <li><strong>定义：</strong>Redis主节点内存中不存在所查询的key</li>
                        <li><strong>体现：</strong>EXISTS命令返回0，GET命令返回nil</li>
                        <li><strong>业务逻辑：</strong>
                            <ol>
                                <li>查询数据库，确认数据是否存在（可能数据只存在于数据库，不在Redis）</li>
                                <li>如果数据库存在：更新数据库数据，并写入Redis</li>
                                <li>如果数据库不存在：插入新数据到数据库，并写入Redis</li>
                            </ol>
                        </li>
                        <li><strong>示例：</strong>
                            <ul>
                                <li>新用户注册："user:1002"不存在，查询DB确认，然后插入DB和Redis</li>
                                <li>新订单创建："order:5002"不存在，插入DB订单表，写入Redis</li>
                                <li>缓存预热：系统启动后首次访问，数据只在DB中，需要加载到Redis</li>
                            </ul>
                        </li>
                        <li><strong>操作命令：</strong>
                            <ul>
                                <li>先查询DB：SELECT * FROM users WHERE id = 1002</li>
                                <li>再写入Redis：SET key value EX seconds（设置过期时间）</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>写操作示例代码：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 伪代码：写操作检查
redis_client.connect(master_ip, master_port)

// 检查数据是否存在
user_key = "user:" + user_id
exists = redis_client.exists(user_key)

if (exists == 1) {
    // 有数据：更新操作
    old_data = redis_client.get(user_key)
    new_data = update_user_info(old_data, params)

    // 事务操作：更新Redis和数据库
    begin_transaction()
    redis_client.set(user_key, new_data)
    db.execute("UPDATE users SET name=? WHERE id=?", new_data.name, user_id)
    commit_transaction()
} else {
    // 无数据：查询DB + 插入操作
    user = db.query("SELECT * FROM users WHERE id=?", user_id)

    if (user != null) {
        // 数据在DB中，更新DB和Redis
        begin_transaction()
        db.execute("UPDATE users SET ... WHERE id=?", user_id)
        redis_client.set(user_key, user_data)
        commit_transaction()
    } else {
        // 数据不存在，插入DB和Redis
        begin_transaction()
        db.execute("INSERT INTO users ...")
        redis_client.set(user_key, new_user_data)
        commit_transaction()
    }
}
                    </pre>
                    <p><strong>并发控制：</strong></p>
                    <ul>
                        <li><strong>乐观锁：</strong>使用WATCH命令监控key，如果在事务执行期间key被修改，事务失败</li>
                        <li><strong>分布式锁：</strong>使用SETNX命令实现分布式锁，避免并发写冲突</li>
                        <li><strong>CAS机制：</strong>Compare-And-Set，先获取版本号，更新时检查版本号是否变化</li>
                    </ul>
                    <p><strong>数据一致性保证：</strong></p>
                    <ul>
                        <li><strong>双写一致性：</strong>使用事务确保Redis和数据库同时成功或同时失败</li>
                        <li><strong>最终一致性：</strong>如果双写失败，通过定时刷新或MQ消息补偿</li>
                        <li><strong>主从同步：</strong>写操作只写入主节点，主节点自动同步到从节点</li>
                    </ul>
                    <p><strong>业务价值：</strong>通过检查Redis中是否有数据，决定执行更新还是插入操作，保证数据一致性，同时利用缓存提升性能。</p>
                `;
            } else if (type === 'cache-hit') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>命中：缓存数据存在</h4>
                    <p><strong>定义：</strong>Redis主节点内存中存在所查询的key，并且返回了有效的数据。</p>
                    <p><strong>命中体现：</strong></p>
                    <ul>
                        <li><strong>命令返回：</strong>GET key 返回了具体的数据（字符串、数字、JSON等），而不是nil</li>
                        <li><strong>返回值：</strong>
                            <ul>
                                <li>字符串：返回value内容，如"张三"、"12345"</li>
                                <li>JSON：返回JSON字符串，如'{"id":1001,"name":"张三"}'</li>
                                <li>数字：返回数字值，如100、3.14</li>
                            </ul>
                        </li>
                        <li><strong>非空判断：</strong>返回值 != null && 返回值 != "" && 返回值 != "(nil)"</li>
                    </ul>
                    <p><strong>命中原因：</strong></p>
                    <ul>
                        <li>数据之前被写入Redis，并且还未过期</li>
                        <li>数据的TTL（Time To Live）未到期，Redis未自动删除</li>
                        <li>数据没有被主动删除（DEL命令或FLUSHDB）</li>
                        <li>内存充足，Redis未因内存压力淘汰该key</li>
                    </ul>
                    <p><strong>命中后的处理流程：</strong></p>
                    <ol>
                        <li>后端服务解析Redis返回的数据</li>
                        <li>如果数据是JSON字符串，反序列化为对象</li>
                        <li>将数据返回给业务模块</li>
                        <li>业务模块进行后续业务逻辑处理</li>
                        <li>最终返回给前端，完成请求</li>
                    </ol>
                    <p><strong>性能优势：</strong></p>
                    <ul>
                        <li><strong>响应时间：</strong>Redis内存读取通常<1ms，比数据库快10-100倍</li>
                        <li><strong>吞吐量：</strong>Redis单节点QPS可达10万+，数据库通常只有几千</li>
                        <li><strong>数据库减压：</strong>命中一次就减少一次数据库查询</li>
                    </ul>
                    <p><strong>命中示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 查询用户ID=1001的信息
GET user:1001

// 命中返回：
'{"id":1001,"name":"张三","age":25,"email":"zhangsan@example.com"}'

// 后端服务解析JSON，返回给业务模块
user_info = JSON.parse(redis_return)
// user_info = {id: 1001, name: "张三", age: 25, email: "zhangsan@example.com"}

// 直接返回给前端，无需查询数据库
                    </pre>
                    <p><strong>业务价值：</strong>缓存命中直接返回数据，跳过数据库查询，大幅提升性能，降低数据库压力。</p>
                `;
            } else if (type === 'cache-miss') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>未命中：缓存数据不存在</h4>
                    <p><strong>定义：</strong>Redis主节点内存中不存在所查询的key，或者key已过期被删除。</p>
                    <p><strong>未命中体现：</strong></p>
                    <ul>
                        <li><strong>命令返回：</strong>GET key 返回nil（空值）</li>
                        <li><strong>返回值：</strong>
                            <ul>
                                <li>Redis CLI显示：(nil)</li>
                                <li>Redis客户端库返回：null、None、nil等</li>
                            </ul>
                        </li>
                        <li><strong>空值判断：</strong>返回值 == null || 返回值 == "" || 返回值 == "(nil)"</li>
                    </ul>
                    <p><strong>未命中原因：</strong></p>
                    <ol>
                        <li><strong>首次访问：</strong>
                            <ul>
                                <li>数据从未写入过Redis（第一次访问该数据）</li>
                                <li>系统刚启动，缓存为空（冷启动）</li>
                            </ul>
                        </li>
                        <li><strong>数据过期：</strong>
                            <ul>
                                <li>数据的TTL（Time To Live）已到期</li>
                                <li>Redis自动删除了过期的key</li>
                                <li>示例：验证码过期、Session过期</li>
                            </ul>
                        </li>
                        <li><strong>数据被删除：</strong>
                            <ul>
                                <li>应用程序主动删除（DEL命令）</li>
                                <li>管理员手动清空缓存（FLUSHDB）</li>
                                <li>数据更新时删除旧缓存</li>
                            </ul>
                        </li>
                        <li><strong>内存淘汰：</strong>
                            <ul>
                                <li>Redis内存不足，触发淘汰策略</li>
                                <li>LRU（Least Recently Used）淘汰最少使用的key</li>
                                <li>LFU（Least Frequently Used）淘汰访问频率最低的key</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>未命中后的处理流程（缓存回源）：</strong></p>
                    <ol>
                        <li><strong>查询数据库：</strong>
                            <ul>
                                <li>执行SQL查询，从数据库获取数据</li>
                                <li>示例：SELECT * FROM users WHERE id = 1001</li>
                            </ul>
                        </li>
                        <li><strong>判断数据库结果：</strong>
                            <ul>
                                <li><strong>数据库有数据：</strong>进入"更新Redis主节点"流程</li>
                                <li><strong>数据库无数据：</strong>返回空结果或错误</li>
                            </ul>
                        </li>
                        <li><strong>写入Redis缓存：</strong>
                            <ul>
                                <li>将数据库查询结果写入Redis主节点</li>
                                <li>设置TTL过期时间，避免数据永久占用内存</li>
                                <li>示例：SET user:1001 '{...}' EX 3600（1小时过期）</li>
                            </ul>
                        </li>
                        <li><strong>返回数据：</strong>
                            <ul>
                                <li>将数据返回给业务模块</li>
                                <li>最终返回给前端</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>未命中示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 查询用户ID=9999的信息（首次访问）
GET user:9999

// 未命中返回：
(nil)

// 后端服务处理：
if (redis_result == null) {
    // 查询数据库
    user = db.query("SELECT * FROM users WHERE id = 9999")

    if (user != null) {
        // 写入Redis缓存，设置1小时过期
        redis_client.set("user:9999", user_json, "EX", 3600)
        return user
    } else {
        // 数据库也没有，返回错误
        return "用户不存在"
    }
}
                    </pre>
                    <p><strong>缓存未命中优化策略：</strong></p>
                    <ul>
                        <li><strong>缓存预热：</strong>系统启动时，提前将热点数据加载到Redis</li>
                        <li><strong>延长TTL：</strong>合理设置过期时间，减少未命中</li>
                        <li><strong>互斥锁：</strong>高并发未命中时，只允许一个线程查询数据库，其他线程等待</li>
                        <li><strong>布隆过滤器：</strong>快速判断key是否存在，避免查询不存在的key</li>
                        <li><strong>空值缓存：</strong>数据库中不存在的数据，也缓存空值，TTL设置较短（如5分钟）</li>
                    </ul>
                    <p><strong>性能影响：</strong></p>
                    <ul>
                        <li>未命中需要查询数据库，响应时间从<1ms增加到10-100ms</li>
                        <li>如果未命中率过高，会失去缓存的意义，反而增加复杂度</li>
                        <li>建议命中率>80%，否则需要优化缓存策略</li>
                    </ul>
                    <p><strong>业务价值：</strong>未命中触发数据库查询，并更新缓存，确保数据最终一致性，同时为后续请求提供缓存数据。</p>
                `;
            } else if (type === 'db-query') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>数据库查询：从持久化存储获取数据</h4>
                    <p><strong>作用：</strong>当Redis缓存未命中时，后端服务从数据库查询数据，确保持久化数据的读取。</p>
                    <p><strong>查询流程：</strong></p>
                    <ol>
                        <li><strong>建立数据库连接：</strong>
                            <ul>
                                <li>从连接池获取一个数据库连接（避免每次创建新连接）</li>
                                <li>连接池配置：最大连接数、最小空闲连接数、连接超时时间</li>
                                <li>执行身份验证（用户名、密码）</li>
                                <li>选择目标数据库（USE database_name）</li>
                            </ul>
                        </li>
                        <li><strong>构建SQL查询：</strong>
                            <ul>
                                <li>根据业务需求构建SELECT语句</li>
                                <li>使用参数化查询（PreparedStatement），防止SQL注入</li>
                                <li>设置查询条件（WHERE子句）、排序（ORDER BY）、分页（LIMIT）</li>
                            </ul>
                        </li>
                        <li><strong>执行查询：</strong>
                            <ul>
                                <li>发送SQL语句到数据库服务器</li>
                                <li>数据库解析SQL、优化查询计划、执行查询</li>
                                <li>从磁盘或缓冲池读取数据</li>
                                <li>返回查询结果集（ResultSet）</li>
                            </ul>
                        </li>
                        <li><strong>处理结果集：</strong>
                            <ul>
                                <li>遍历结果集，提取每一行数据</li>
                                <li>将数据库字段映射到对象属性（ORM映射）</li>
                                <li>组装成业务对象（如User、Order等）</li>
                                <li>序列化为JSON或XML格式</li>
                            </ul>
                        </li>
                        <li><strong>释放连接：</strong>
                            <ul>
                                <li>将连接返回给连接池，供后续请求复用</li>
                                <li>关闭ResultSet、Statement等资源</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>查询示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 伪代码：数据库查询
connection = db_pool.get_connection()

// 参数化查询，防止SQL注入
sql = "SELECT id, name, age, email FROM users WHERE id = ?"
statement = connection.prepare(sql)
statement.set_int(1, user_id)

result_set = statement.execute()

if (result_set.next()) {
    // 提取数据
    user = {
        id: result_set.get_int("id"),
        name: result_set.get_string("name"),
        age: result_set.get_int("age"),
        email: result_set.get_string("email")
    }

    // 序列化为JSON
    user_json = JSON.stringify(user)

    // 进入"更新Redis主节点"流程
    redis_client.set("user:" + user_id, user_json, "EX", 3600)

    return user
} else {
    // 数据库中也没有该数据
    return null
}

db_pool.return_connection(connection)
                    </pre>
                    <p><strong>查询优化：</strong></p>
                    <ul>
                        <li><strong>索引优化：</strong>
                            <ul>
                                <li>为WHERE子句中的字段创建索引</li>
                                <li>示例：CREATE INDEX idx_user_id ON users(id)</li>
                                <li>避免全表扫描，使用索引快速定位数据</li>
                            </ul>
                        </li>
                        <li><strong>分页查询：</strong>
                            <ul>
                                <li>使用LIMIT offset, count分页</li>
                                <li>避免一次性加载大量数据</li>
                                <li>示例：SELECT * FROM orders WHERE user_id=? LIMIT 0, 20</li>
                            </ul>
                        </li>
                        <li><strong>字段筛选：</strong>
                            <ul>
                                <li>只查询需要的字段，避免SELECT *</li>
                                <li>减少网络传输和内存占用</li>
                            </ul>
                        </li>
                        <li><strong>查询缓存：</strong>
                            <ul>
                                <li>数据库自身的查询缓存（Query Cache）</li>
                                <li>相同SQL直接返回缓存结果</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>分库分表查询：</strong></p>
                    <ul>
                        <li><strong>分片路由：</strong>根据分片键（如user_id）确定查询哪个数据库</li>
                        <li><strong>跨库查询：</strong>如果需要查询多个分片，分别查询后合并结果</li>
                        <li><strong>示例：</strong>
                            <ul>
                                <li>user_id % 10 = 0 → 查询db0.users表</li>
                                <li>user_id % 10 = 1 → 查询db1.users表</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>事务隔离级别：</strong></p>
                    <ul>
                        <li><strong>读未提交：</strong>可能读到脏数据（不推荐）</li>
                        <li><strong>读已提交：</strong>只能读到已提交的数据（推荐）</li>
                        <li><strong>可重复读：</strong>MySQL默认级别，防止幻读</li>
                        <li><strong>串行化：</strong>最高隔离级别，性能差</li>
                    </ul>
                    <p><strong>性能指标：</strong></p>
                    <ul>
                        <li><strong>响应时间：</strong>简单查询10-50ms，复杂查询100-500ms</li>
                        <li><strong>并发连接：</strong>数据库连接池通常配置为10-100个连接</li>
                        <li><strong>QPS：</strong>单实例数据库QPS通常几千到上万</li>
                    </ul>
                    <p><strong>业务价值：</strong>从持久化存储获取完整、准确的数据，为业务逻辑提供数据基础，同时为缓存更新提供数据源。</p>
                `;
            } else if (type === 'update-redis-master') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>更新Redis主节点：回写缓存</h4>
                    <p><strong>作用：</strong>将从数据库查询到的数据写入Redis主节点，更新缓存，为后续请求提供服务。</p>
                    <p><strong>更新流程：</strong></p>
                    <ol>
                        <li><strong>序列化数据：</strong>
                            <ul>
                                <li>将数据库查询结果（对象、结构体）序列化为字符串</li>
                                <li>常用格式：JSON、MessagePack、Protobuf</li>
                                <li>示例：JSON.stringify(user_object)</li>
                            </ul>
                        </li>
                        <li><strong>构建Redis命令：</strong>
                            <ul>
                                <li><strong>简单key-value：</strong>SET key value EX seconds</li>
                                <li><strong>哈希结构：</strong>HMSET hash field1 value1 field2 value2</li>
                                <li><strong>列表结构：</strong>LPUSH list value1 value2</li>
                                <li><strong>集合结构：</strong>SADD set member1 member2</li>
                            </ul>
                        </li>
                        <li><strong>设置过期时间（TTL）：</strong>
                            <ul>
                                <li><strong>为什么需要TTL：</strong>防止数据永久占用内存，确保内存空间可回收</li>
                                <li><strong>TTL设置策略：</strong>
                                    <ul>
                                        <li>热点数据：1小时（3600秒）</li>
                                        <li>普通数据：10分钟（600秒）</li>
                                        <li>冷数据：5分钟（300秒）</li>
                                        <li>会话数据：30分钟（1800秒）</li>
                                    </ul>
                                </li>
                                <li><strong>设置方式：</strong>
                                    <ul>
                                        <li>SET key value EX seconds（设置时指定TTL）</li>
                                        <li>EXPIRE key seconds（已存在的key设置TTL）</li>
                                        <li>EXPIREAT key timestamp（设置过期时间戳）</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li><strong>执行写入命令：</strong>
                            <ul>
                                <li>发送命令到Redis主节点</li>
                                <li>Redis将数据写入内存</li>
                                <li>返回OK表示写入成功</li>
                                <li><strong>同步到从节点：</strong>主节点异步将写命令发送给所有从节点</li>
                            </ul>
                        </li>
                        <li><strong>主从同步机制：</strong>
                            <ul>
                                <li>主节点执行写命令后，将命令传播给从节点</li>
                                <li>从节点接收命令并执行，保持数据一致</li>
                                <li>异步复制：不等待从节点确认，主节点立即返回</li>
                                <li><strong>注意：</strong>这里只是更新Redis主节点，不涉及"将从节点提升为主节点"</li>
                                <li>从节点提升为主节点是哨兵的自动故障转移流程，与缓存更新是两个独立的概念</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>写入示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 伪代码：更新Redis主节点

// 序列化数据
user_json = JSON.stringify({
    id: 1001,
    name: "张三",
    age: 25,
    email: "zhangsan@example.com"
})

// 写入Redis主节点，设置1小时过期
redis_client.set("user:1001", user_json, "EX", 3600)

// 返回结果：OK
// 主节点异步将写命令同步到从节点
                    </pre>
                    <p><strong>主从同步详细说明：</strong></p>
                    <ul>
                        <li><strong>主节点角色：</strong>接收所有写操作，是唯一的写入点</li>
                        <li><strong>从节点角色：</strong>只能读，数据从主节点同步</li>
                        <li><strong>同步方向：</strong>主节点 → 从节点（单向）</li>
                        <li><strong>同步方式：</strong>主节点执行写命令后，将命令发送给所有从节点</li>
                        <li><strong>异步复制：</strong>主节点不等从节点确认，立即返回给客户端</li>
                        <li><strong>数据一致性：</strong>短暂延迟（通常毫秒级），从节点最终与主节点一致</li>
                    </ul>
                    <p><strong>重要澄清：</strong></p>
                    <ul>
                        <li><strong>本节点的作用：</strong>更新Redis主节点的内存数据（缓存回写）</li>
                        <li><strong>不是主从切换：</strong>不涉及将从节点提升为主节点的操作</li>
                        <li><strong>主从切换场景：</strong>只有当主节点故障时，哨兵才会将某个从节点提升为新的主节点</li>
                        <li><strong>两个独立概念：</strong>
                            <ul>
                                <li>缓存更新：正常业务流程，将数据写入Redis主节点</li>
                                <li>主从切换：故障恢复流程，哨兵自动将从节点提升为主节点</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>内存管理：</strong></p>
                    <ul>
                        <li><strong>淘汰策略：</strong>当内存不足时，Redis自动淘汰过期key或不常用的key</li>
                        <li><strong>最大内存：</strong>maxmemory配置，如maxmemory 2GB</li>
                        <li><strong>淘汰算法：</strong>allkeys-lru（淘汰最少使用的key）、volatile-lru（淘汰过期且最少使用的key）</li>
                    </ul>
                    <p><strong>并发控制：</strong></p>
                    <ul>
                        <li><strong>原子操作：</strong>Redis命令是原子的，不会出现并发冲突</li>
                        <li><strong>事务支持：</strong>使用MULTI/EXEC执行多个命令，保证原子性</li>
                        <li><strong>乐观锁：</strong>使用WATCH命令监控key，CAS更新</li>
                    </ul>
                    <p><strong>性能优势：</strong></p>
                    <ul>
                        <li><strong>写入速度：</strong>Redis写入操作通常<1ms</li>
                        <li><strong>内存访问：</strong>后续请求直接从内存读取，无需查询数据库</li>
                        <li><strong>QPS提升：</strong>缓存更新后，QPS可提升10-100倍</li>
                    </ul>
                    <p><strong>业务价值：</strong>通过更新Redis主节点，将数据库数据缓存到内存，为后续请求提供快速访问，大幅提升系统性能和用户体验。</p>
                `;
            } else if (type === 'write-has-data') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>有数据：Redis中已存在数据（更新场景）</h4>
                    <p><strong>定义：</strong>写操作检查时，发现Redis主节点内存中已存在所查询的key，并且有对应的value，表示这是对已有数据的更新操作。</p>
                    <p><strong>有数据的体现：</strong></p>
                    <ul>
                        <li><strong>EXISTS命令：</strong>返回1（表示key存在）</li>
                        <li><strong>GET命令：</strong>返回了具体的数据（不是nil）</li>
                        <li><strong>TYPE命令：</strong>返回key的数据类型（string、hash、list等）</li>
                        <li><strong>TTL命令：</strong>返回key的剩余生存时间（-1表示永不过期，-2表示已过期）</li>
                    </ul>
                    <p><strong>有数据示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 检查用户ID=1001的数据
EXISTS user:1001
// 返回：1

GET user:1001
// 返回：'{"id":1001,"name":"张三","age":25}'

// 判断：Redis中有数据，执行更新操作
                    </pre>
                    <p><strong>业务场景：</strong></p>
                    <ul>
                        <li><strong>用户信息修改：</strong>用户修改昵称、头像、个人简介等</li>
                        <li><strong>订单状态变更：</strong>订单从"待支付"变为"已支付"、"已发货"</li>
                        <li><strong>库存扣减：</strong>商品库存数量减少</li>
                        <li><strong>积分更新：</strong>用户积分增加或减少</li>
                        <li><strong>配置更新：</strong>系统配置参数的修改</li>
                    </ul>
                    <p><strong>有数据后的处理流程：</strong></p>
                    <ol>
                        <li><strong>获取旧数据：</strong>
                            <ul>
                                <li>从Redis主节点获取当前存储的数据</li>
                                <li>解析数据（如果是JSON，反序列化为对象）</li>
                                <li>了解当前的数据状态和结构</li>
                            </ul>
                        </li>
                        <li><strong>合并更新：</strong>
                            <ul>
                                <li>将前端提交的更新数据与旧数据合并</li>
                                <li>只更新需要修改的字段，保留其他字段不变</li>
                                <li>执行业务逻辑验证（如库存不能为负数）</li>
                            </ul>
                        </li>
                        <li><strong>更新Redis主节点：</strong>
                            <ul>
                                <li>使用SET、HMSET等命令更新Redis主节点中的数据</li>
                                <li>如果是部分更新，使用HSET、HINCRBY等命令</li>
                                <li>保持TTL不变或重置TTL</li>
                            </ul>
                        </li>
                        <li><strong>更新数据库：</strong>
                            <ul>
                                <li>同时更新数据库中的对应数据</li>
                                <li>使用UPDATE SQL语句</li>
                                <li>确保Redis和数据库的数据一致性</li>
                            </ul>
                        </li>
                        <li><strong>事务保证：</strong>
                            <ul>
                                <li>Redis和数据库的更新操作必须在同一个事务中</li>
                                <li>要么全部成功，要么全部失败</li>
                                <li>避免出现Redis已更新但数据库未更新的不一致情况</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>有数据更新示例代码：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 伪代码：有数据场景的更新操作
user_key = "user:" + user_id

// 1. 检查Redis中是否有数据
exists = redis_client.exists(user_key)

if (exists == 1) {
    // 2. 获取旧数据
    old_data_json = redis_client.get(user_key)
    old_data = JSON.parse(old_data_json)

    // 3. 合并更新（只更新提交的字段）
    new_data = old_data
    if (params.name != null) {
        new_data.name = params.name
    }
    if (params.age != null) {
        new_data.age = params.age
    }

    // 4. 序列化新数据
    new_data_json = JSON.stringify(new_data)

    // 5. 事务操作：同时更新Redis和数据库
    begin_transaction()
    try {
        // 更新Redis主节点
        redis_client.set(user_key, new_data_json, "EX", 3600)

        // 更新数据库
        db.execute(
            "UPDATE users SET name=?, age=? WHERE id=?",
            new_data.name, new_data.age, user_id
        )

        // 提交事务
        commit_transaction()

        return "更新成功"
    } catch (error) {
        // 回滚事务
        rollback_transaction()
        return "更新失败"
    }
}
                    </pre>
                    <p><strong>更新Redis的数据结构操作：</strong></p>
                    <ul>
                        <li><strong>字符串（String）：</strong>SET key value 或 SET key value EX seconds</li>
                        <li><strong>哈希（Hash）：</strong>
                            <ul>
                                <li>单个字段：HSET hash field value</li>
                                <li>多个字段：HMSET hash field1 value1 field2 value2</li>
                                <li>数值递增：HINCRBY hash field increment</li>
                            </ul>
                        </li>
                        <li><strong>列表（List）：</strong>
                            <ul>
                                <li>左推入：LPUSH list value</li>
                                <li>右推入：RPUSH list value</li>
                                <li>指定索引：LSET list index value</li>
                            </ul>
                        </li>
                        <li><strong>集合（Set）：</strong>SADD set member</li>
                        <li><strong>有序集合（ZSet）：</strong>ZADD zset score member</li>
                    </ul>
                    <p><strong>性能优势：</strong></p>
                    <ul>
                        <li>直接更新已有数据，无需插入新数据</li>
                        <li>利用Redis的原子操作，性能极高</li>
                        <li>减少数据库的写入压力（如果只更新Redis）</li>
                        <li>但为了数据一致性，通常需要同步更新数据库</li>
                    </ul>
                    <p><strong>注意事项：</strong></p>
                    <ul>
                        <li>更新操作必须考虑并发问题，避免覆盖其他线程的更新</li>
                        <li>使用乐观锁（版本号）或分布式锁（SETNX）保证并发安全</li>
                        <li>注意TTL的设置，避免更新后TTL被清除导致数据永久驻留内存</li>
                        <li>如果是部分字段更新，使用HSET而不是SET，避免覆盖整个对象</li>
                    </ul>
                    <p><strong>业务价值：</strong>通过识别Redis中已有数据，执行更新操作，同时保持Redis和数据库的数据一致性，确保数据的准确性和实时性。</p>
                `;
            } else if (type === 'write-no-data') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>无数据：Redis中不存在数据（插入场景）</h4>
                    <p><strong>定义：</strong>写操作检查时，发现Redis主节点内存中不存在所查询的key，表示这是首次写入或数据已过期，需要查询数据库确认后执行插入操作。</p>
                    <p><strong>无数据的体现：</strong></p>
                    <ul>
                        <li><strong>EXISTS命令：</strong>返回0（表示key不存在）</li>
                        <li><strong>GET命令：</strong>返回nil（空值）</li>
                        <li><strong>TYPE命令：</strong>返回none（key不存在）</li>
                        <li><strong>TTL命令：</strong>返回-2（表示key已过期或不存在）</li>
                    </ul>
                    <p><strong>无数据示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 检查用户ID=9999的数据
EXISTS user:9999
// 返回：0

GET user:9999
// 返回：(nil)

// 判断：Redis中无数据，需要查询数据库
                    </pre>
                    <p><strong>业务场景：</strong></p>
                    <ul>
                        <li><strong>新用户注册：</strong>第一次创建用户数据</li>
                        <li><strong>新订单创建：</strong>用户首次下单，创建订单记录</li>
                        <li><strong>缓存过期：</strong>之前的数据已过期（TTL到期），需要重新加载</li>
                        <li><strong>缓存被清空：</strong>系统重启或管理员清空缓存后首次访问</li>
                        <li><strong>冷启动：</strong>系统刚启动，缓存为空</li>
                    </ul>
                    <p><strong>无数据后的处理流程：</strong></p>
                    <ol>
                        <li><strong>查询数据库：</strong>
                            <ul>
                                <li>执行SELECT查询，从数据库获取数据</li>
                                <li>判断数据库中是否存在该数据</li>
                                <li>有两种可能：数据库有数据、数据库无数据</li>
                            </ul>
                        </li>
                        <li><strong>情况1：数据库有数据（缓存过期/冷启动）</strong>
                            <ul>
                                <li>数据存在于数据库，但不在Redis中</li>
                                <li>需要更新数据库数据（如果有更新）</li>
                                <li>同时将数据写入Redis缓存</li>
                            </ul>
                        </li>
                        <li><strong>情况2：数据库无数据（首次插入）</strong>
                            <ul>
                                <li>数据库和Redis中都没有该数据</li>
                                <li>需要执行INSERT操作，插入新数据到数据库</li>
                                <li>同时将新数据写入Redis缓存</li>
                            </ul>
                        </li>
                        <li><strong>事务保证：</strong>
                            <ul>
                                <li>数据库操作和Redis操作必须在同一个事务中</li>
                                <li>要么全部成功（数据库插入/更新 + Redis写入）</li>
                                <li>要么全部失败（回滚所有操作）</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>无数据更新示例代码：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 伪代码：无数据场景的处理操作
user_key = "user:" + user_id

// 1. 检查Redis中是否有数据
exists = redis_client.exists(user_key)

if (exists == 0) {
    // 2. 查询数据库
    user = db.query("SELECT * FROM users WHERE id = ?", user_id)

    if (user != null) {
        // 情况1：数据库有数据（缓存过期或冷启动）

        // 3. 更新数据（如果有更新）
        if (params.name != null) {
            user.name = params.name
        }
        if (params.age != null) {
            user.age = params.age
        }

        // 4. 序列化数据
        user_json = JSON.stringify(user)

        // 5. 事务操作：更新数据库和Redis
        begin_transaction()
        try {
            // 更新数据库
            db.execute(
                "UPDATE users SET name=?, age=? WHERE id=?",
                user.name, user.age, user_id
            )

            // 写入Redis缓存，设置1小时过期
            redis_client.set(user_key, user_json, "EX", 3600)

            commit_transaction()
            return "更新成功"
        } catch (error) {
            rollback_transaction()
            return "更新失败"
        }
    } else {
        // 情况2：数据库也无数据（首次插入）

        // 3. 准备新数据
        new_user = {
            id: user_id,
            name: params.name,
            age: params.age,
            email: params.email,
            created_at: now()
        }

        // 4. 序列化数据
        new_user_json = JSON.stringify(new_user)

        // 5. 事务操作：插入数据库和Redis
        begin_transaction()
        try {
            // 插入数据库
            db.execute(
                "INSERT INTO users (id, name, age, email, created_at) VALUES (?, ?, ?, ?, ?)",
                new_user.id, new_user.name, new_user.age, new_user.email, new_user.created_at
            )

            // 写入Redis缓存，设置1小时过期
            redis_client.set(user_key, new_user_json, "EX", 3600)

            commit_transaction()
            return "创建成功"
        } catch (error) {
            rollback_transaction()
            return "创建失败"
        }
    }
}
                    </pre>
                    <p><strong>为什么需要查询数据库：</strong></p>
                    <ul>
                        <li><strong>数据可能只在数据库中：</strong>缓存过期或被清空后，数据只存在于数据库</li>
                        <li><strong>避免重复插入：</strong>直接插入可能导致主键冲突或数据重复</li>
                        <li><strong>数据完整性：</strong>需要确认数据库的真实状态</li>
                        <li><strong>业务逻辑：</strong>某些业务需要在现有数据基础上更新</li>
                    </ul>
                    <p><strong>INSERT vs UPDATE的选择：</strong></p>
                    <ul>
                        <li><strong>数据库有数据：</strong>执行UPDATE语句，更新现有记录</li>
                        <li><strong>数据库无数据：</strong>执行INSERT语句，创建新记录</li>
                        <li><strong>合并写法：</strong>使用INSERT ... ON DUPLICATE KEY UPDATE（MySQL）或MERGE INTO（Oracle）</li>
                    </ul>
                    <p><strong>性能影响：</strong></p>
                    <ul>
                        <li>需要额外查询数据库，增加一次数据库交互</li>
                        <li>响应时间比"有数据"场景略长</li>
                        <li>但保证了数据的准确性和一致性</li>
                    </ul>
                    <p><strong>优化策略：</strong></p>
                    <ul>
                        <li><strong>缓存预热：</strong>系统启动时提前加载热点数据到Redis</li>
                        <li><strong>延长TTL：</strong>合理设置过期时间，减少"无数据"场景</li>
                        <li><strong>布隆过滤器：</strong>快速判断key是否在数据库中存在</li>
                        <li><strong>批量加载：</strong>检测到缓存miss时，批量预加载相关数据</li>
                    </ul>
                    <p><strong>业务价值：</strong>通过查询数据库确认数据状态，执行正确的插入或更新操作，确保数据完整性和一致性，避免数据冲突或重复。</p>
                `;
            } else if (type === 'write-query-db-transaction') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>查询DB & 事务更新DB & 更新Redis主节点：事务一致性保证</h4>
                    <p><strong>作用：</strong>在无数据场景下，先查询数据库确认数据状态，然后使用事务机制同时更新数据库和Redis主节点，确保两者的数据一致性。</p>
                    <p><strong>什么是事务一致性：</strong></p>
                    <ul>
                        <li><strong>定义：</strong>事务是一个或多个SQL语句组成的逻辑单元，这些语句要么全部成功执行，要么全部不执行，不会出现部分成功部分失败的情况。</li>
                        <li><strong>ACID特性：</strong>
                            <ol>
                                <li><strong>原子性（Atomicity）：</strong>事务中的操作是一个不可分割的整体，要么全部成功，要么全部失败回滚。不会出现数据库已更新但Redis未更新的不一致状态。</li>
                                <li><strong>一致性（Consistency）：</strong>事务执行前后，数据库从一个一致性状态变换到另一个一致性状态。所有业务规则和约束都得到满足。例如：库存扣减后不能为负数。</li>
                                <li><strong>隔离性（Isolation）：</strong>并发执行的事务之间相互隔离，一个事务的中间状态对其他事务不可见，避免并发冲突。例如：两个用户同时修改同一个用户信息。</li>
                                <li><strong>持久性（Durability）：</strong>事务一旦提交，对数据的修改就是永久性的，即使系统故障也不会丢失。</li>
                            </ol>
                        </li>
                    </ul>
                    <p><strong>为什么需要事务一致性：</strong></p>
                    <ul>
                        <li><strong>避免数据不一致：</strong>
                            <ul>
                                <li>如果数据库更新成功但Redis更新失败 → 数据不一致</li>
                                <li>如果Redis更新成功但数据库更新失败 → 数据不一致</li>
                                <li>示例：用户修改昵称，数据库已改为"李四"，但Redis还是"张三"，下次查询返回旧数据</li>
                            </ul>
                        </li>
                        <li><strong>保证业务正确性：</strong>
                            <ul>
                                <li>库存扣减：必须同时更新数据库库存和Redis缓存，避免超卖</li>
                                <li>余额转账：必须同时扣减一方余额和增加另一方余额</li>
                                <li>订单状态：必须同步更新数据库和Redis中的订单状态</li>
                            </ul>
                        </li>
                        <li><strong>用户体验：</strong>
                            <ul>
                                <li>确保用户看到的始终是最新的、准确的数据</li>
                                <li>避免用户看到修改后又变回旧数据的"数据回滚"现象</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>如何保证事务一致性：</strong></p>
                    <h5>方法1：数据库事务 + Redis回滚补偿（推荐）</h5>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 伪代码：数据库事务 + Redis回滚补偿
begin_transaction()  // 开始数据库事务

try {
    // 1. 更新数据库
    db.execute("UPDATE users SET name=?, age=? WHERE id=?", new_name, new_age, user_id)

    // 2. 更新Redis主节点
    success = redis_client.set(user_key, new_data_json, "EX", 3600)

    if (success) {
        // 3. Redis更新成功，提交数据库事务
        commit_transaction()
        return "更新成功"
    } else {
        // 4. Redis更新失败，回滚数据库事务
        rollback_transaction()
        return "Redis更新失败"
    }
} catch (db_error) {
    // 5. 数据库操作失败，回滚事务
    rollback_transaction()

    // 6. 尝试回滚Redis（删除已写入的数据）
    redis_client.del(user_key)

    return "数据库更新失败"
}
                    </pre>
                    <h5>方法2：两阶段提交（2PC，Two-Phase Commit）</h5>
                    <ul>
                        <li><strong>阶段1：准备阶段（Prepare Phase）</strong>
                            <ul>
                                <li>事务协调器询问所有参与者（数据库、Redis）是否准备好提交</li>
                                <li>参与者执行操作但不提交，返回"准备就绪"或"准备失败"</li>
                            </ul>
                        </li>
                        <li><strong>阶段2：提交阶段（Commit Phase）</strong>
                            <ul>
                                <li>如果所有参与者都返回"准备就绪"，协调器发送"提交"命令</li>
                                <li>如果有任何参与者返回"准备失败"，协调器发送"回滚"命令</li>
                            </ul>
                        </li>
                        <li><strong>优点：</strong>强一致性保证</li>
                        <li><strong>缺点：</strong>实现复杂，性能较差，存在阻塞</li>
                    </ul>
                    <h5>方法3：TCC模式（Try-Confirm-Cancel，尝试-确认-取消）</h5>
                    <ul>
                        <li><strong>Try阶段：</strong>尝试执行操作，预留资源
                            <ul>
                                <li>数据库：检查数据是否存在，锁定记录</li>
                                <li>Redis：检查key是否可写入</li>
                            </ul>
                        </li>
                        <li><strong>Confirm阶段：</strong>确认执行，提交所有操作
                            <ul>
                                <li>数据库：执行UPDATE或INSERT</li>
                                <li>Redis：执行SET写入</li>
                            </ul>
                        </li>
                        <li><strong>Cancel阶段：</strong>取消操作，释放资源
                            <ul>
                                <li>数据库：释放锁，回滚已执行的修改</li>
                                <li>Redis：删除已写入的数据</li>
                            </ul>
                        </li>
                        <li><strong>优点：</strong>性能较好，最终一致性</li>
                        <li><strong>缺点：</strong>需要编写Try、Confirm、Cancel三个方法，代码复杂</li>
                    </ul>
                    <h5>方法4：基于消息队列的最终一致性（异步）</h5>
                    <ul>
                        <li><strong>写流程：</strong>
                            <ol>
                                <li>先更新数据库（事务提交）</li>
                                <li>将更新操作发送到消息队列（MQ）</li>
                                <li>消息队列保证消息不丢失（持久化、确认机制）</li>
                                <li>消费者监听消息，更新Redis缓存</li>
                            </ol>
                        </li>
                        <li><strong>优点：</strong>解耦数据库和Redis，性能好</li>
                        <li><strong>缺点：</strong>最终一致性（短暂延迟），需要处理消息失败重试</li>
                        <li><strong>适用场景：</strong>高并发、对实时性要求不高的场景</li>
                    </ul>
                    <p><strong>事务隔离级别：</strong></p>
                    <ul>
                        <li><strong>读未提交（Read Uncommitted）：</strong>可能读到脏数据（不推荐）</li>
                        <li><strong>读已提交（Read Committed）：</strong>只能读到已提交的数据（推荐大多数场景）</li>
                        <li><strong>可重复读（Repeatable Read）：</strong>MySQL默认级别，防止幻读</li>
                        <li><strong>串行化（Serializable）：</strong>最高隔离级别，完全串行执行（性能差）</li>
                    </ul>
                    <p><strong>并发控制机制：</strong></p>
                    <ul>
                        <li><strong>乐观锁（Optimistic Lock）：</strong>
                            <ul>
                                <li>使用版本号（version）或时间戳（updated_at）字段</li>
                                <li>更新时检查版本号是否变化，变化则说明有其他事务已修改</li>
                                <li>示例：UPDATE users SET name=?, age=?, version=version+1 WHERE id=? AND version=?</li>
                                <li>优点：无需加锁，并发性能好</li>
                                <li>缺点：高并发时冲突率高，需要重试</li>
                            </ul>
                        </li>
                        <li><strong>悲观锁（Pessimistic Lock）：</strong>
                            <ul>
                                <li>使用SELECT ... FOR UPDATE锁定数据行</li>
                                <li>其他事务无法修改被锁定的行，直到锁释放</li>
                                <li>优点：强一致性，避免并发冲突</li>
                                <li>缺点：并发性能差，容易死锁</li>
                            </ul>
                        </li>
                        <li><strong>分布式锁：</strong>
                            <ul>
                                <li>使用Redis的SETNX命令实现分布式锁</li>
                                <li>或使用Redlock算法（多个Redis实例）</li>
                                <li>确保在分布式环境下，同一时刻只有一个线程能执行关键操作</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>完整事务流程示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 伪代码：完整的事务一致性保证流程
function update_user_with_transaction(user_id, params) {
    user_key = "user:" + user_id

    // 1. 查询数据库
    user = db.query("SELECT * FROM users WHERE id = ? FOR UPDATE", user_id)

    begin_transaction()

    try {
        if (user != null) {
            // 情况1：数据库有数据，执行UPDATE
            new_user = merge_user(user, params)
            db.execute(
                "UPDATE users SET name=?, age=?, version=version+1 WHERE id=? AND version=?",
                new_user.name, new_user.age, user_id, user.version
            )
        } else {
            // 情况2：数据库无数据，执行INSERT
            new_user = {
                id: user_id,
                name: params.name,
                age: params.age,
                version: 1
            }
            db.execute(
                "INSERT INTO users (id, name, age, version) VALUES (?, ?, ?, ?)",
                new_user.id, new_user.name, new_user.age, new_user.version
            )
        }

        // 2. 序列化数据
        new_user_json = JSON.stringify(new_user)

        // 3. 更新Redis主节点
        redis_success = redis_client.set(user_key, new_user_json, "EX", 3600)

        if (!redis_success) {
            // Redis更新失败，回滚数据库事务
            throw new Exception("Redis更新失败")
        }

        // 4. 提交数据库事务
        commit_transaction()

        return {success: true, data: new_user}

    } catch (error) {
        // 5. 发生错误，回滚数据库事务
        rollback_transaction()

        // 6. 尝试回滚Redis（如果已写入）
        redis_client.del(user_key)

        return {success: false, error: error.message}
    }
}
                    </pre>
                    <p><strong>失败重试机制：</strong></p>
                    <ul>
                        <li><strong>Redis更新失败：</strong>记录日志，告警通知，人工介入处理</li>
                        <li><strong>数据库更新失败：</strong>回滚Redis，重试整个事务</li>
                        <li><strong>网络超时：</strong>设置合理的超时时间，超时后重试或回滚</li>
                        <li><strong>死锁处理：</strong>检测到死锁时，回滚当前事务，等待随机时间后重试</li>
                    </ul>
                    <p><strong>性能优化：</strong></p>
                    <ul>
                        <li><strong>减少事务持有时间：</strong>事务中只包含必要的操作，避免长时间锁定</li>
                        <li><strong>批量操作：</strong>如果可能，将多个更新合并为一个事务</li>
                        <li><strong>异步更新：</strong>对实时性要求不高的场景，可以使用MQ异步更新Redis</li>
                        <li><strong>读写分离：</strong>写操作走主节点，读操作走从节点，减轻主节点压力</li>
                    </ul>
                    <p><strong>业务价值：</strong>通过事务机制保证数据库和Redis的数据一致性，避免数据冲突和不一致，确保业务逻辑的正确性和用户体验的可靠性。</p>
                `;
            } else if (type === 'return-nginx') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>返回Nginx网关</h4>
                    <p><strong>作用：</strong>业务处理完成后，将结果返回给Nginx网关，由Nginx返回给前端。</p>
                    <p><strong>返回流程：</strong></p>
                    <ol>
                        <li>业务模块处理完成，生成响应数据</li>
                        <li>后端服务将响应返回给Nginx网关</li>
                        <li>Nginx网关进行必要的处理（如添加响应头、Gzip压缩等）</li>
                        <li>Nginx将响应返回给前端App/Web</li>
                    </ol>
                    <p><strong>适用场景：</strong></p>
                    <ul>
                        <li><strong>不需要数据库操作的业务：</strong>直接返回结果。</li>
                        <li><strong>纯计算操作：</strong>计算完成后返回结果。</li>
                        <li><strong>缓存命中：</strong>从Redis获取数据后返回。</li>
                        <li><strong>静态数据：</strong>返回配置数据或常量。</li>
                    </ul>
                    <p><strong>Nginx处理能力：</strong></p>
                    <ul>
                        <li><strong>负载均衡：</strong>将请求分发到健康的后端服务。</li>
                        <li><strong>反向代理：</strong>隐藏后端服务真实地址。</li>
                        <li><strong>响应缓存：</strong>缓存静态资源，减少后端压力。</li>
                        <li><strong>SSL终止：</strong>处理HTTPS加密解密。</li>
                    </ul>
                    <p><strong>优势：</strong>简化前端对接，统一接口入口，提高系统安全性。</p>
                `;
            } else if (type === 'health-monitor') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>后端服务健康监控</h4>
                    <p><strong>作用：</strong>Nginx持续监控后端服务的健康状态，确保只将流量分发到健康的服务。</p>
                    <p><strong>监控机制：</strong></p>
                    <ul>
                        <li><strong>主动健康检查：</strong>Nginx定期向后端服务发送健康检查请求（默认/health端点）。</li>
                        <li><strong>检查频率：</strong>可配置间隔时间（如每5秒检查一次）。</li>
                        <li><strong>超时设置：</strong>请求超时时间（如3秒未响应视为失败）。</li>
                        <li><strong>失败阈值：</strong>连续失败N次标记为不健康（如max_fails=3）。</li>
                    </ul>
                    <p><strong>健康状态：</strong></p>
                    <ul>
                        <li><strong>健康（Up）：</strong>服务正常运行，可以接收请求。</li>
                        <li><strong>不健康（Down）：</strong>服务故障或超时，不再接收新请求。</li>
                        <li><strong>恢复检测：</strong>不健康的服务恢复后，需要通过健康检查才能重新上线。</li>
                    </ul>
                    <p><strong>故障转移流程：</strong></p>
                    <ol>
                        <li>主服务连续失败max_fails次</li>
                        <li>Nginx将主服务标记为不健康</li>
                        <li>自动将流量切换到备用服务</li>
                        <li>主服务恢复后，健康检查通过重新上线</li>
                    </ol>
                    <p><strong>Nginx配置示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
upstream backend {
    server 192.168.2.10:8080 max_fails=3 fail_timeout=30s;
    server 192.168.2.11:8080 backup;

    # 主动健康检查（需要nginx_plus或第三方模块）
    check interval=5000 rise=2 fall=3 timeout=3000;
}
                    </pre>
                    <p><strong>优势：</strong>提高系统可用性，实现自动故障转移，减少人工干预。</p>
                `;
            } else if (type === 'nginx-switch') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>Nginx自动切换备用服务</h4>
                    <p><strong>作用：</strong>当主后端服务故障时，Nginx自动将流量切换到备用服务，确保业务连续性。</p>
                    <p><strong>工作原理：</strong></p>
                    <ul>
                        <li><strong>健康检查：</strong>Nginx定期向后端服务发送健康检查请求</li>
                        <li><strong>失败计数：</strong>连续失败max_fails次后，标记服务为不健康</li>
                        <li><strong>自动切换：</strong>主服务不健康时，自动将流量路由到备用服务</li>
                        <li><strong>恢复检测：</strong>主服务恢复后，健康检查通过后重新加入负载均衡池</li>
                    </ul>
                    <p><strong>实现方式：</strong></p>
                    <ul>
                        <li><strong>被动健康检查（Nginx开源版）：</strong>
                            <ul>
                                <li>通过max_fails和fail_timeout参数配置</li>
                                <li>max_fails=3：连续失败3次标记为不健康</li>
                                <li>fail_timeout=30s：30秒后重新尝试连接</li>
                                <li>backup标记：备用服务器只在工作服务器都不可用时才接收流量</li>
                            </ul>
                        </li>
                        <li><strong>主动健康检查（Nginx Plus或第三方模块）：</strong>
                            <ul>
                                <li>定期发送健康检查请求到指定端点（如/health）</li>
                                <li>可配置检查间隔、超时时间、成功/失败阈值</li>
                                <li>更灵活、更精确的健康状态监控</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>Nginx配置示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
upstream backend {
    # 主服务
    server 192.168.2.10:8080 max_fails=3 fail_timeout=30s;

    # 备用服务
    server 192.168.2.11:8080 backup;
}

# 主动健康检查（需要nginx_plus或第三方模块）
check interval=5000 rise=2 fall=3 timeout=3000;
                    </pre>
                    <p><strong>切换流程：</strong></p>
                    <ol>
                        <li>Nginx检测到主服务连续失败3次</li>
                        <li>将主服务标记为不健康（down）</li>
                        <li>自动将新请求发送到备用服务</li>
                        <li>30秒后定期尝试重新连接主服务</li>
                        <li>主服务恢复后，重新加入负载均衡池</li>
                    </ol>
                    <p><strong>优势：</strong>实现自动故障转移，无需人工干预，提高系统可用性达到99.9%以上。</p>
                `;
            } else if (type === 'hot-data-server') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>独立热数据服务器</h4>
                    <p><strong>定义：</strong>专门用于存储和管理频繁访问的"热数据"的高性能服务器。</p>
                    <p><strong>主要功能：</strong></p>
                    <ul>
                        <li><strong>快速响应：</strong>使用高性能存储（SSD、NVMe），确保低延迟访问</li>
                        <li><strong>高并发处理：</strong>优化数据库配置，支持大量并发查询</li>
                        <li><strong>内存缓存：</strong>增大内存配置，将更多热数据缓存到内存</li>
                        <li><strong>读写优化：</strong>优化索引、分区策略，提高读写性能</li>
                    </ul>
                    <p><strong>热数据特征：</strong></p>
                    <ul>
                        <li>频繁访问的数据（如最近7天的订单）</li>
                        <li>用户活跃数据（如在线用户信息）</li>
                        <li>实时业务数据（如当前直播间数据）</li>
                        <li>最近创建或修改的数据</li>
                    </ul>
                    <p><strong>硬件配置建议：</strong></p>
                    <ul>
                        <li>CPU：高性能多核处理器</li>
                        <li>内存：大容量内存（如64GB、128GB）</li>
                        <li>存储：SSD或NVMe高速存储</li>
                        <li>网络：万兆网卡，低延迟</li>
                    </ul>
                    <p><strong>优化策略：</strong></p>
                    <ul>
                        <li>合理的索引设计</li>
                        <li>定期分析慢查询并优化</li>
                        <li>合理设置缓存大小</li>
                        <li>读写分离，从库分担读压力</li>
                    </ul>
                    <p><strong>优势：</strong>显著提升热数据访问速度，改善用户体验，降低冷数据服务器的压力。</p>
                `;
            } else if (type === 'cold-data-server') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>集合冷数据服务器</h4>
                    <p><strong>定义：</strong>用于存储不常访问的"冷数据"的服务器，通常使用成本较低的存储方案。</p>
                    <p><strong>主要功能：</strong></p>
                    <ul>
                        <li><strong>归档存储：</strong>存储历史数据、过期数据</li>
                        <li><strong>数据备份：</strong>作为热数据的备份，防止数据丢失</li>
                        <li><strong>合规存储：</strong>满足法规要求的数据保留期限</li>
                        <li><strong>分析查询：</strong>支持数据分析、报表生成等操作</li>
                    </ul>
                    <p><strong>冷数据特征：</strong></p>
                    <ul>
                        <li>不常访问的历史数据（如一年前的订单）</li>
                        <li>已归档的业务数据</li>
                        <li>超过一定时间的数据（如一个月前）</li>
                        <li>用于审计、分析的数据</li>
                    </ul>
                    <p><strong>存储策略：</strong></p>
                    <ul>
                        <li><strong>压缩存储：</strong>使用数据压缩技术，节省存储空间</li>
                        <li><strong>分级存储：</strong>热数据、温数据、冷数据分层存储</li>
                        <li><strong>定期归档：</strong>自动将超期数据迁移到冷存储</li>
                        <li><strong>冗余备份：</strong>多副本存储，保证数据安全</li>
                    </ul>
                    <p><strong>硬件配置：</strong></p>
                    <ul>
                        <li>使用大容量HDD存储，成本较低</li>
                        <li>配置适中的CPU和内存</li>
                        <li>可以使用分布式存储系统</li>
                        <li>支持数据压缩和去重</li>
                    </ul>
                    <p><strong>访问特点：</strong></p>
                    <ul>
                        <li>查询性能较低，但不影响业务正常运行</li>
                        <li>主要用于后台分析、报表生成</li>
                        <li>支持批量查询，不支持高并发实时查询</li>
                    </ul>
                    <p><strong>优势：</strong>降低存储成本，优化热数据服务器性能，满足数据合规要求。</p>
                `;
            } else if (type === 'cold-backup') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>冷数据备份</h4>
                    <p><strong>作用：</strong>将一个月前的历史数据定期备份到冷数据库，释放热数据服务器的存储空间。</p>
                    <p><strong>备份策略：</strong></p>
                    <ul>
                        <li><strong>时间策略：</strong>定期执行（如每月1号凌晨执行数据迁移）</li>
                        <li><strong>数据筛选：</strong>将创建时间超过30天的数据标记为冷数据</li>
                        <li><strong>数据迁移：</strong>将冷数据从热数据库迁移到冷数据库</li>
                        <li><strong>数据清理：</strong>热数据库中删除已迁移的冷数据</li>
                    </ul>
                    <p><strong>备份流程：</strong></p>
                    <ol>
                        <li>扫描热数据库，识别超过30天的数据</li>
                        <li>将数据导出到临时文件或直接迁移到冷数据库</li>
                        <li>验证数据完整性</li>
                        <li>从热数据库删除已备份的数据</li>
                        <li>记录备份日志，便于追溯</li>
                    </ol>
                    <p><strong>数据保留策略：</strong></p>
                    <ul>
                        <li><strong>短期备份：</strong>保留最近3个月的冷数据</li>
                        <li><strong>中期备份：</strong>保留最近1年的数据</li>
                        <li><strong>长期归档：</strong>保留超过1年的数据，用于审计和分析</li>
                        <li><strong>永久保存：</strong>关键业务数据永久保存</li>
                    </ul>
                    <p><strong>注意事项：</strong></p>
                    <ul>
                        <li>备份前必须验证数据完整性</li>
                        <li>使用事务确保备份过程的原子性</li>
                        <li>备份过程中避免影响业务正常运行</li>
                        <li>定期测试备份恢复流程</li>
                    </ul>
                    <p><strong>优势：</strong>优化热数据存储，降低成本，满足数据合规要求，保留历史数据用于分析。</p>
                `;
            } else if (type === 'cold-db') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>可查询冷DB</h4>
                    <p><strong>作用：</strong>冷数据库虽然性能较低，但仍然支持查询操作，用于历史数据查询和数据分析。</p>
                    <p><strong>查询场景：</strong></p>
                    <ul>
                        <li><strong>历史订单查询：</strong>用户查询几个月前的订单记录</li>
                        <li><strong>数据分析：</strong>业务分析、趋势分析、报表生成</li>
                        <li><strong>审计查询：</strong>审计人员查询历史操作记录</li>
                        <li><strong>合规检查：</strong>满足监管要求的数据查询</li>
                    </ul>
                    <p><strong>查询特点：</strong></p>
                    <ul>
                        <li><strong>响应时间较慢：</strong>通常在秒级到分钟级</li>
                        <li><strong>支持批量查询：</strong>适合批量数据导出</li>
                        <li><strong>不支持高并发：</strong>限制并发查询数量</li>
                        <li><strong>只读优先：</strong>建议设计为只读数据库</li>
                    </ul>
                    <p><strong>查询优化：</strong></p>
                    <ul>
                        <li>建立合适的索引，加快查询速度</li>
                        <li>使用分区表，按时间分区</li>
                        <li>限制返回结果数量，使用分页</li>
                        <li>使用物化视图，预计算常用查询</li>
                    </ul>
                    <p><strong>访问权限：</strong></p>
                    <ul>
                        <li>限制访问权限，只允许授权用户查询</li>
                        <li>记录所有查询操作，用于审计</li>
                        <li>敏感数据需要脱敏处理</li>
                        <li>大数据导出需要审批</li>
                    </ul>
                    <p><strong>优势：</strong>保留历史数据查询能力，同时不影响热数据库性能，降低存储成本。</p>
                `;
            } else if (type === 'transaction') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>事务保护</h4>
                    <p><strong>作用：</strong>确保数据库操作的ACID特性，保证数据一致性和完整性。</p>
                    <p><strong>ACID特性：</strong></p>
                    <ul>
                        <li><strong>原子性（Atomicity）：</strong>事务中的操作要么全部成功，要么全部失败回滚</li>
                        <li><strong>一致性（Consistency）：</strong>事务执行前后，数据库从一个一致性状态变换到另一个一致性状态</li>
                        <li><strong>隔离性（Isolation）：</strong>并发事务之间相互隔离，不会互相干扰</li>
                        <li><strong>持久性（Durability）：</strong>事务一旦提交，对数据库的修改是永久性的</li>
                    </ul>
                    <p><strong>事务应用场景：</strong></p>
                    <ul>
                        <li><strong>转账操作：</strong>一个账户扣款，另一个账户加款，必须同时成功或同时失败</li>
                        <li><strong>订单创建：</strong>创建订单、扣减库存、生成物流单，必须保持一致性</li>
                        <li><strong>Redis和数据库同步：</strong>更新Redis和数据库，必须同时成功</li>
                        <li><strong>批量操作：</strong>批量插入、批量更新，必须全部成功或全部回滚</li>
                    </ul>
                    <p><strong>事务隔离级别：</strong></p>
                    <ul>
                        <li><strong>读未提交（READ UNCOMMITTED）：</strong>可能读到脏数据，不推荐使用</li>
                        <li><strong>读已提交（READ COMMITTED）：</strong>只能读到已提交的数据，推荐使用</li>
                        <li><strong>可重复读（REPEATABLE READ）：</strong>MySQL默认级别，防止幻读</li>
                        <li><strong>串行化（SERIALIZABLE）：</strong>最高隔离级别，性能较差</li>
                    </ul>
                    <p><strong>分布式事务：</strong></p>
                    <ul>
                        <li><strong>2PC（两阶段提交）：</strong>准备阶段和提交阶段</li>
                        <li><strong>TCC（Try-Confirm-Cancel）：</strong>尝试、确认、取消</li>
                        <li><strong>本地消息表：</strong>通过消息队列实现最终一致性</li>
                        <li><strong>Saga模式：</strong>长事务拆分为多个短事务</li>
                    </ul>
                    <p><strong>注意事项：</strong></p>
                    <ul>
                        <li>事务尽可能短小，避免长事务锁定资源</li>
                        <li>合理设置隔离级别，平衡性能和一致性</li>
                        <li>注意死锁问题，设置合理的锁超时时间</li>
                        <li>分布式事务会影响性能，谨慎使用</li>
                    </ul>
                    <p><strong>优势：</strong>保证数据一致性，避免数据异常，确保业务逻辑正确执行。</p>
                `;
            } else if (type === 'redis-refresh') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>定时刷新Redis-DB</h4>
                    <p><strong>作用：</strong>定期将Redis中的数据持久化到数据库，确保数据不丢失，同时保持Redis和数据库的数据一致性。</p>
                    <p><strong>刷新策略：</strong></p>
                    <ul>
                        <li><strong>定时刷新：</strong>每隔一段时间（如每5分钟）将Redis数据写入数据库</li>
                        <li><strong>增量刷新：</strong>只刷新有变化的数据，减少数据库压力</li>
                        <li><strong>批量刷新：</strong>将多个Redis操作合并为一个数据库事务</li>
                        <li><strong>异步刷新：</strong>使用后台线程异步执行，不阻塞主流程</li>
                    </ul>
                    <p><strong>刷新流程：</strong></p>
                    <ol>
                        <li>定时任务触发，扫描Redis中的所有key</li>
                        <li>识别有变化的key（通过版本号或时间戳）</li>
                        <li>将变化的数据批量写入数据库</li>
                        <li>清除Redis中已过期或不需要的数据</li>
                        <li>记录刷新日志，便于监控和排查问题</li>
                    </ol>
                    <p><strong>实现方式：</strong></p>
                    <ul>
                        <li><strong>定时任务：</strong>使用Quartz、Spring Scheduled等定时任务框架</li>
                        <li><strong>消息队列：</strong>通过MQ触发数据刷新任务</li>
                        <li><strong>变更日志：</strong>记录Redis操作日志，定期批量写入数据库</li>
                        <li><strong>双写一致性：</strong>写操作同时更新Redis和数据库</li>
                    </ul>
                    <p><strong>注意事项：</strong></p>
                    <ul>
                        <li>避免在高峰期执行刷新任务</li>
                        <li>合理设置刷新间隔，平衡实时性和性能</li>
                        <li>做好异常处理，刷新失败时记录日志并重试</li>
                        <li>监控Redis内存使用，防止内存溢出</li>
                    </ul>
                    <p><strong>优势：</strong>保证数据持久化，防止Redis故障导致数据丢失，保持数据一致性。</p>
                `;
            } else if (type === 'sharding') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>分库分表处理</h4>
                    <p><strong>作用：</strong>将大表拆分成多个小表，分布到多个数据库服务器上，提高系统性能和可扩展性。</p>
                    <p><strong>为什么要分库分表：</strong></p>
                    <ul>
                        <li><strong>性能瓶颈：</strong>单表数据量过大，查询变慢</li>
                        <li><strong>存储瓶颈：</strong>单机存储空间有限</li>
                        <li><strong>并发瓶颈：</strong>单机连接数有限，无法支持高并发</li>
                        <li><strong>扩展需求：</strong>业务增长需要扩容</li>
                    </ul>
                    <p><strong>分库分表策略：</strong></p>
                    <ul>
                        <li><strong>水平分表（Sharding）：</strong>
                            <ul>
                                <li>按范围分片：如按时间、按ID范围</li>
                                <li>按哈希分片：如user_id % 10，均匀分布</li>
                                <li>地理位置分片：按用户所在地区分布</li>
                            </ul>
                        </li>
                        <li><strong>垂直分库：</strong>
                            <ul>
                                <li>按业务模块分库：用户库、订单库、商品库</li>
                                <li>按表关系分库：频繁关联的表放在同一库</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>分片算法：</strong></p>
                    <ul>
                        <li><strong>取模分片：</strong>user_id % 分片数，简单均匀</li>
                        <li><strong>范围分片：</strong>ID范围分片，便于查询</li>
                        <li><strong>一致性哈希：</strong>节点扩容时数据迁移少</li>
                        <li><strong>地理位置：</strong>按地域分片，就近访问</li>
                    </ul>
                    <p><strong>数据路由：</strong></p>
                    <ul>
                        <li>客户端路由：应用层根据分片规则选择数据库</li>
                        <li>代理层路由：通过MyCat、ShardingSphere等中间件路由</li>
                        <li>支持跨库查询、聚合、排序</li>
                        <li>需要处理分布式事务</li>
                    </ul>
                    <p><strong>注意事项：</strong></p>
                    <ul>
                        <li>提前规划分片策略，避免后期扩容困难</li>
                        <li>跨库查询性能较差，避免频繁跨库操作</li>
                        <li>分布式ID生成，确保全局唯一</li>
                        <li>做好数据迁移和备份方案</li>
                    </ul>
                    <p><strong>优势：</strong>提高查询性能、支持高并发、易于扩展、降低单机压力。</p>
                `;
            } else if (type === 'sentinel-monitoring-process') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>哨兵监控：健康检查业务流程</h4>
                    <p><strong>业务含义：</strong>这是哨兵持续监控Redis主从节点健康状态的动态过程，是整个高可用机制的基础环节。</p>
                    <p><strong>触发条件：</strong></p>
                    <ul>
                        <li><strong>定时触发：</strong>哨兵启动后自动开启监控线程，每隔1秒（默认）执行一次健康检查</li>
                        <li><strong>持续运行：</strong>24小时不间断监控，无论是否有客户端请求</li>
                        <li><strong>全量覆盖：</strong>监控所有Redis节点（1个主节点 + N个从节点）</li>
                    </ul>
                    <p><strong>监控原理：</strong></p>
                    <ol>
                        <li><strong>PING-PONG心跳检测：</strong>
                            <ul>
                                <li>哨兵向Redis节点发送PING命令</li>
                                <li>记录发送时间戳，等待响应</li>
                                <li>收到PONG响应：计算往返时间（RTT），更新节点状态为"健康"</li>
                                <li>未收到响应：继续等待，直到超时</li>
                            </ul>
                        </li>
                        <li><strong>超时判定：</strong>
                            <ul>
                                <li>如果down-after-milliseconds时间内（默认30秒）未收到有效响应</li>
                                <li>哨兵标记该节点为"主观下线"（SDOWN）</li>
                                <li>记录下线时间、下线原因等信息到日志</li>
                            </ul>
                        </li>
                        <li><strong>询问其他哨兵：</strong>
                            <ul>
                                <li>发现节点主观下线后，哨兵向其他所有哨兵发送SENTINEL is-master-down-by-addr命令</li>
                                <li>询问："你们也认为这个主节点下线了吗？"</li>
                                <li>收集其他哨兵的回复（是/否）</li>
                                <li>统计认为主节点下线的哨兵数量</li>
                            </ul>
                        </li>
                        <li><strong>客观下线判定：</strong>
                            <ul>
                                <li>如果quorum个哨兵（如2个）都确认主节点下线</li>
                                <li>哨兵将主节点标记为"客观下线"（ODOWN）</li>
                                <li>触发下一个环节：自动故障转移</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>监控状态机：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
节点状态流转：
[在线] --(ping超时30s)--> [主观下线SDOWN] --(quorum确认)--> [客观下线ODOWN] --(故障转移)--> [新主节点上线]
    ↑                                                                           ↓
    └────────────────────────────────(节点恢复)─────────────────────────────────┘
                    </pre>
                    <p><strong>关键时间参数：</strong></p>
                    <ul>
                        <li><strong>down-after-milliseconds：</strong>判定主观下线的超时时间（默认30秒）</li>
                        <li><strong>ping间隔：</strong>发送PING命令的间隔（默认1秒）</li>
                        <li><strong>info-quorum间隔：</strong>发送INFO命令获取复制信息的间隔（默认10秒）</li>
                    </ul>
                    <p><strong>监控数据收集：</strong></p>
                    <ul>
                        <li><strong>INFO命令：</strong>每10秒发送一次，获取Redis运行状态、内存使用、复制偏移量等</li>
                        <li><strong>从节点发现：</strong>通过INFO命令自动发现新加入的从节点</li>
                        <li><strong>状态缓存：</strong>哨兵内存中维护所有节点的状态信息</li>
                    </ul>
                    <p><strong>异常情况处理：</strong></p>
                    <ul>
                        <li><strong>网络抖动：</strong>可能误判为主观下线，但不会触发客观下线（因为其他哨兵正常）</li>
                        <li><strong>哨兵自身故障：</strong>其他哨兵会监测到该哨兵下线，重新投票选举</li>
                        <li><strong>Redis节点重启：</strong>节点恢复后会自动重新连接哨兵，恢复正常状态</li>
                    </ul>
                    <p><strong>业务价值：</strong>通过持续监控，第一时间发现故障，为自动故障转移提供触发条件，确保Redis集群高可用。</p>
                `;
            } else if (type === 'sentinel-failover-process') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>自动故障转移：主节点切换业务流程</h4>
                    <p><strong>业务含义：</strong>当主节点客观下线后，哨兵自动执行的主从切换过程，是从故障发现到服务恢复的核心环节。</p>
                    <p><strong>触发条件：</strong></p>
                    <ul>
                        <li><strong>前置条件：</strong>主节点被标记为客观下线（ODOWN）</li>
                        <li><strong>quorum满足：</strong>至少quorum个哨兵确认主节点下线</li>
                        <li><strong>领头哨兵：</strong>某个哨兵被选为领头哨兵（Leader），负责执行故障转移</li>
                    </ul>
                    <p><strong>完整业务流程：</strong></p>
                    <ol>
                        <li><strong>阶段1：选举领头哨兵（Leader Election）</strong>
                            <ul>
                                <li><strong>发起选举：</strong>确认主节点客观下线的哨兵向其他哨兵发送SENTINEL is-master-down-by-addr命令</li>
                                <li><strong>投票机制：</strong>
                                    <ul>
                                        <li>每个哨兵只能投票一次</li>
                                        <li>投票给第一个请求投票的哨兵</li>
                                        <li>先到先得原则</li>
                                    </ul>
                                </li>
                                <li><strong>当选条件：</strong>获得超过半数哨兵的投票（如3个哨兵需要2票）</li>
                                <li><strong>领头哨兵职责：</strong>唯一的故障转移执行者，负责任务调度和状态管理</li>
                            </ul>
                        </li>
                        <li><strong>阶段2：选择新的主节点（Candidate Selection）</strong>
                            <ul>
                                <li><strong>筛选条件：</strong>
                                    <ol>
                                        <li>必须是健康的从节点（在线、正常复制）</li>
                                        <li>断线时间不超过down-after-milliseconds的10倍</li>
                                        <li>优先级最高（slave-priority配置）</li>
                                        <li>复制偏移量最大（数据最完整）</li>
                                        <li>run_id字典序最小（同优先级和偏移量时的tie-breaker）</li>
                                    </ol>
                                </li>
                                <li><strong>选择命令：</strong>领头哨兵内部算法评估所有从节点，选出最优者</li>
                                <li><strong>配置优先级：</strong>可以人工干预，将高性能从节点的slave-priority设置更高</li>
                            </ul>
                        </li>
                        <li><strong>阶段3：提升从节点为主节点（Promotion）</strong>
                            <ul>
                                <li><strong>发送命令：</strong>领头哨兵向选中的从节点发送SLAVEOF NO ONE命令</li>
                                <li><strong>节点转换：</strong>
                                    <ul>
                                        <li>从节点停止复制主节点</li>
                                        <li>解除只读限制（如果配置了slave-read-only yes）</li>
                                        <li>变身为独立的主节点，可以接受写操作</li>
                                    </ul>
                                </li>
                                <li><strong>确认成功：</strong>领头哨兵通过INFO命令确认节点已成功提升为主节点</li>
                            </ul>
                        </li>
                        <li><strong>阶段4：重新配置其他从节点（Reconfiguration）</strong>
                            <ul>
                                <li><strong>发送命令：</strong>领头哨兵向其他所有从节点发送SLAVEOF <new-master-ip> <new-master-port>命令</li>
                                <li><strong>数据同步：</strong>
                                    <ul>
                                        <li>从节点断开旧主节点（如果还在线）</li>
                                        <li>连接到新主节点</li>
                                        <li>发送SYNC命令，开始全量同步</li>
                                        <li>接收RDB快照文件，加载数据</li>
                                        <li>持续接收新主节点的写命令，保持数据一致</li>
                                    </ul>
                                </li>
                                <li><strong>并行控制：</strong>通过parallel-syncs参数控制同时同步的从节点数量，避免网络拥堵</li>
                            </ul>
                        </li>
                        <li><strong>阶段5：处理旧主节点（Old Master Handling）</strong>
                            <ul>
                                <li><strong>观察期：</strong>如果旧主节点在故障转移期间恢复，哨兵会将其标记为从节点</li>
                                <li><strong>数据同步：</strong>旧主节点向新主节点发起同步，丢弃自己未同步的写操作</li>
                                <li><strong>避免脑裂：</strong>确保旧主节点不会再次成为主节点，防止数据冲突</li>
                            </ul>
                        </li>
                        <li><strong>阶段6：更新配置状态（Configuration Update）</strong>
                            <ul>
                                <li><strong>更新哨兵状态：</strong>所有哨兵更新内存中的主节点地址信息</li>
                                <li><strong>持久化配置：</strong>新主节点信息写入哨兵的配置文件</li>
                                <li><strong>触发通知：</strong>进入"通知"环节，告知客户端主节点已切换</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>故障转移时间线（估算）：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
T+0s     : 主节点客观下线
T+0-5s   : 选举领头哨兵
T+5-10s  : 选择新主节点
T+10-15s : 提升从节点为主节点（SLAVEOF NO ONE）
T+15-30s : 其他从节点开始同步新主节点
T+30-60s : 所有从节点同步完成，故障转移结束
总计：30-60秒
                    </pre>
                    <p><strong>关键配置参数：</strong></p>
                    <ul>
                        <li><strong>failover-timeout：</strong>故障转移超时时间（默认180秒），超时后会重新尝试</li>
                        <li><strong>parallel-syncs：</strong>同时同步的从节点数量，默认1（逐个同步，避免网络压力）</li>
                        <li><strong>slave-priority：</strong>从节点优先级，影响新主节点的选择</li>
                    </ul>
                    <p><strong>失败重试机制：</strong></p>
                    <ul>
                        <li><strong>提升失败：</strong>如果选中的从节点无法提升（如网络故障），领头哨兵会选择下一个候选从节点</li>
                        <li><strong>同步失败：</strong>如果某个从节点同步失败，不影响其他从节点的同步</li>
                        <li><strong>超时重试：</strong>如果failover-timeout时间内未完成，会重新发起故障转移</li>
                    </ul>
                    <p><strong>数据一致性保证：</strong></p>
                    <ul>
                        <li><strong>可能丢失数据：</strong>旧主节点未同步到从节点的数据会丢失</li>
                        <li><strong>最小化丢失：</strong>通过选择复制偏移量最大的从节点，最小化数据丢失</li>
                        <li><strong>强一致性配置：</strong>配置min-slaves-to-write和min-slaves-max-lag，确保写操作至少同步到N个从节点</li>
                    </ul>
                    <p><strong>业务价值：</strong>实现主节点故障的自动切换，无需人工干预，在30-60秒内恢复服务，最大程度保证业务连续性。</p>
                `;
            } else if (type === 'sentinel-notification-process') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>通知：主节点切换信息发布业务流程</h4>
                    <p><strong>业务含义：</strong>故障转移完成后，哨兵将新的主节点地址信息告知后端服务（客户端），使客户端能够切换到新的主节点继续访问。</p>
                    <p><strong>触发条件：</strong></p>
                    <ul>
                        <li><strong>前置条件：</strong>自动故障转移完成，新主节点已上线</li>
                        <li><strong>从节点同步：</strong>所有从节点已开始或完成向新主节点的同步</li>
                        <li><strong>配置更新：</strong>哨兵已更新内存中的主节点地址信息</li>
                    </ul>
                    <p><strong>通知机制详解：</strong></p>
                    <ol>
                        <li><strong>机制1：发布/订阅（Pub/Sub）- 主动推送</strong>
                            <ul>
                                <li><strong>哨兵作为发布者：</strong>
                                    <ul>
                                        <li>哨兵通过Redis的发布/订阅机制发布事件消息</li>
                                        <li>使用专门的频道：__sentinel__:hello（哨兵间通信）</li>
                                        <li>使用事件频道：+switch-master（主节点切换）、+failover-end（故障转移结束）</li>
                                        <li>消息格式：JSON字符串，包含master-name、old-ip、new-ip、port等信息</li>
                                    </ul>
                                </li>
                                <li><strong>客户端作为订阅者：</strong>
                                    <ul>
                                        <li>后端服务启动时订阅哨兵的事件频道</li>
                                        <li>使用SUBSCRIBE命令订阅：SUBSCRIBE +switch-master</li>
                                        <li>建立长连接，实时接收哨兵发布的事件消息</li>
                                        <li>收到消息后解析JSON，提取新主节点的IP和端口</li>
                                    </ul>
                                </li>
                                <li><strong>实时性：</strong>毫秒级推送，客户端第一时间感知主节点变化</li>
                                <li><strong>可靠性：</strong>如果客户端断线，重连后可以重新订阅，但可能错过期间的消息</li>
                            </ul>
                        </li>
                        <li><strong>机制2：客户端主动查询 - 轮询拉取</strong>
                            <ul>
                                <li><strong>查询命令：</strong>客户端定期向哨兵发送SENTINEL get-master-addr-by-name <master-name>命令</li>
                                <li><strong>返回内容：</strong>当前主节点的IP和端口（如：192.168.2.10 6379）</li>
                                <li><strong>轮询间隔：</strong>客户端自己决定，通常为几秒到几十秒</li>
                                <li><strong>适用场景：</strong>
                                    <ul>
                                        <li>不支持订阅机制的客户端</li>
                                        <li>需要精确控制查询时机的场景</li>
                                        <li>作为订阅机制的补充和备份</li>
                                    </ul>
                                </li>
                                <li><strong>优点：</strong>简单可靠，客户端主动控制</li>
                                <li><strong>缺点：</strong>实时性差，可能延迟几秒到几十秒</li>
                            </ul>
                        </li>
                        <li><strong>机制3：哨兵配置文件 - 被动读取</strong>
                            <ul>
                                <li><strong>配置文件：</strong>哨兵会将当前主节点信息写入sentinel.conf配置文件</li>
                                <li><strong>持久化：</strong>即使哨兵重启，也能恢复主节点信息</li>
                                <li><strong>客户端读取：</strong>客户端可以读取配置文件获取主节点地址（较少使用）</li>
                                <li><strong>优点：</strong>持久化存储，不会丢失</li>
                                <li><strong>缺点：</strong>需要文件I/O，实时性最差</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>通知流程时序图：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
哨兵端：
T+0s   : 故障转移完成
T+0.1s : 发布事件到 +switch-master 频道
        消息内容：{"event":"+switch-master","master":"mymaster","from":"192.168.2.10","to":"192.168.2.11"}

客户端（订阅模式）：
T+0.2s : 收到订阅消息
        解析JSON，提取新主节点IP：192.168.2.11
T+0.3s : 关闭旧连接（连接192.168.2.10）
T+0.4s : 建立新连接（连接192.168.2.11）
T+0.5s : 发送PING命令测试新连接
T+0.6s : 继续业务操作

客户端（轮询模式）：
T+5s   : 发送SENTINEL get-master-addr-by-name mymaster
        返回：192.168.2.11 6379
T+5.1s : 更新连接，切换到新主节点
                    </pre>
                    <p><strong>客户端实现示例：</strong></p>
                    <pre style="background-color: #f4f4f4; padding: 10px; border-radius: 5px; font-size: 12px;">
// 伪代码：订阅模式
client.subscribe("+switch-master")
client.on("message", (channel, message) => {
    if (channel === "+switch-master") {
        const event = JSON.parse(message)
        if (event.master === "mymaster") {
            console.log("主节点切换: " + event.from + " -> " + event.to)
            // 更新连接
            redis_client.disconnect()
            redis_client.connect(event.to, 6379)
        }
    }
})

// 伪代码：轮询模式
setInterval(() => {
    const new_master = sentinel.get_master_addr_by_name("mymaster")
    if (new_master !== current_master) {
        console.log("检测到主节点变化: " + current_master + " -> " + new_master)
        current_master = new_master
        redis_client.reconnect(new_master)
    }
}, 5000)  // 每5秒查询一次
                    </pre>
                    <p><strong>通知内容（事件类型）：</strong></p>
                    <ul>
                        <li><strong>+switch-master：</strong>主节点切换事件（最重要）</li>
                        <li><strong>+failover-end：</strong>故障转移结束事件</li>
                        <li><strong>+redirect-to-master：</strong>从节点重定向到主节点</li>
                        <li><strong>-slave：</strong>从节点下线事件</li>
                        <li><strong>+slave：</strong>从节点上线事件</li>
                        <li><strong>+sdown：</strong>节点主观下线</li>
                        <li><strong>+odown：</strong>节点客观下线</li>
                    </ul>
                    <p><strong>同步 vs 异步通知：</strong></p>
                    <ul>
                        <li><strong>异步推送（订阅模式）：</strong>
                            <ul>
                                <li>哨兵发布消息后立即返回，不等待客户端确认</li>
                                <li>客户端异步接收消息，非阻塞</li>
                                <li>实时性高，但可能丢失消息（客户端断线期间）</li>
                            </ul>
                        </li>
                        <li><strong>同步拉取（轮询模式）：</strong>
                            <ul>
                                <li>客户端主动发起查询，等待哨兵响应</li>
                                <li>实时性差，但不会丢失信息</li>
                                <li>适合对实时性要求不高的场景</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>客户端连接切换最佳实践：</strong></p>
                    <ul>
                        <li><strong>同时使用两种机制：</strong>订阅模式为主，轮询模式为备份</li>
                        <li><strong>优雅重连：</strong>检测到连接断开后，延迟几秒再重连，避免频繁重连</li>
                        <li><strong>连接池管理：</strong>更新连接池中的所有连接，确保后续请求使用新主节点</li>
                        <li><strong>失败重试：</strong>切换到新主节点时，如果连接失败，记录日志并重试</li>
                        <li><strong>监控告警：</strong>主节点切换时发送告警通知，让运维人员感知</li>
                    </ul>
                    <p><strong>业务价值：</strong>通过主动推送和被动查询两种机制，确保客户端能够及时感知主节点变化并切换连接，最大程度减少业务中断时间，实现透明化的高可用切换。</p>
                `;
            } else if (type === 'connection-type') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>连接类型判断</h4>
                    <p><strong>作用：</strong>根据业务需求选择合适的通信协议。</p>
                    <p><strong>连接类型说明：</strong></p>
                    <ul>
                        <li><strong>HTTP连接：</strong>
                            <ul>
                                <li>适用于标准的请求-响应模式</li>
                                <li>无状态协议，每次请求独立</li>
                                <li>适合数据查询、表单提交等操作</li>
                                <li>支持缓存，易于扩展</li>
                            </ul>
                        </li>
                        <li><strong>WebSocket连接：</strong>
                            <ul>
                                <li>适用于实时双向通信场景</li>
                                <li>持久连接，低延迟</li>
                                <li>适合聊天、推送、实时通知等</li>
                                <li>服务器可主动推送数据给客户端</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>选择建议：</strong></p>
                    <ul>
                        <li>需要实时性：选择WebSocket</li>
                        <li>简单请求-响应：选择HTTP</li>
                        <li>需要服务器推送：选择WebSocket</li>
                        <li>需要广泛兼容性：选择HTTP</li>
                    </ul>
                    <p><strong>优势：</strong>灵活适应不同业务场景，优化用户体验和系统性能。</p>
                `;
            } else if (type === 'data-type') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>数据类型判断（热数据/冷数据）</h4>
                    <p><strong>作用：</strong>根据数据访问频率，将数据分类存储到不同的服务器。</p>
                    <p><strong>数据类型说明：</strong></p>
                    <ul>
                        <li><strong>热数据：</strong>
                            <ul>
                                <li>频繁访问的数据</li>
                                <li>最近创建或修改的数据</li>
                                <li>用户活跃数据</li>
                                <li>存储在独立的高性能服务器上</li>
                            </ul>
                        </li>
                        <li><strong>冷数据：</strong>
                            <li>不常访问的历史数据</li>
                            <li>归档数据</li>
                            <li>超过一定时间的数据（如一个月前）</li>
                            <li>存储在集合冷数据服务器上</li>
                        </ul>
                    </ul>
                    <p><strong>处理策略：</strong></p>
                    <ul>
                        <li><strong>热数据：</strong>快速响应，优先处理，使用高性能存储</li>
                        <li><strong>冷数据：</strong>定期备份到冷数据库，支持查询但性能较低</li>
                    </ul>
                    <p><strong>数据迁移：</strong></p>
                    <ul>
                        <li>定期（如每月）将热数据迁移到冷数据库</li>
                        <li>热数据服务器保留最近一段时间的数据</li>
                        <li>冷数据可以压缩存储，降低存储成本</li>
                    </ul>
                    <p><strong>优势：</strong>优化存储资源使用，提高热数据访问速度，降低存储成本。</p>
                `;
            } else if (type === 'redis-db-sync') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>Redis-DB定期同步</h4>
                    <p><strong>作用：</strong>定期将Redis缓存中的数据全量或增量同步到数据库，确保最终数据一致性，防止缓存数据丢失导致数据永久丢失。</p>
                    <p><strong>同步原因：</strong></p>
                    <ul>
                        <li><strong>缓存是易失性存储：</strong>Redis重启、故障时，内存数据会丢失</li>
                        <li><strong>缓存更新失败：</strong>写操作可能只更新了数据库，未更新Redis（或反之）</li>
                        <li><strong>数据不一致：</strong>长时间运行后，Redis和DB数据可能不一致</li>
                        <li><strong>数据恢复：</strong>故障恢复后，需要从DB重建Redis缓存</li>
                    </ul>
                    <p><strong>同步方式：</strong></p>
                    <ul>
                        <li><strong>全量同步：</strong>
                            <ul>
                                <li>将Redis中的所有数据扫描并写入DB</li>
                                <li>通常在业务低峰期执行（如凌晨）</li>
                                <li>优点：简单直接，数据完整</li>
                                <li>缺点：耗时长，对DB压力大</li>
                            </ul>
                        </li>
                        <li><strong>增量同步：</strong>
                            <ul>
                                <li>记录Redis的写操作日志（如通过Redis的RDB或AOF）</li>
                                <li>定期将增量的写操作同步到DB</li>
                                <li>优点：速度快，对DB压力小</li>
                                <li>缺点：实现复杂，需要处理日志顺序和重复</li>
                            </ul>
                        </li>
                        <li><strong>基于时间戳同步：</strong>
                            <ul>
                                <li>为每个缓存数据设置同步时间戳</li>
                                <li>定期查询超过一定时间未同步的数据</li>
                                <li>将这些数据写入DB并更新同步时间戳</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>同步策略：</strong></p>
                    <ul>
                        <li><strong>实时同步：</strong>每次写操作时，同时写DB和Redis（一致性最好，性能较差）</li>
                        <li><strong>准实时同步：</strong>写操作先写Redis，通过MQ异步写DB（性能好，最终一致性）</li>
                        <li><strong>定期同步：</strong>写操作只写Redis，定期（如每分钟）批量同步到DB（性能最好，一致性较弱）</li>
                        <li><strong>混合策略：</strong>核心数据实时同步，非核心数据定期同步</li>
                    </ul>
                    <p><strong>同步冲突处理：</strong></p>
                    <ul>
                        <li><strong>时间戳比较：</strong>比较Redis和DB的更新时间，取最新值</li>
                        <li><strong>版本号：</strong>使用版本号或CAS机制，防止覆盖更新的数据</li>
                        <li><strong>以DB为准：</strong>冲突时以DB数据为准（覆盖Redis）</li>
                        <li><strong>人工介入：</strong>记录冲突数据，人工核实处理</li>
                    </ul>
                    <p><strong>业务价值：</strong>保证Redis和DB的最终数据一致性，防止缓存数据丢失导致的数据永久丢失，是数据可靠性的最后一道保障。</p>
                `;
            } else if (type === 'message-queue') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>消息队列（异步解耦）</h4>
                    <p><strong>作用：</strong>通过消息队列实现系统异步解耦，提升系统响应速度和吞吐量，削峰填谷，增强系统弹性。</p>
                    <p><strong>核心价值：</strong></p>
                    <ul>
                        <li><strong>异步解耦：</strong>发送者和接收者无需直接依赖，通过MQ解耦</li>
                        <li><strong>提升性能：</strong>同步变异步，主流程快速返回，耗时操作异步处理</li>
                        <li><strong>削峰填谷：</strong>高峰期消息堆积在MQ，低峰期消费，避免系统被压垮</li>
                        <li><strong>可靠性：</strong>消息持久化，即使消费者故障，消息不丢失</li>
                    </ul>
                    <p><strong>常见消息队列：</strong></p>
                    <ul>
                        <li><strong>Kafka：</strong>
                            <ul>
                                <li>高吞吐量（百万级/秒）</li>
                                <li>适合日志采集、流式处理</li>
                                <li>支持消息回溯（重播历史消息）</li>
                            </ul>
                        </li>
                        <li><strong>RabbitMQ：</strong>
                            <ul>
                                <li>功能完善，支持多种消息协议</li>
                                <li>适合复杂路由、延迟队列场景</li>
                                <li>可靠性高，支持事务消息</li>
                            </ul>
                        </li>
                        <li><strong>RocketMQ：</strong>
                            <ul>
                                <li>阿里开源，适合电商场景</li>
                                <li>支持事务消息（解决最终一致性）</li>
                                <li>支持定时消息、顺序消息</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>消息模式：</strong></p>
                    <ul>
                        <li><strong>点对点（Point-to-Point）：</strong>一条消息只被一个消费者消费（如：任务队列）</li>
                        <li><strong>发布订阅（Pub/Sub）：</strong>一条消息被多个消费者消费（如：广播通知）</li>
                        <li><strong>顺序消费：</strong>保证消息按顺序消费（如：订单状态流转）</li>
                        <li><strong>事务消息：</strong>保证消息发送和本地事务的一致性（如：下单→发消息→扣库存）</li>
                    </ul>
                    <p><strong>典型应用场景：</strong></p>
                    <ul>
                        <li><strong>异步处理：</strong>用户注册 → 发送消息 → 异步发送欢迎邮件、初始化用户数据</li>
                        <li><strong>系统解耦：</strong>订单系统 → 发送消息 → 库存系统、物流系统、通知系统并行消费</li>
                        <li><strong>流量削峰：</strong>秒杀请求 → 写入MQ → 后台慢慢处理订单，避免压垮库存系统</li>
                        <li><strong>日志收集：</strong>应用日志 → 发送到Kafka → 日志系统、监控系统消费</li>
                        <li><strong>事件驱动：</strong>数据变更 → 发送事件消息 → 触发下游业务（如：数据同步、缓存刷新）</li>
                    </ul>
                    <p><strong>消息可靠性保证：</strong></p>
                    <ul>
                        <li><strong>消息持久化：</strong>消息写入磁盘，防止MQ宕机导致消息丢失</li>
                        <li><strong>消费确认（ACK）：</strong>消费者处理完消息后发送ACK，MQ才删除消息</li>
                        <li><strong>重试机制：</strong>消费失败时自动重试（指数退避）</li>
                        <li><strong>死信队列：</strong>重试多次仍失败的消息，进入死信队列，人工处理</li>
                    </ul>
                    <p><strong>业务价值：</strong>通过异步解耦提升系统响应速度和吞吐量，通过削峰填谷增强系统弹性，通过消息持久化保证可靠性。</p>
                `;
            } else if (type === 'full-link-monitoring') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>全链路监控</h4>
                    <p><strong>作用：</strong>追踪请求从前端到后端的完整调用链路，记录每个环节的耗时、状态，帮助快速定位性能瓶颈和故障点。</p>
                    <p><strong>核心能力：</strong></p>
                    <ul>
                        <li><strong>链路追踪：</strong>记录请求经过的所有服务、接口、数据库</li>
                        <li><strong>性能分析：</strong>统计每个环节的耗时、吞吐量、成功率</li>
                        <li><strong>故障定位：</strong>快速定位慢查询、异常调用、错误率高的接口</li>
                        <li><strong>依赖拓扑：</strong>自动生成服务调用关系图，展示服务依赖</li>
                    </ul>
                    <p><strong>常见全链路监控工具：</strong></p>
                    <ul>
                        <li><strong>SkyWalking：</strong>
                            <ul>
                                <li>国产开源，专注于APM（应用性能管理）</li>
                                <li>支持Java、.NET、Node.js等多语言</li>
                                <li>可视化界面友好，支持告警</li>
                            </ul>
                        </li>
                        <li><strong>Zipkin：</strong>
                            <ul>
                                <li>Twitter开源，轻量级</li>
                                <li>适合微服务架构</li>
                                <li>集成简单，但功能相对基础</li>
                            </ul>
                        </li>
                        <li><strong>Jaeger：</strong>
                            <ul>
                                <li>Uber开源，兼容OpenTelemetry标准</li>
                                <li>支持大规模部署</li>
                                <li>适合云原生架构</li>
                            </ul>
                        </li>
                        <li><strong>Pinpoint：</strong>
                            <ul>
                                <li>韩国开源，字节码注入，无侵入</li>
                                <li>功能强大，定位精确到代码行级别</li>
                                <li>性能开销相对较大</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>核心概念：</strong></p>
                    <ul>
                        <li><strong>Trace（链路）：</strong>一个完整的请求调用链路（从用户请求到响应）</li>
                        <li><strong>Span（跨度）：</strong>链路中的单个调用（如：调用Redis、调用DB、调用外部接口）</li>
                        <li><strong>TraceID：</strong>链路唯一标识，串联整个调用链</li>
                        <li><strong>SpanID：</strong>跨度标识，记录单个调用的父子关系</li>
                    </ul>
                    <p><strong>监控指标：</strong></p>
                    <ul>
                        <li><strong>响应时间（RT）：</strong>平均响应时间、P99响应时间（99%请求的响应时间）</li>
                        <li><strong>吞吐量（QPS）：</strong>每秒请求数、峰值QPS</li>
                        <li><strong>错误率：</strong>HTTP错误码占比、异常占比</li>
                        <li><strong>慢查询：</strong>响应时间超过阈值的请求（如：>1秒）</li>
                    </ul>
                    <p><strong>Trace传递机制：</strong></p>
                    <ul>
                        <li><strong>线程上下文：</strong>在同一线程内的调用，TraceID通过ThreadLocal传递</li>
                        <li><strong>跨进程传递：</strong>通过HTTP Header（如：X-Trace-Id）或RPC元数据传递</li>
                        <li><strong>异步传递：</strong>异步线程池、消息队列消费时，需要手动传递TraceID</li>
                    </ul>
                    <p><strong>典型监控界面：</strong></p>
                    <ul>
                        <li><strong>调用链路图：</strong>可视化展示服务调用关系和耗时占比</li>
                        <li><strong>慢查询Top榜：</strong>展示响应时间最慢的接口和SQL</li>
                        <li><strong>错误率统计：</strong>展示错误率高的服务和接口</li>
                        <li><strong>依赖拓扑图：</strong>自动生成服务依赖关系图</li>
                    </ul>
                    <p><strong>业务价值：</strong>快速定位性能瓶颈和故障点，优化系统性能，提升故障排查效率，保障系统稳定运行。</p>
                `;
            } else if (type === 'alert-center') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>告警中心</h4>
                    <p><strong>作用：</strong>收集系统监控指标和日志，根据预设规则触发告警，及时通知运维人员处理故障，保障系统稳定运行。</p>
                    <p><strong>核心功能：</strong></p>
                    <ul>
                        <li><strong>数据采集：</strong>采集系统指标（CPU、内存、磁盘、网络）、应用指标（QPS、RT、错误率）</li>
                        <li><strong>告警规则：</strong>配置告警阈值（如：CPU>80%、错误率>5%、响应时间>1秒）</li>
                        <li><strong>告警聚合：</strong>相同告警聚合，避免告警轰炸</li>
                        <li><strong>告警通知：</strong>通过邮件、短信、钉钉、企业微信、电话通知</li>
                        <li><strong>告警确认：</strong>运维确认告警，避免重复通知</li>
                    </ul>
                    <p><strong>常见监控系统：</strong></p>
                    <ul>
                        <li><strong>Prometheus + Grafana：</strong>
                            <ul>
                                <li>Prometheus：数据采集和存储（时序数据库）</li>
                                <li>Grafana：可视化展示和告警</li>
                                <li>适合云原生、容器化环境</li>
                            </ul>
                        </li>
                        <li><strong>Zabbix：</strong>
                            <ul>
                                <li>老牌监控工具，功能全面</li>
                                <li>支持多种监控项和告警方式</li>
                                <li>适合传统服务器监控</li>
                            </ul>
                        </li>
                        <li><strong>ELK Stack（Elasticsearch + Logstash + Kibana）：</strong>
                            <ul>
                                <li>日志采集、存储、分析和可视化</li>
                                <li>适合日志分析和告警</li>
                            </ul>
                        </li>
                    </ul>
                    <p><strong>告警级别：</strong></p>
                    <ul>
                        <li><strong>P0（严重）：</strong>系统不可用（如：服务宕机、数据库连接失败），需要立即处理</li>
                        <li><strong>P1（重要）：</strong>核心功能异常（如：下单失败、支付失败），需要快速处理</li>
                        <li><strong>P2（一般）：</strong>非核心功能异常（如：评论失败、推荐失败），需要处理</li>
                        <li><strong>P4（提示）：</strong>性能下降（如：响应变慢、CPU升高），需要关注</li>
                    </ul>
                    <p><strong>告警规则示例：</strong></p>
                    <ul>
                        <li><strong>系统指标：</strong>CPU使用率>80%持续5分钟、内存使用率>90%、磁盘使用率>85%</li>
                        <li><strong>应用指标：</strong>QPS突然下降50%、错误率>5%、响应时间P99>2秒</li>
                        <li><strong>业务指标：</strong>订单量异常下降、支付成功率<90%</li>
                    </ul>
                    <p><strong>告警收敛策略：</strong></p>
                    <ul>
                        <li><strong>时间窗口：</strong>相同告警在N分钟内只发送一次（避免重复通知）</li>
                        <li><strong>告警升级：</strong>P4告警未确认，N分钟后自动升级为P2</li>
                        <li><strong>告警聚合：</strong>多个实例的相同告警合并为一条</li>
                        <li><strong>静默期：</strong>维护期间自动屏蔽告警</li>
                    </ul>
                    <p><strong>告警通知渠道：</strong></p>
                    <ul>
                        <li><strong>邮件：</strong>适合非紧急告警，记录完整信息</li>
                        <li><strong>短信：</strong>适合紧急告警（P0、P1），确保及时触达</li>
                        <li><strong>钉钉/企业微信：</strong>支持群消息和@人，适合团队协作</li>
                        <li><strong>电话：</strong>适合P0严重告警，确保处理人及时响应</li>
                    </ul>
                    <p><strong>业务价值：</strong>及时感知系统异常，快速响应故障，保障系统可用性和用户体验，是系统稳定运行的重要保障。</p>
                `;
            } else if (type === 'login-service') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>登录认证服务（Login Service）</h4>
                    <p><strong>作用：</strong>负责用户注册、登录、密码管理、身份认证等核心安全功能。</p>
                    <p><strong>订阅事件：</strong>用户注册成功、密码修改成功、手机号变更</p>
                    <p><strong>处理逻辑：</strong></p>
                    <ul>
                        <li><strong>用户注册：</strong>创建用户账号、发送欢迎短信/邮件</li>
                        <li><strong>密码修改：</strong>发送安全通知（短信/邮件）</li>
                        <li><strong>手机号变更：</strong>重新验证新手机号</li>
                    </ul>
                    <p><strong>自身数据存储：</strong></p>
                    <ul>
                        <li><strong>Redis：</strong>Token缓存（30分钟TTL）、用户登录状态、验证码（5分钟TTL）</li>
                        <li><strong>DB：</strong>用户基本信息、登录历史、认证日志</li>
                    </ul>
                    <p><strong>业务价值：</strong>保障系统安全，防止未授权访问，提供可靠的身份认证服务。</p>
                `;
            } else if (type === 'im-service') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>即时通讯服务（IM Service）</h4>
                    <p><strong>作用：</strong>提供实时聊天、推送、WebSocket连接管理等即时通讯功能。</p>
                    <p><strong>订阅事件：</strong>用户注册成功、订单创建成功、订单状态变更、客服消息</p>
                    <p><strong>处理逻辑：</strong></p>
                    <ul>
                        <li><strong>用户注册：</strong>创建IM账号，分配好友列表</li>
                        <li><strong>订单创建：</strong>推送订单通知到用户App</li>
                        <li><strong>订单状态变更：</strong>推送物流信息、发货通知</li>
                        <li><strong>客服消息：</strong>实时推送给用户和客服</li>
                    </ul>
                    <p><strong>自身数据存储：</strong></p>
                    <ul>
                        <li><strong>Redis：</strong>用户会话信息（在线状态）、未读消息数、WebSocket连接信息</li>
                        <li><strong>DB：</strong>聊天消息记录、群组信息、好友关系</li>
                    </ul>
                    <p><strong>业务价值：</strong>提供实时沟通能力，提升用户体验，支持客服、社交等场景。</p>
                `;
            } else if (type === 'video-service') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>视频服务（Video Service）</h4>
                    <p><strong>作用：</strong>处理视频上传、转码、存储、播放等视频相关功能。</p>
                    <p><strong>订阅事件：</strong>用户注册成功、视频上传完成、视频审核通过</p>
                    <p><strong>处理逻辑：</strong></p>
                    <ul>
                        <li><strong>用户注册：</strong>初始化用户视频空间，分配默认权限</li>
                        <li><strong>视频上传：</strong>触发转码（标清、高清、超清），生成缩略图</li>
                        <li><strong>审核通过：</strong>更新视频状态为"已发布"，通知用户</li>
                    </ul>
                    <p><strong>自身数据存储：</strong></p>
                    <ul>
                        <li><strong>Redis：</strong>视频元信息（标题、时长、播放数）、热门视频排行榜</li>
                        <li><strong>DB：</strong>视频元数据、转码记录、播放历史</li>
                        <li><strong>对象存储：</strong>视频文件（OSS）</li>
                    </ul>
                    <p><strong>业务价值：</strong>提供完整的视频处理能力，支持UGC、短视频、直播等场景。</p>
                `;
            } else if (type === 'order-service') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>商品订单服务（Order Service）</h4>
                    <p><strong>作用：</strong>处理订单创建、支付、退款、库存管理等核心交易功能。</p>
                    <p><strong>订阅事件：</strong>订单创建成功、订单支付成功、订单取消、订单退款</p>
                    <p><strong>处理逻辑：</strong></p>
                    <ul>
                        <li><strong>订单创建：</strong>扣减库存（分布式锁保证），生成订单号</li>
                        <li><strong>支付成功：</strong>更新订单状态为"已支付"，通知发货服务</li>
                        <li><strong>订单取消：</strong>恢复库存，处理退款</li>
                    </ul>
                    <p><strong>自身数据存储：</strong></p>
                    <ul>
                        <li><strong>Redis：</strong>订单信息（热点订单，最近7天）、实时库存、购物车数据</li>
                        <li><strong>DB：</strong>订单详情、商品信息、交易流水</li>
                    </ul>
                    <p><strong>业务价值：</strong>处理核心交易流程，保证库存准确，支持秒杀、抢购等高并发场景。</p>
                `;
            } else if (type === 'customer-service') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>客服服务（Customer Service）</h4>
                    <p><strong>作用：</strong>提供工单管理、客服聊天、投诉处理、售后支持等客户服务功能。</p>
                    <p><strong>订阅事件：</strong>订单创建成功、用户投诉、退款申请、评价提交</p>
                    <p><strong>处理逻辑：</strong></p>
                    <ul>
                        <li><strong>订单创建：</strong>自动创建工单，准备售后支持</li>
                        <li><strong>用户投诉：</strong>分配客服人员，优先处理</li>
                        <li><strong>退款申请：</strong>触发退款流程，通知财务</li>
                    </ul>
                    <p><strong>自身数据存储：</strong></p>
                    <ul>
                        <li><strong>Redis：</strong>待处理工单队列、客服在线状态、常见问题FAQ</li>
                        <li><strong>DB：</strong>工单详情、聊天记录、评价信息</li>
                    </ul>
                    <p><strong>业务价值：</strong>提供完整的客户服务能力，提升用户满意度，降低客服成本。</p>
                `;
            } else if (type === 'merchant-service') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>商户管理服务（Merchant Service）</h4>
                    <p><strong>作用：</strong>为商户提供订单管理、账户余额、结算、对账等商家服务功能。</p>
                    <p><strong>订阅事件：</strong>订单创建成功、订单支付成功、商户入驻申请</p>
                    <p><strong>处理逻辑：</strong></p>
                    <ul>
                        <li><strong>订单创建：</strong>推送新订单通知到商户App，发送短信提醒</li>
                        <li><strong>支付成功：</strong>更新商户账户余额（分布式锁保护），生成结算单</li>
                        <li><strong>入驻申请：</strong>触发审核流程，通知运营人员</li>
                    </ul>
                    <p><strong>自身数据存储：</strong></p>
                    <ul>
                        <li><strong>Redis：</strong>商户基本信息、账户余额（实时）、今日订单数、分布式锁（lock:merchant:*）</li>
                        <li><strong>DB：</strong>商户详细信息、账户余额、结算记录、交易流水</li>
                    </ul>
                    <p><strong>关键流程示例（更新商户余额）：</strong></p>
                    <ol>
                        <li>消费MQ消息：订单支付成功事件</li>
                        <li>获取分布式锁：SET lock:merchant:balance:{商户ID}</li>
                        <li>查询Redis余额：GET merchant:balance:{商户ID}</li>
                        <li>计算新余额：当前余额 + 到账金额</li>
                        <li>DB事务更新：UPDATE账户余额 + INSERT交易流水 + COMMIT</li>
                        <li>更新Redis缓存：SET merchant:balance:{商户ID}</li>
                        <li>释放分布式锁：DEL lock</li>
                    </ol>
                    <p><strong>为什么需要分布式锁：</strong>防止并发问题！当前余额100元，订单A(+50元)和订单B(+30元)同时支付，没有锁会导致最终余额130元（错误，应该是180元），有锁保证最终余额180元（正确）。</p>
                    <p><strong>业务价值：</strong>为商户提供完整的订单和财务管理能力，保证资金安全，支持对账和结算。</p>
                `;
            } else if (type === 'login-service-db' || type === 'im-service-db' || type === 'video-service-db' || type === 'order-service-db' || type === 'customer-service-db' || type === 'merchant-service-db') {
                const serviceNameMap = {
                    'login-service-db': '登录认证服务',
                    'im-service-db': '即时通讯服务',
                    'video-service-db': '视频服务',
                    'order-service-db': '商品订单服务',
                    'customer-service-db': '客服服务',
                    'merchant-service-db': '商户管理服务'
                };
                const serviceName = serviceNameMap[type] || '微服务';
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>${serviceName}的数据存储架构</h4>
                    <p><strong>核心原则：</strong>每个微服务都有自己独立的Redis和DB实例，不共享数据存储。服务间通过MQ交换数据，而非直接访问对方的DB。</p>
                    <p><strong>Redis存储（缓存层）：</strong></p>
                    <ul>
                        <li><strong>热点数据：</strong>频繁访问的数据，响应时间&lt;5ms</li>
                        <li><strong>会话状态：</strong>在线状态、未读消息数、购物车数据</li>
                        <li><strong>分布式锁：</strong>保证并发安全的锁机制</li>
                        <li><strong>计数器：</strong>实时统计、订单数、播放数等</li>
                    </ul>
                    <p><strong>DB存储（持久化层）：</strong></p>
                    <ul>
                        <li><strong>业务数据：</strong>完整的业务记录，持久化保存</li>
                        <li><strong>历史记录：</strong>聊天记录、交易流水、操作日志</li>
                        <li><strong>关系数据：</strong>用户关系、好友关系、订单详情</li>
                    </ul>
                    <p><strong>典型查询流程：</strong></p>
                    <ol>
                        <li><strong>查询Redis：</strong>GET key（1-5ms）</li>
                        <li><strong>命中：</strong>直接返回数据</li>
                        <li><strong>未命中：</strong>查询DB（10-100ms）→ 写入Redis → 返回数据</li>
                    </ol>
                    <p><strong>写入流程（带分布式锁）：</strong></p>
                    <ol>
                        <li><strong>获取锁：</strong>SET lock:key NX PX 30000</li>
                        <li><strong>查询Redis：</strong>GET key（获取当前值）</li>
                        <li><strong>计算新值：</strong>业务逻辑计算</li>
                        <li><strong>DB事务更新：</strong>START TRANSACTION → UPDATE/INSERT → COMMIT</li>
                        <li><strong>更新Redis：</strong>SET key 新值</li>
                        <li><strong>释放锁：</strong>DEL lock</li>
                    </ol>
                    <p><strong>为什么每个服务独立Redis+DB：</strong></p>
                    <ul>
                        <li><strong>数据隔离：</strong>服务间数据完全隔离，避免误操作</li>
                        <li><strong>独立扩展：</strong>可根据负载独立扩展（如：订单数据量大，分100个表）</li>
                        <li><strong>技术选型灵活：</strong>可选不同存储（MySQL、MongoDB、OSS等）</li>
                        <li><strong>故障隔离：</strong>某个服务DB故障不影响其他服务</li>
                    </ul>
                    <p><strong>业务价值：</strong>通过独立的Redis+DB架构，实现数据隔离、独立扩展、故障隔离，是微服务架构的核心原则（Database per Service）。</p>
                `;
            }
            tooltip.innerHTML = content;

            document.body.appendChild(tooltip);

            // 定位到旁边
            const rect = target.getBoundingClientRect();
            const tooltipWidth = 300;
            const tooltipHeight = 200; // 估算
            let left, top = rect.top + window.scrollY;

            if (type === 'WebSocket') {
                left = rect.left + window.scrollX - tooltipWidth - 10;
            } else { // HTTP
                left = rect.right + window.scrollX + 10;
            }

            // 确保不超出视窗
            if (left < 0) left = 10;
            if (left + tooltipWidth > window.innerWidth) left = window.innerWidth - tooltipWidth - 10;
            if (top + tooltipHeight > window.innerHeight + window.scrollY) top = rect.top + window.scrollY - tooltipHeight - 10;

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';

            currentTooltip = tooltip;
            currentTarget = target;
        }

        function closeTooltip() {
            if (currentTooltip) {
                document.body.removeChild(currentTooltip);
                currentTooltip = null;
                currentTarget = null;
            }
        }
    </script>
</body>
</html>