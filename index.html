<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>前端App与后端交互业务流程（详细版）</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        h1, h2, h3 {
            color: #007bff;
        }
        .section {
            margin-bottom: 20px;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .step {
            cursor: pointer;
            padding: 10px;
            margin: 5px 0;
            background-color: #e9ecef;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        .step:hover {
            background-color: #d6d8db;
        }
        .details {
            display: none;
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-left: 4px solid #007bff;
        }
        .tooltip {
            position: absolute;
            background-color: #f8f9fa;
            border: 1px solid #007bff;
            border-radius: 5px;
            padding: 10px;
            max-width: 300px;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .tooltip .close-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            cursor: pointer;
            font-size: 16px;
            color: #007bff;
        }
        button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .module {
            background-color: #fff3cd;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>前端App与后端交互业务流程（详细版）</h1>
    <p>基于您的描述，重新梳理了详细业务流程，强调网关分发、数据校验、缓存策略、分库分表、冷热数据分离、备份等。整体设计高度解耦、高度内聚，模块化架构。</p>

    <div id="flowchart" class="section">
        <h2>整体架构与流程图</h2>
        <div class="mermaid">
            graph TD
                A[前端App/Web] --> B{连接类型}
                B -->|HTTP| C[Nginx网关]
                B -->|WebSocket| C
                C --> D[分发到后端服务]
                D --> E[用户中台模块: 认证校验]
                E --> F[业务模块: 操作处理]
                F --> G{读/写操作}
                G -->|读| H[Redis查询]
                H -->|命中| I[返回数据]
                H -->|未命中| J[数据库查询]
                J --> K[更新Redis]
                K --> I
                G -->|写| L[Redis检查]
                L -->|有数据| M[更新Redis & 事务更新DB]
                L -->|无数据| N[查询DB & 事务更新DB & 更新Redis]
                M --> O[定时刷新Redis-DB]
                N --> O
                O --> P[分库分表处理]
                P --> Q{数据类型}
                Q -->|热数据| R[独立热数据服务器]
                Q -->|冷数据| S[集合冷数据服务器]
                S --> T[冷数据备份: 一个月前数据到备份DB]
                T --> U[可查询冷DB]
                R --> V[事务保护]
                S --> V
        </div>
    </div>

    <button onclick="toggleAllDetails()">展开/折叠所有详情</button>

    <div class="section">
        <h2>1. 前端发送环节</h2>
        <div class="step" onclick="toggleDetails('frontend')">点击查看详情</div>
        <div id="frontend" class="details">
            <p><strong>连接类型区分：</strong></p>
            <ul>
                <li><strong>普通网络连接（HTTP）：</strong>用于标准请求/响应，如GET/POST。</li>
                <li><strong>WebSocket连接：</strong>用于实时双向通信，如聊天、推送。</li>
            </ul>
            <p><strong>网关分发：</strong>Nginx作为网关，负责负载均衡、路由分发到后端服务。</p>
        </div>
    </div>

    <div class="section">
        <h2>2. 后端接收与校验环节</h2>
        <div class="step" onclick="toggleDetails('validation')">点击查看详情</div>
        <div id="validation" class="details">
            <p><strong>数据校验：</strong></p>
            <ul>
                <li>ID匹配：验证请求中的用户ID。</li>
                <li>Token匹配：JWT/OAuth验证用户身份。</li>
            </ul>
            <p><strong>用户确定：</strong>通过校验确定用户上下文，路由到相应业务模块。</p>
        </div>
    </div>

    <div class="section">
        <h2>3. 业务处理环节（读写操作）</h2>
        <div class="step" onclick="toggleDetails('business')">点击查看详情</div>
        <div id="business" class="details">
            <p><strong>读操作：</strong></p>
            <ol>
                <li>优先查询Redis缓存。</li>
                <li>未命中则查询数据库。</li>
                <li>查询后立即更新Redis（事务性）。</li>
            </ol>
            <p><strong>写操作：</strong></p>
            <ol>
                <li>检查Redis是否有数据。</li>
                <li>有：更新Redis和数据库（事务）。</li>
                <li>无：查询数据库，更新数据库和Redis（事务）。</li>
            </ol>
            <p><strong>Redis-DB同步：</strong>定时刷新机制，确保一致性。</p>
        </div>
    </div>

    <div class="section">
        <h2>4. 数据库架构与优化</h2>
        <div class="step" onclick="toggleDetails('database')">点击查看详情</div>
        <div id="database" class="details">
            <p><strong>分库分表：</strong>根据业务拆分数据库和表，降低单库压力。</p>
            <p><strong>热数据分离：</strong></p>
            <ul>
                <li>频繁查询热数据：抽取到独立服务器。</li>
                <li>不频繁冷数据：放到集合服务器。</li>
            </ul>
            <p><strong>事务保护：</strong>确保读写一致性，避免并发问题。</p>
            <p><strong>冷热数据备份：</strong>一个月前数据备份到冷数据库，支持查询但性能较低。</p>
        </div>
    </div>

    <div class="section">
        <h2>5. 模块化设计（高度解耦、内聚）</h2>
        <div class="step" onclick="toggleDetails('modules')">点击查看详情</div>
        <div id="modules" class="details">
            <div class="module"><strong>用户中台模块：</strong>负责认证、用户管理、权限控制。</div>
            <div class="module"><strong>缓存模块：</strong>Redis操作、定时刷新逻辑。</div>
            <div class="module"><strong>数据库模块：</strong>ORM、分库分表、事务管理。</div>
            <div class="module"><strong>业务模块：</strong>具体业务逻辑，如订单、查询等。</div>
            <div class="module"><strong>网关模块：</strong>Nginx配置、路由分发。</div>
            <div class="module"><strong>备份模块：</strong>冷数据迁移、备份策略。</div>
            <p>每个模块独立部署，支持微服务架构。</p>
        </div>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: true });

        window.addEventListener('load', function() {
            console.log('Window loaded');
            // 等待Mermaid渲染完成
            setTimeout(function() {
                console.log('Timeout triggered');
                const svg = document.querySelector('.mermaid svg');
                console.log('SVG found:', svg);
                if (svg) {
                    const texts = svg.querySelectorAll('text');
                    const tspans = svg.querySelectorAll('tspan');
                    const gs = svg.querySelectorAll('g');
                    console.log('Texts found:', texts.length);
                    console.log('Tspans found:', tspans.length);
                    console.log('Gs found:', gs.length);
                    gs.forEach(g => {
                        const text = g.textContent.trim();
                        if (text === 'HTTP' || text === 'WebSocket' || text === '前端App/Web') {
                            console.log('G with exact match:', text);
                            g.style.cursor = 'pointer';
                            g.addEventListener('click', function() {
                                let type;
                                if (text === 'HTTP') type = 'HTTP';
                                else if (text === 'WebSocket') type = 'WebSocket';
                                else if (text === '前端App/Web') type = 'frontend';
                                console.log('Clicked G:', type);
                                toggleTooltip(this, type);
                            });
                        }
                    });
                    [...texts, ...tspans].forEach(text => {
                        const content = text.textContent.trim();
                        console.log('Text/Tspan content:', content);
                        if (content.includes('HTTP') || content.includes('WebSocket')) {
                            console.log('Match found for:', content);
                            text.style.cursor = 'pointer';
                            text.style.fill = '#007bff'; // 蓝色表示可点击
                            text.addEventListener('click', function() {
                                const type = content.includes('HTTP') ? 'HTTP' : 'WebSocket';
                                console.log('Clicked:', type);
                                toggleTooltip(this, type);
                            });
                        }
                    });
                }
            }, 2000); // 增加延迟到2秒
        });

        let currentTooltip = null;
        let currentTarget = null;

        function toggleTooltip(target, type) {
            if (currentTooltip && currentTarget === target) {
                // 隐藏
                document.body.removeChild(currentTooltip);
                currentTooltip = null;
                currentTarget = null;
                return;
            }

            // 隐藏之前的
            if (currentTooltip) {
                document.body.removeChild(currentTooltip);
            }

            // 创建新的
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';

            let content = '';
            if (type === 'HTTP') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>HTTP连接说明</h4>
                    <p><strong>定义：</strong>超文本传输协议，用于客户端和服务器之间的请求-响应通信。</p>
                    <p><strong>特点：</strong>无状态、简单、易扩展。</p>
                    <p><strong>案例：</strong>用户登录、提交表单、API调用。</p>
                    <p><strong>优势：</strong>广泛支持，易缓存。</p>
                    <p><strong>劣势：</strong>不适合实时通信。</p>
                `;
            } else if (type === 'WebSocket') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>WebSocket连接说明</h4>
                    <p><strong>定义：</strong>全双工通信协议，允许服务器推送数据。</p>
                    <p><strong>特点：</strong>持久连接、低延迟、双向。</p>
                    <p><strong>案例：</strong>聊天、实时通知、游戏。</p>
                    <p><strong>优势：</strong>实时性强。</p>
                    <p><strong>劣势：</strong>实现复杂。</p>
                `;
            } else if (type === 'frontend') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>前端App/Web准备数据说明</h4>
                    <p><strong>基础校验数据：</strong></p>
                    <ul>
                        <li><strong>Token：</strong>根据用户ID生成，具有唯一性，用于身份验证。</li>
                        <li><strong>Token位置：</strong>通常放在HTTP请求头（Header）中，如Authorization: Bearer <token>。不建议放在请求体（Data）中，以避免暴露。</li>
                        <li><strong>其他必传数据：</strong>用户ID（用于关联）、时间戳（防止重放攻击）、请求签名（可选，用于额外安全）。</li>
                    </ul>
                    <p><strong>业务数据：</strong>根据具体操作上传，如表单数据、文件等（标识化处理）。</p>
                    <p><strong>注意：</strong>确保数据格式正确，敏感信息加密传输。</p>
                `;
            }
            tooltip.innerHTML = content;

            document.body.appendChild(tooltip);

            // 定位到旁边
            const rect = target.getBoundingClientRect();
            const tooltipWidth = 300;
            const tooltipHeight = 200; // 估算
            let left, top = rect.top + window.scrollY;

            if (type === 'WebSocket') {
                left = rect.left + window.scrollX - tooltipWidth - 10;
            } else { // HTTP
                left = rect.right + window.scrollX + 10;
            }

            // 确保不超出视窗
            if (left < 0) left = 10;
            if (left + tooltipWidth > window.innerWidth) left = window.innerWidth - tooltipWidth - 10;
            if (top + tooltipHeight > window.innerHeight + window.scrollY) top = rect.top + window.scrollY - tooltipHeight - 10;

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';

            currentTooltip = tooltip;
            currentTarget = target;
        }

        function closeTooltip() {
            if (currentTooltip) {
                document.body.removeChild(currentTooltip);
                currentTooltip = null;
                currentTarget = null;
            }
        }
    </script>
</body>
</html>