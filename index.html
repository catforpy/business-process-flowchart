<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>前端App与后端交互业务流程（详细版）</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        h1, h2, h3 {
            color: #007bff;
        }
        .section {
            margin-bottom: 20px;
            padding: 15px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .step {
            cursor: pointer;
            padding: 10px;
            margin: 5px 0;
            background-color: #e9ecef;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        .step:hover {
            background-color: #d6d8db;
        }
        .details {
            display: none;
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-left: 4px solid #007bff;
        }
        .tooltip {
            position: absolute;
            background-color: #f8f9fa;
            border: 1px solid #007bff;
            border-radius: 5px;
            padding: 10px;
            max-width: 300px;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .tooltip .close-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            cursor: pointer;
            font-size: 16px;
            color: #007bff;
        }
        button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .module {
            background-color: #fff3cd;
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>前端App与后端交互业务流程（详细版）</h1>
    <p>基于您的描述，重新梳理了详细业务流程，强调网关分发、数据校验、缓存策略、分库分表、冷热数据分离、备份等。整体设计高度解耦、高度内聚，模块化架构。</p>

    <div id="flowchart" class="section">
        <h2>整体架构与流程图</h2>
        <div class="mermaid">
            graph TD
                A[前端App/Web] --> B{连接类型}
                B -->|HTTP| C[Nginx网关]
                B -->|WebSocket| C
                C --> D[分发到后端服务]
                D --> E1[后端服务1]
                D --> E2[后端服务2]
                D --> E3[后端服务3]
                E1 --> F[用户中台模块: 认证校验]
                E2 --> F
                E3 --> F
                F --> G[业务模块: 操作处理]
                G --> DBOp{需要数据库操作}
                DBOp -->|是| H{读/写操作}
                DBOp -->|否| X[返回Nginx网关]
                X --> C
                H -->|读| I[Redis查询]
                I -->|命中| J[返回数据]
                J --> G
                I -->|未命中| K[数据库查询]
                K --> L[更新Redis]
                L --> J
                H -->|写| M[Redis检查]
                M -->|有数据| N[更新Redis & 事务更新DB]
                M -->|无数据| O[查询DB & 事务更新DB & 更新Redis]
                N --> P[定时刷新Redis-DB]
                O --> P
                P --> Q[分库分表处理]
                Q --> R{数据类型}
                R -->|热数据| S[独立热数据服务器]
                R -->|冷数据| T[集合冷数据服务器]
                T --> U[冷数据备份: 一个月前数据到备份DB]
                U --> V[可查询冷DB]
                S --> W[事务保护]
                T --> W
        </div>
    </div>

    <button onclick="toggleAllDetails()">展开/折叠所有详情</button>

    <div class="section">
        <h2>1. 前端发送环节</h2>
        <div class="step" onclick="toggleDetails('frontend')">点击查看详情</div>
        <div id="frontend" class="details">
            <p><strong>连接类型区分：</strong></p>
            <ul>
                <li><strong>普通网络连接（HTTP）：</strong>用于标准请求/响应，如GET/POST。</li>
                <li><strong>WebSocket连接：</strong>用于实时双向通信，如聊天、推送。</li>
            </ul>
            <p><strong>网关分发：</strong>Nginx作为网关，负责负载均衡、路由分发到后端服务。</p>
        </div>
    </div>

    <div class="section">
        <h2>2. 后端接收与校验环节</h2>
        <div class="step" onclick="toggleDetails('validation')">点击查看详情</div>
        <div id="validation" class="details">
            <p><strong>数据校验：</strong></p>
            <ul>
                <li>ID匹配：验证请求中的用户ID。</li>
                <li>Token匹配：JWT/OAuth验证用户身份。</li>
            </ul>
            <p><strong>用户确定：</strong>通过校验确定用户上下文，路由到相应业务模块。</p>
        </div>
    </div>

    <div class="section">
        <h2>3. 业务处理环节（读写操作）</h2>
        <div class="step" onclick="toggleDetails('business')">点击查看详情</div>
        <div id="business" class="details">
            <p><strong>读操作：</strong></p>
            <ol>
                <li>优先查询Redis缓存。</li>
                <li>未命中则查询数据库。</li>
                <li>查询后立即更新Redis（事务性）。</li>
            </ol>
            <p><strong>写操作：</strong></p>
            <ol>
                <li>检查Redis是否有数据。</li>
                <li>有：更新Redis和数据库（事务）。</li>
                <li>无：查询数据库，更新数据库和Redis（事务）。</li>
            </ol>
            <p><strong>Redis-DB同步：</strong>定时刷新机制，确保一致性。</p>
        </div>
    </div>

    <div class="section">
        <h2>4. 数据库架构与优化</h2>
        <div class="step" onclick="toggleDetails('database')">点击查看详情</div>
        <div id="database" class="details">
            <p><strong>分库分表：</strong>根据业务拆分数据库和表，降低单库压力。</p>
            <p><strong>热数据分离：</strong></p>
            <ul>
                <li>频繁查询热数据：抽取到独立服务器。</li>
                <li>不频繁冷数据：放到集合服务器。</li>
            </ul>
            <p><strong>事务保护：</strong>确保读写一致性，避免并发问题。</p>
            <p><strong>冷热数据备份：</strong>一个月前数据备份到冷数据库，支持查询但性能较低。</p>
        </div>
    </div>

    <div class="section">
        <h2>5. 模块化设计（高度解耦、内聚）</h2>
        <div class="step" onclick="toggleDetails('modules')">点击查看详情</div>
        <div id="modules" class="details">
            <div class="module"><strong>用户中台模块：</strong>负责认证、用户管理、权限控制。</div>
            <div class="module"><strong>缓存模块：</strong>Redis操作、定时刷新逻辑。</div>
            <div class="module"><strong>数据库模块：</strong>ORM、分库分表、事务管理。</div>
            <div class="module"><strong>业务模块：</strong>具体业务逻辑，如订单、查询等。</div>
            <div class="module"><strong>网关模块：</strong>Nginx配置、路由分发。</div>
            <div class="module"><strong>备份模块：</strong>冷数据迁移、备份策略。</div>
            <p>每个模块独立部署，支持微服务架构。</p>
        </div>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: true });

        window.addEventListener('load', function() {
            console.log('Window loaded');
            // 等待Mermaid渲染完成
            setTimeout(function() {
                console.log('Timeout triggered');
                const svg = document.querySelector('.mermaid svg');
                console.log('SVG found:', svg);
                if (svg) {
                    const texts = svg.querySelectorAll('text');
                    const tspans = svg.querySelectorAll('tspan');
                    const gs = svg.querySelectorAll('g');
                    console.log('Texts found:', texts.length);
                    console.log('Tspans found:', tspans.length);
                    console.log('Gs found:', gs.length);
                    gs.forEach(g => {
                        const text = g.textContent.trim();
                        if (text === 'HTTP' || text === 'WebSocket' || text === '前端App/Web' || text === 'Nginx网关' || text === '分发到后端服务' || text === '后端服务1' || text === '后端服务2' || text === '后端服务3' || text === '用户中台模块: 认证校验' || text === '业务模块: 操作处理') {
                            console.log('G with exact match:', text);
                            g.style.cursor = 'pointer';
                            g.addEventListener('click', function() {
                                let type;
                                if (text === 'HTTP') type = 'HTTP';
                                else if (text === 'WebSocket') type = 'WebSocket';
                                else if (text === '前端App/Web') type = 'frontend';
                                else if (text === 'Nginx网关') type = 'nginx';
                                else if (text === '分发到后端服务') type = 'distribution';
                                else if (text === '后端服务1' || text === '后端服务2' || text === '后端服务3') type = 'backend';
                                else if (text === '用户中台模块: 认证校验') type = 'user-middle-tier';
                                else if (text === '业务模块: 操作处理') type = 'business-module';
                                console.log('Clicked G:', type);
                                toggleTooltip(this, type);
                            });
                        }
                    });
                    [...texts, ...tspans].forEach(text => {
                        const content = text.textContent.trim();
                        console.log('Text/Tspan content:', content);
                        if (content.includes('HTTP') || content.includes('WebSocket')) {
                            console.log('Match found for:', content);
                            text.style.cursor = 'pointer';
                            text.style.fill = '#007bff'; // 蓝色表示可点击
                            text.addEventListener('click', function() {
                                const type = content.includes('HTTP') ? 'HTTP' : 'WebSocket';
                                console.log('Clicked:', type);
                                toggleTooltip(this, type);
                            });
                        }
                    });
                }
            }, 2000); // 增加延迟到2秒
        });

        let currentTooltip = null;
        let currentTarget = null;

        function toggleTooltip(target, type) {
            if (currentTooltip && currentTarget === target) {
                // 隐藏
                document.body.removeChild(currentTooltip);
                currentTooltip = null;
                currentTarget = null;
                return;
            }

            // 隐藏之前的
            if (currentTooltip) {
                document.body.removeChild(currentTooltip);
            }

            // 创建新的
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';

            let content = '';
            if (type === 'HTTP') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>HTTP连接说明</h4>
                    <p><strong>定义：</strong>超文本传输协议，用于客户端和服务器之间的请求-响应通信。</p>
                    <p><strong>特点：</strong>无状态、简单、易扩展。</p>
                    <p><strong>案例：</strong>用户登录、提交表单、API调用。</p>
                    <p><strong>优势：</strong>广泛支持，易缓存。</p>
                    <p><strong>劣势：</strong>不适合实时通信。</p>
                `;
            } else if (type === 'WebSocket') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>WebSocket连接说明</h4>
                    <p><strong>定义：</strong>全双工通信协议，允许服务器推送数据。</p>
                    <p><strong>特点：</strong>持久连接、低延迟、双向。</p>
                    <p><strong>案例：</strong>聊天、实时通知、游戏。</p>
                    <p><strong>优势：</strong>实时性强。</p>
                    <p><strong>劣势：</strong>实现复杂。</p>
                `;
            } else if (type === 'frontend') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>前端App/Web准备数据说明</h4>
                    <p><strong>基础校验数据：</strong></p>
                    <ul>
                        <li><strong>Token：</strong>根据用户ID生成，具有唯一性，用于身份验证。</li>
                        <li><strong>Token位置：</strong>通常放在HTTP请求头（Header）中，如Authorization: Bearer <token>。不建议放在请求体（Data）中，以避免暴露。</li>
                        <li><strong>其他必传数据：</strong>用户ID（用于关联）、时间戳（防止重放攻击）、请求签名（可选，用于额外安全）。</li>
                    </ul>
                    <p><strong>业务数据：</strong>根据具体操作上传，如表单数据、文件等（标识化处理）。</p>
                    <p><strong>注意：</strong>确保数据格式正确，敏感信息加密传输。</p>
                `;
            } else if (type === 'nginx') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>Nginx网关说明</h4>
                    <p><strong>作用：</strong>作为反向代理和负载均衡器，接收前端请求，分发到后端服务。</p>
                    <p><strong>主要功能：</strong></p>
                    <ul>
                        <li>负载均衡：轮询、IP哈希、最少连接等算法。</li>
                        <li>SSL/TLS终止：处理HTTPS加密。</li>
                        <li>缓存：静态资源缓存，减少后端压力。</li>
                        <li>安全：防火墙、限流、DDoS防护。</li>
                        <li>日志记录：请求日志，便于监控。</li>
                    </ul>
                    <p><strong>配置示例：</strong>upstream backend { server 127.0.0.1:8080; server 127.0.0.1:8081; } location /api { proxy_pass http://backend; }</p>
                    <p><strong>优势：</strong>高性能、轻量、易扩展。</p>
                `;
            } else if (type === 'distribution') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>分发到后端服务说明</h4>
                    <p><strong>作用：</strong>将请求分发到多个后端服务器，实现负载均衡和高可用性。</p>
                    <p><strong>主要功能：</strong></p>
                    <ul>
                        <li>负载均衡：根据算法（如轮询、权重）分配请求到不同服务器。</li>
                        <li>故障转移：检测服务器健康状态，自动切换到可用服务器。</li>
                        <li>扩展性：支持动态添加/移除服务器。</li>
                        <li>性能优化：减少单点压力，提高响应速度。</li>
                    </ul>
                    <p><strong>示例：</strong>请求被分发到后端服务1、2、3中的一个或多个。</p>
                    <p><strong>优势：</strong>提高系统可用性和性能。</p>
                `;
            } else if (type === 'backend') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>后端服务说明</h4>
                    <p><strong>多种部署情况：</strong></p>
                    <ul>
                        <li><strong>主备服务器（容灾备份）：</strong>纯粹的主备架构，用于备份和容灾。可以随时切换，确保服务连续性。主服务器处理正常流量，备服务器同步数据，故障时自动或手动切换。</li>
                        <li><strong>业务拆分（性能优化）：</strong>根据业务特点拆分，高频访问或高资源占用（如AI推理、AI训练）的业务单独部署到高性能服务器上；低资源占用的业务部署到低性能服务器上，实现资源合理分配。</li>
                        <li><strong>地理分布：</strong>不同地区的服务器部署，减少网络延迟，提高用户体验。</li>
                        <li><strong>负载均衡集群：</strong>多个相同配置的服务器组成集群，根据负载动态分配请求。</li>
                        <li><strong>安全隔离：</strong>敏感数据处理或高安全要求的业务部署到专用服务器。</li>
                        <li><strong>版本控制：</strong>用于A/B测试、灰度发布或多版本并存。</li>
                    </ul>
                    <p><strong>优势：</strong>提高可用性、性能和安全性。</p>
                `;
            } else if (type === 'user-middle-tier') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>用户中台模块: 认证校验与ID生成</h4>
                    <p><strong>核心功能：</strong>生成全局唯一ID，用于用户注册时的手机号、名字、密码等信息。</p>
                    <p><strong>数据库设计：</strong></p>
                    <ul>
                        <li><strong>号段概念：</strong>预分配ID号段，避免每次生成都访问数据库。</li>
                        <li><strong>步长概念：</strong>每次申请的ID数量，控制性能。</li>
                        <li><strong>表结构：</strong>t_id_generate_config，管理所有业务的ID生成配置。</li>
                    </ul>
                    <p><strong>并发控制机制：</strong></p>
                    <ul>
                        <li><strong>信号量：</strong>保证只有一个线程申请新号段，避免并发冲突。</li>
                        <li><strong>乐观锁：</strong>version字段控制并发更新，只有匹配版本的线程才能成功。</li>
                        <li><strong>异步线程池：</strong>号段刷新异步执行，不阻塞ID生成。</li>
                        <li><strong>阈值策略：</strong>号段使用率超过75%时异步申请新号段。</li>
                    </ul>
                    <p><strong>核心机制：</strong>一张表管理所有业务的ID生成，支持扩展枚举(IdTypeEnum)添加新业务类型。</p>
                    <p><strong>数据隔离方式：</strong></p>
                    <table border="1" style="border-collapse: collapse; width: 100%;">
                        <thead>
                            <tr>
                                <th>id</th>
                                <th>remark</th>
                                <th>step</th>
                                <th>current_start</th>
                                <th>next_threshold</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>1</td>
                                <td>用户ID</td>
                                <td>1000</td>
                                <td>1000</td>
                                <td>2000</td>
                            </tr>
                            <tr>
                                <td>2</td>
                                <td>订单ID</td>
                                <td>5000</td>
                                <td>10000</td>
                                <td>15000</td>
                            </tr>
                            <tr>
                                <td>3</td>
                                <td>礼物ID</td>
                                <td>10000</td>
                                <td>100000</td>
                                <td>110000</td>
                            </tr>
                            <tr>
                                <td>4</td>
                                <td>房间ID</td>
                                <td>1000</td>
                                <td>1000000</td>
                                <td>1001000</td>
                            </tr>
                        </tbody>
                    </table>
                    <p><strong>示例：</strong>用户ID从1开始，订单ID从10000开始，各有独立号段和步长配置。</p>
                `;
            } else if (type === 'business-module') {
                content = `
                    <span class="close-btn" onclick="closeTooltip()">×</span>
                    <h4>业务模块: 操作处理</h4>
                    <p><strong>模块功能：</strong>根据用户请求进行具体业务逻辑处理，区分是否需要数据库操作。</p>
                    <p><strong>处理逻辑：</strong></p>
                    <ul>
                        <li><strong>无需数据库操作：</strong>直接返回前端，数据闭环完成。</li>
                        <li><strong>需要数据库操作：</strong>进入Redis查询流程。</li>
                    </ul>
                    <p><strong>Redis查询命中后的循环处理：</strong></p>
                    <ul>
                        <li>数据返回业务模块，由业务模块再次处理。</li>
                        <li>业务模块判断是否需要进一步查询数据库。</li>
                        <li>如果需要，继续走数据库查询逻辑。</li>
                        <li>如果不需要，直接返回前端。</li>
                    </ul>
                    <p><strong>不需要读写查询数据库的操作（直接返回）：</strong></p>
                    <ul>
                        <li><strong>纯计算操作：</strong>如数学计算、数据格式转换、加密解密等。</li>
                        <li><strong>缓存查询：</strong>从Redis等缓存中获取数据，无需访问数据库。</li>
                        <li><strong>静态数据返回：</strong>返回配置数据、常量、枚举值等。</li>
                        <li><strong>外部API调用：</strong>调用第三方服务，处理结果后返回。</li>
                        <li><strong>状态检查：</strong>检查系统状态、服务可用性等。</li>
                    </ul>
                    <p><strong>需要读写查询数据库的操作（继续流程）：</strong></p>
                    <ul>
                        <li><strong>数据查询：</strong>从数据库读取用户数据、历史记录等。</li>
                        <li><strong>数据写入：</strong>插入新记录、更新现有数据、删除操作。</li>
                        <li><strong>事务处理：</strong>涉及多表操作，需要保证数据一致性。</li>
                        <li><strong>复杂业务逻辑：</strong>需要结合数据库数据进行判断和处理。</li>
                        <li><strong>数据验证：</strong>检查数据完整性、业务规则验证。</li>
                    </ul>
                    <p><strong>处理流程：</strong>根据操作类型决定是否进入读/写数据库流程，支持循环处理以优化性能。</p>
                `;
            }
            tooltip.innerHTML = content;

            document.body.appendChild(tooltip);

            // 定位到旁边
            const rect = target.getBoundingClientRect();
            const tooltipWidth = 300;
            const tooltipHeight = 200; // 估算
            let left, top = rect.top + window.scrollY;

            if (type === 'WebSocket') {
                left = rect.left + window.scrollX - tooltipWidth - 10;
            } else { // HTTP
                left = rect.right + window.scrollX + 10;
            }

            // 确保不超出视窗
            if (left < 0) left = 10;
            if (left + tooltipWidth > window.innerWidth) left = window.innerWidth - tooltipWidth - 10;
            if (top + tooltipHeight > window.innerHeight + window.scrollY) top = rect.top + window.scrollY - tooltipHeight - 10;

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';

            currentTooltip = tooltip;
            currentTarget = target;
        }

        function closeTooltip() {
            if (currentTooltip) {
                document.body.removeChild(currentTooltip);
                currentTooltip = null;
                currentTarget = null;
            }
        }
    </script>
</body>
</html>